import { o as __toESM } from "./chunk-C8U8pIma.mjs";
import { t as defineCommand$1 } from "./dist-sJJifug_.mjs";
import { n as colors } from "./consola.DXBYu-KD-BxkQ5_xB.mjs";
import "./utils-D5jIbZ8_.mjs";
import { i as c, r as a, t as D } from "./dist-KRhCJXtj.mjs";
import { a as legacyRootDirArgs, i as extendsArgs, n as dotEnvArgs, o as logLevelArgs, r as envNameArgs, t as cwdArgs } from "./_shared-CoPxtaYg.mjs";
import "./dist-CGV6T3ee.mjs";
import { n as logger, t as debug } from "./logger-TGEXLs5w.mjs";
import { c as resolve$1 } from "./pathe.M-eThtNZ-0R4k6vpe.mjs";
import "./defu-DcpjBOZc.mjs";
import "./env-Dgf3oimn.mjs";
import "./kit-BqwTIe0r.mjs";
import { a as require_lib, i as listenAndWatch, n as createDevServer, o as require_http_shutdown, r as listen } from "./utils--eSm-kwO.mjs";
import { n as isAbsolute$1 } from "./pathe.ff20891b-DxvP26Xy.mjs";
import "./satisfies--kW1HehR.mjs";
import { i as require_semver } from "./versions-CItnJg_E.mjs";
import "./banner-DR0HFUbH.mjs";
import "./fs-CN5CWQ-H.mjs";
import "./nuxt-ISq-9kSI.mjs";
import { initialize } from "./dev/index.mjs";
import process$1 from "node:process";
import { fork } from "node:child_process";

//#region ../../node_modules/.pnpm/citty@0.1.6/node_modules/citty/dist/index.mjs
function defineCommand(def) {
	return def;
}

//#endregion
//#region ../../node_modules/.pnpm/listhen@1.9.0/node_modules/listhen/dist/cli.mjs
var import_http_shutdown = /* @__PURE__ */ __toESM(require_http_shutdown(), 1);
var import_lib = /* @__PURE__ */ __toESM(require_lib(), 1);
const main = defineCommand({
	meta: {
		name: "listhen",
		description: "ðŸ‘‚ Elegant HTTP Listener",
		version: "1.8.0"
	},
	args: {
		cwd: {
			type: "string",
			description: "Current working directory"
		},
		entry: {
			type: "positional",
			description: "Listener entry file (./app.ts)",
			required: true
		},
		name: {
			type: "string",
			description: "Name to use in the banner"
		},
		baseURL: {
			type: "string",
			description: "Base URL to use"
		},
		watch: {
			type: "boolean",
			description: "Watch for changes",
			alias: "w"
		},
		ws: {
			type: "boolean",
			description: "Enable Experimental WebSocket support"
		},
		...getArgs()
	},
	async run({ args }) {
		const opts = {
			...args,
			...parseArgs$1(args),
			baseURL: args.baseURL,
			name: args.name
		};
		const entry = isAbsolute$1(args.entry) || args.entry.startsWith(".") ? args.entry : `./${args.entry}`;
		if (args.watch) await listenAndWatch(entry, opts);
		else {
			const devServer = await createDevServer(entry, opts);
			await listen(devServer.nodeListener, {
				...opts,
				_entry: devServer._entry,
				ws: opts.ws ? devServer._ws : void 0
			});
			await devServer.reload(true);
		}
	}
});
function getArgs() {
	return {
		port: {
			type: "string",
			description: "Port to listen on (use `PORT` environment variable to override)"
		},
		host: { description: "Host to listen on. If no value or an empty string provided, will listen on all available interfaces (use `HOST` environment variable to override)" },
		clipboard: {
			type: "boolean",
			description: "Copy the URL to the clipboard"
		},
		open: {
			type: "boolean",
			description: "Open the URL in the browser"
		},
		https: {
			type: "boolean",
			description: "Enable HTTPS"
		},
		"https.cert": {
			type: "string",
			description: "Path to TLS certificate used with HTTPS in PEM format"
		},
		"https.key": {
			type: "string",
			description: "Path to TLS key used with HTTPS in PEM format"
		},
		"https.pfx": {
			type: "string",
			description: "Path to PKCS#12 (.p12/.pfx) keystore containing a TLS certificate and Key"
		},
		"https.passphrase": {
			type: "string",
			description: "Passphrase used for TLS key or keystore"
		},
		"https.validityDays": {
			type: "string",
			description: "Validity in days of the autogenerated TLS certificate (https: true)"
		},
		"https.domains": {
			type: "string",
			description: "Comma seperated list of domains and IPs, the autogenerated certificate should be valid for (https: true)"
		},
		publicURL: {
			type: "string",
			description: "Displayed public URL (used for QR code)",
			required: false
		},
		qr: {
			type: "boolean",
			description: "Display The QR code of public URL when available",
			required: false
		},
		public: {
			type: "boolean",
			description: "Listen to all network interfaces",
			required: false
		},
		tunnel: {
			type: "boolean",
			description: "Open a tunnel using https://github.com/unjs/untun",
			required: false
		}
	};
}
function parseArgs$1(args) {
	return {
		port: args.port,
		hostname: typeof args.host === "string" ? args.host : args.host === true ? "" : void 0,
		clipboard: args.clipboard,
		open: args.open,
		qr: args.qr,
		publicURL: args.publicURL,
		public: args.public,
		tunnel: args.tunnel,
		https: args.https ? {
			cert: args["https.cert"],
			key: args["https.key"],
			pfx: args["https.pfx"],
			passphrase: args["https.passphrase"],
			validityDays: args["https.validityDays"] ? +args["https.validityDays"] : void 0,
			domains: args["https.domains"] ? args["https.domains"].split(",") : void 0
		} : false
	};
}

//#endregion
//#region src/dev/pool.ts
var import_semver = require_semver();
var ForkPool = class {
	pool = [];
	poolSize;
	rawArgs;
	listenOverrides;
	warming = false;
	constructor(options) {
		this.rawArgs = options.rawArgs;
		this.poolSize = options.poolSize ?? 2;
		this.listenOverrides = options.listenOverrides;
		for (const signal of [
			"exit",
			"SIGTERM",
			"SIGINT",
			"SIGQUIT"
		]) process$1.once(signal, () => {
			this.killAll(signal === "exit" ? 0 : signal);
		});
	}
	startWarming() {
		if (this.warming) return;
		this.warming = true;
		for (let i = 0; i < this.poolSize; i++) this.warmFork();
	}
	async getFork(context, onMessage) {
		const readyFork = this.pool.find((f) => f.state === "ready");
		if (readyFork) {
			readyFork.state = "active";
			if (onMessage) this.attachMessageHandler(readyFork.process, onMessage);
			await this.sendContext(readyFork.process, context);
			if (this.warming) this.warmFork();
			return () => this.killFork(readyFork);
		}
		const warmingFork = this.pool.find((f) => f.state === "warming");
		if (warmingFork) {
			await warmingFork.ready;
			warmingFork.state = "active";
			if (onMessage) this.attachMessageHandler(warmingFork.process, onMessage);
			await this.sendContext(warmingFork.process, context);
			if (this.warming) this.warmFork();
			return () => this.killFork(warmingFork);
		}
		debug("No pre-warmed forks available, starting cold fork");
		const coldFork = this.createFork();
		await coldFork.ready;
		coldFork.state = "active";
		if (onMessage) this.attachMessageHandler(coldFork.process, onMessage);
		await this.sendContext(coldFork.process, context);
		return () => this.killFork(coldFork);
	}
	attachMessageHandler(childProc, onMessage) {
		childProc.on("message", (message) => {
			if (message.type !== "nuxt:internal:dev:fork-ready") onMessage(message);
		});
	}
	warmFork() {
		const fork = this.createFork();
		fork.ready.then(() => {
			if (fork.state === "warming") fork.state = "ready";
		}).catch(() => {
			this.removeFork(fork);
		});
		this.pool.push(fork);
	}
	createFork() {
		const childProc = fork(globalThis.__nuxt_cli__.devEntry, this.rawArgs, {
			execArgv: ["--enable-source-maps", process$1.argv.find((a) => a.includes("--inspect"))].filter(Boolean),
			env: {
				...process$1.env,
				__NUXT__FORK: "true"
			}
		});
		let readyResolve;
		let readyReject;
		const pooledFork = {
			process: childProc,
			ready: new Promise((resolve, reject) => {
				readyResolve = resolve;
				readyReject = reject;
			}),
			state: "warming"
		};
		childProc.on("message", (message) => {
			if (message.type === "nuxt:internal:dev:fork-ready") readyResolve();
		});
		childProc.on("error", (err) => {
			readyReject(err);
			this.removeFork(pooledFork);
		});
		childProc.on("close", (errorCode) => {
			if (pooledFork.state === "active" && errorCode) process$1.exit(errorCode);
			this.removeFork(pooledFork);
		});
		return pooledFork;
	}
	async sendContext(childProc, context) {
		childProc.send({
			type: "nuxt:internal:dev:context",
			listenOverrides: this.listenOverrides,
			context
		});
	}
	killFork(fork, signal = "SIGTERM") {
		fork.state = "dead";
		if (fork.process) fork.process.kill(signal === 0 && D ? "SIGTERM" : signal);
		this.removeFork(fork);
	}
	removeFork(fork) {
		const index = this.pool.indexOf(fork);
		if (index > -1) this.pool.splice(index, 1);
	}
	killAll(signal) {
		for (const fork of this.pool) this.killFork(fork, signal);
	}
	getStats() {
		return {
			total: this.pool.length,
			warming: this.pool.filter((f) => f.state === "warming").length,
			ready: this.pool.filter((f) => f.state === "ready").length,
			active: this.pool.filter((f) => f.state === "active").length
		};
	}
};

//#endregion
//#region src/commands/dev.ts
const startTime = Date.now();
const forkSupported = !a && (!c || isBunForkSupported());
const listhenArgs = getArgs();
const command = defineCommand$1({
	meta: {
		name: "dev",
		description: "Run Nuxt development server"
	},
	args: {
		...cwdArgs,
		...logLevelArgs,
		...dotEnvArgs,
		...legacyRootDirArgs,
		...envNameArgs,
		...extendsArgs,
		clear: {
			type: "boolean",
			description: "Clear console on restart",
			default: false
		},
		fork: {
			type: "boolean",
			description: forkSupported ? "Disable forked mode" : "Enable forked mode",
			negativeDescription: "Disable forked mode",
			default: forkSupported,
			alias: ["f"]
		},
		...listhenArgs,
		port: {
			...listhenArgs.port,
			description: "Port to listen on (default: `NUXT_PORT || NITRO_PORT || PORT || nuxtOptions.devServer.port`)",
			alias: ["p"]
		},
		open: {
			...listhenArgs.open,
			alias: ["o"],
			default: false
		},
		host: {
			...listhenArgs.host,
			alias: ["h"],
			description: "Host to listen on (default: `NUXT_HOST || NITRO_HOST || HOST || nuxtOptions.devServer?.host`)"
		},
		clipboard: {
			...listhenArgs.clipboard,
			default: false
		},
		sslCert: {
			type: "string",
			description: "(DEPRECATED) Use `--https.cert` instead."
		},
		sslKey: {
			type: "string",
			description: "(DEPRECATED) Use `--https.key` instead."
		}
	},
	async run(ctx) {
		const cwd = resolve$1(ctx.args.cwd || ctx.args.rootDir);
		const listenOverrides = resolveListenOverrides(ctx.args);
		const { listener, close, onRestart, onReady } = await initialize({
			cwd,
			args: ctx.args
		}, {
			data: ctx.data,
			listenOverrides,
			showBanner: true
		});
		if (!ctx.args.fork) return {
			listener,
			close
		};
		const pool = new ForkPool({
			rawArgs: ctx.rawArgs,
			poolSize: 2,
			listenOverrides
		});
		onReady((_address) => {
			pool.startWarming();
			if (startTime) debug(`Dev server ready for connections in ${Date.now() - startTime}ms`);
		});
		let cleanupCurrentFork;
		async function restartWithFork() {
			const context = {
				cwd,
				args: ctx.args
			};
			cleanupCurrentFork?.();
			cleanupCurrentFork = await pool.getFork(context, (message) => {
				if (message.type === "nuxt:internal:dev:ready") {
					if (startTime) debug(`Dev server ready for connections in ${Date.now() - startTime}ms`);
				} else if (message.type === "nuxt:internal:dev:restart") restartWithFork();
				else if (message.type === "nuxt:internal:dev:rejection") {
					logger.info(`Restarting Nuxt due to error: ${colors.cyan(message.message)}`);
					restartWithFork();
				}
			});
		}
		onRestart(async () => {
			await close();
			await restartWithFork();
		});
		return { async close() {
			cleanupCurrentFork?.();
			await Promise.all([listener.close(), close()]);
		} };
	}
});
function resolveListenOverrides(args) {
	if (process$1.env._PORT) return {
		port: process$1.env._PORT || 0,
		hostname: "127.0.0.1",
		showURL: false
	};
	const options = parseArgs$1({
		...args,
		"host": args.host || process$1.env.NUXT_HOST || process$1.env.NITRO_HOST || process$1.env.HOST,
		"port": args.port || process$1.env.NUXT_PORT || process$1.env.NITRO_PORT || process$1.env.PORT,
		"https": args.https !== false && args.https !== "false",
		"https.cert": args["https.cert"] || args.sslCert || process$1.env.NUXT_SSL_CERT || process$1.env.NITRO_SSL_CERT,
		"https.key": args["https.key"] || args.sslKey || process$1.env.NUXT_SSL_KEY || process$1.env.NITRO_SSL_KEY
	});
	return {
		...options,
		_https: args.https,
		get https() {
			const httpsArg = this._https;
			if (httpsArg === false || httpsArg === "false") return false;
			return httpsArg ? options.https : false;
		}
	};
}
function isBunForkSupported() {
	const bunVersion = globalThis.Bun.version;
	return (0, import_semver.satisfies)(bunVersion, ">=1.2");
}

//#endregion
export { command as default };