import { i as __require, o as __toESM, t as __commonJSMin } from "./chunk-C8U8pIma.mjs";
import { n as colors$2, r as getColor } from "./consola.DXBYu-KD-BxkQ5_xB.mjs";
import { a as p$2 } from "./dist-KRhCJXtj.mjs";
import { t as consola } from "./dist-CGV6T3ee.mjs";
import { i as supportsColor, r as init_supports_color } from "./logger-TGEXLs5w.mjs";
import { a as join$1, c as resolve$2, i as isAbsolute$1 } from "./pathe.M-eThtNZ-0R4k6vpe.mjs";
import { t as defu } from "./defu-DcpjBOZc.mjs";
import { a as resolveModulePath, i as withNodePath, t as loadKit } from "./kit-BqwTIe0r.mjs";
import { n as joinURL } from "./dist-HcWZhMNe.mjs";
import { a as relative, o as resolve$3, r as join$2, t as dirname$2 } from "./pathe.ff20891b-DxvP26Xy.mjs";
import { t as debounce } from "./dist-BuzUXIai.mjs";
import { r as toNodeHandler } from "./node-Bj1neqoF.mjs";
import { r as showVersionsFromConfig } from "./banner-DR0HFUbH.mjs";
import { t as clearBuildDir } from "./fs-CN5CWQ-H.mjs";
import { a as writeNuxtManifest, i as resolveNuxtManifest, n as loadNuxtManifest } from "./nuxt-ISq-9kSI.mjs";
import { builtinModules, createRequire } from "node:module";
import path, { dirname, extname, join } from "node:path";
import process$1 from "node:process";
import { format, inspect, promisify } from "node:util";
import assert from "node:assert";
import { URL as URL$1, fileURLToPath, pathToFileURL } from "node:url";
import fs, { accessSync, constants, existsSync, promises, readFileSync, readdirSync, realpathSync, statSync, watch } from "node:fs";
import { debuglog as debuglog$1, inspect as inspect$1 } from "util";
import os, { networkInterfaces, tmpdir } from "node:os";
import EventEmitter from "node:events";
import { mkdir, readFile, rm, stat } from "node:fs/promises";
import v8 from "node:v8";
import { createServer } from "node:http";
import { createServer as createServer$1 } from "node:https";
import { createServer as createServer$2 } from "node:net";
import childProcess from "node:child_process";
import { readFile as readFile$1 } from "fs/promises";
import { extname as extname$1 } from "path";
import { fileURLToPath as fileURLToPath$1 } from "url";

//#region ../../node_modules/.pnpm/h3@1.15.5/node_modules/h3/dist/index.mjs
function hasProp$1(obj, prop) {
	try {
		return prop in obj;
	} catch {
		return false;
	}
}
var H3Error = class extends Error {
	static __h3_error__ = true;
	statusCode = 500;
	fatal = false;
	unhandled = false;
	statusMessage;
	data;
	cause;
	constructor(message, opts = {}) {
		super(message, opts);
		if (opts.cause && !this.cause) this.cause = opts.cause;
	}
	toJSON() {
		const obj = {
			message: this.message,
			statusCode: sanitizeStatusCode(this.statusCode, 500)
		};
		if (this.statusMessage) obj.statusMessage = sanitizeStatusMessage(this.statusMessage);
		if (this.data !== void 0) obj.data = this.data;
		return obj;
	}
};
function createError$1(input) {
	if (typeof input === "string") return new H3Error(input);
	if (isError$1(input)) return input;
	const err = new H3Error(input.message ?? input.statusMessage ?? "", { cause: input.cause || input });
	if (hasProp$1(input, "stack")) try {
		Object.defineProperty(err, "stack", { get() {
			return input.stack;
		} });
	} catch {
		try {
			err.stack = input.stack;
		} catch {}
	}
	if (input.data) err.data = input.data;
	if (input.statusCode) err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);
	else if (input.status) err.statusCode = sanitizeStatusCode(input.status, err.statusCode);
	if (input.statusMessage) err.statusMessage = input.statusMessage;
	else if (input.statusText) err.statusMessage = input.statusText;
	if (err.statusMessage) {
		const originalMessage = err.statusMessage;
		if (sanitizeStatusMessage(err.statusMessage) !== originalMessage) console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.");
	}
	if (input.fatal !== void 0) err.fatal = input.fatal;
	if (input.unhandled !== void 0) err.unhandled = input.unhandled;
	return err;
}
function sendError(event, error, debug) {
	if (event.handled) return;
	const h3Error = isError$1(error) ? error : createError$1(error);
	const responseBody = {
		statusCode: h3Error.statusCode,
		statusMessage: h3Error.statusMessage,
		stack: [],
		data: h3Error.data
	};
	if (debug) responseBody.stack = (h3Error.stack || "").split("\n").map((l) => l.trim());
	if (event.handled) return;
	setResponseStatus(event, Number.parseInt(h3Error.statusCode), h3Error.statusMessage);
	event.node.res.setHeader("content-type", MIMES.json);
	event.node.res.end(JSON.stringify(responseBody, void 0, 2));
}
function isError$1(input) {
	return input?.constructor?.__h3_error__ === true;
}
const RawBodySymbol = Symbol.for("h3RawBody");
const ParsedBodySymbol = Symbol.for("h3ParsedBody");
const MIMES = {
	html: "text/html",
	json: "application/json"
};
const DISALLOWED_STATUS_CHARS = /[^\u0009\u0020-\u007E]/g;
function sanitizeStatusMessage(statusMessage = "") {
	return statusMessage.replace(DISALLOWED_STATUS_CHARS, "");
}
function sanitizeStatusCode(statusCode, defaultStatusCode = 200) {
	if (!statusCode) return defaultStatusCode;
	if (typeof statusCode === "string") statusCode = Number.parseInt(statusCode, 10);
	if (statusCode < 100 || statusCode > 999) return defaultStatusCode;
	return statusCode;
}
function splitCookiesString(cookiesString) {
	if (Array.isArray(cookiesString)) return cookiesString.flatMap((c) => splitCookiesString(c));
	if (typeof cookiesString !== "string") return [];
	const cookiesStrings = [];
	let pos = 0;
	let start;
	let ch;
	let lastComma;
	let nextStart;
	let cookiesSeparatorFound;
	const skipWhitespace = () => {
		while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) pos += 1;
		return pos < cookiesString.length;
	};
	const notSpecialChar = () => {
		ch = cookiesString.charAt(pos);
		return ch !== "=" && ch !== ";" && ch !== ",";
	};
	while (pos < cookiesString.length) {
		start = pos;
		cookiesSeparatorFound = false;
		while (skipWhitespace()) {
			ch = cookiesString.charAt(pos);
			if (ch === ",") {
				lastComma = pos;
				pos += 1;
				skipWhitespace();
				nextStart = pos;
				while (pos < cookiesString.length && notSpecialChar()) pos += 1;
				if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
					cookiesSeparatorFound = true;
					pos = nextStart;
					cookiesStrings.push(cookiesString.slice(start, lastComma));
					start = pos;
				} else pos = lastComma + 1;
			} else pos += 1;
		}
		if (!cookiesSeparatorFound || pos >= cookiesString.length) cookiesStrings.push(cookiesString.slice(start));
	}
	return cookiesStrings;
}
function setResponseStatus(event, code, text) {
	if (code) event.node.res.statusCode = sanitizeStatusCode(code, event.node.res.statusCode);
	if (text) event.node.res.statusMessage = sanitizeStatusMessage(text);
}
function sendStream(event, stream) {
	if (!stream || typeof stream !== "object") throw new Error("[h3] Invalid stream provided.");
	event.node.res._data = stream;
	if (!event.node.res.socket) {
		event._handled = true;
		return Promise.resolve();
	}
	if (hasProp$1(stream, "pipeTo") && typeof stream.pipeTo === "function") return stream.pipeTo(new WritableStream({ write(chunk) {
		event.node.res.write(chunk);
	} })).then(() => {
		event.node.res.end();
	});
	if (hasProp$1(stream, "pipe") && typeof stream.pipe === "function") return new Promise((resolve, reject) => {
		stream.pipe(event.node.res);
		if (stream.on) {
			stream.on("end", () => {
				event.node.res.end();
				resolve();
			});
			stream.on("error", (error) => {
				reject(error);
			});
		}
		event.node.res.on("close", () => {
			if (stream.abort) stream.abort();
		});
	});
	throw new Error("[h3] Invalid or incompatible stream provided.");
}
function sendWebResponse(event, response) {
	for (const [key, value] of response.headers) if (key === "set-cookie") event.node.res.appendHeader(key, splitCookiesString(value));
	else event.node.res.setHeader(key, value);
	if (response.status) event.node.res.statusCode = sanitizeStatusCode(response.status, event.node.res.statusCode);
	if (response.statusText) event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
	if (response.redirected) event.node.res.setHeader("location", response.url);
	if (!response.body) {
		event.node.res.end();
		return;
	}
	return sendStream(event, response.body);
}
var H3Event = class {
	"__is_event__" = true;
	node;
	web;
	context = {};
	_method;
	_path;
	_headers;
	_requestBody;
	_handled = false;
	_onBeforeResponseCalled;
	_onAfterResponseCalled;
	constructor(req, res) {
		this.node = {
			req,
			res
		};
	}
	get method() {
		if (!this._method) this._method = (this.node.req.method || "GET").toUpperCase();
		return this._method;
	}
	get path() {
		return this._path || this.node.req.url || "/";
	}
	get headers() {
		if (!this._headers) this._headers = _normalizeNodeHeaders(this.node.req.headers);
		return this._headers;
	}
	get handled() {
		return this._handled || this.node.res.writableEnded || this.node.res.headersSent;
	}
	respondWith(response) {
		return Promise.resolve(response).then((_response) => sendWebResponse(this, _response));
	}
	toString() {
		return `[${this.method}] ${this.path}`;
	}
	toJSON() {
		return this.toString();
	}
	/** @deprecated Please use `event.node.req` instead. */
	get req() {
		return this.node.req;
	}
	/** @deprecated Please use `event.node.res` instead. */
	get res() {
		return this.node.res;
	}
};
function createEvent(req, res) {
	return new H3Event(req, res);
}
function _normalizeNodeHeaders(nodeHeaders) {
	const headers = new Headers();
	for (const [name, value] of Object.entries(nodeHeaders)) if (Array.isArray(value)) for (const item of value) headers.append(name, item);
	else if (value) headers.set(name, value);
	return headers;
}
const H3Headers = globalThis.Headers;
const H3Response = globalThis.Response;
function toNodeListener(app) {
	const toNodeHandle = async function(req, res) {
		const event = createEvent(req, res);
		try {
			await app.handler(event);
		} catch (_error) {
			const error = createError$1(_error);
			if (!isError$1(_error)) error.unhandled = true;
			setResponseStatus(event, error.statusCode, error.statusMessage);
			if (app.options.onError) await app.options.onError(error, event);
			if (event.handled) return;
			if (error.unhandled || error.fatal) console.error("[h3]", error.fatal ? "[fatal]" : "[unhandled]", error);
			if (app.options.onBeforeResponse && !event._onBeforeResponseCalled) await app.options.onBeforeResponse(event, { body: error });
			await sendError(event, error, !!app.options.debug);
			if (app.options.onAfterResponse && !event._onAfterResponseCalled) await app.options.onAfterResponse(event, { body: error });
		}
	};
	return toNodeHandle;
}

//#endregion
//#region ../../node_modules/.pnpm/get-port-please@3.2.0/node_modules/get-port-please/dist/index.mjs
const unsafePorts = /* @__PURE__ */ new Set([
	1,
	7,
	9,
	11,
	13,
	15,
	17,
	19,
	20,
	21,
	22,
	23,
	25,
	37,
	42,
	43,
	53,
	69,
	77,
	79,
	87,
	95,
	101,
	102,
	103,
	104,
	109,
	110,
	111,
	113,
	115,
	117,
	119,
	123,
	135,
	137,
	139,
	143,
	161,
	179,
	389,
	427,
	465,
	512,
	513,
	514,
	515,
	526,
	530,
	531,
	532,
	540,
	548,
	554,
	556,
	563,
	587,
	601,
	636,
	989,
	990,
	993,
	995,
	1719,
	1720,
	1723,
	2049,
	3659,
	4045,
	5060,
	5061,
	6e3,
	6566,
	6665,
	6666,
	6667,
	6668,
	6669,
	6697,
	10080
]);
function isUnsafePort(port) {
	return unsafePorts.has(port);
}
function isSafePort(port) {
	return !isUnsafePort(port);
}
var GetPortError = class extends Error {
	constructor(message, opts) {
		super(message, opts);
		this.message = message;
	}
	name = "GetPortError";
};
function _log(verbose, message) {
	if (verbose) console.log(`[get-port] ${message}`);
}
function _generateRange(from, to) {
	if (to < from) return [];
	const r = [];
	for (let index = from; index <= to; index++) r.push(index);
	return r;
}
function _tryPort(port, host) {
	return new Promise((resolve) => {
		const server = createServer$2();
		server.unref();
		server.on("error", () => {
			resolve(false);
		});
		server.listen({
			port,
			host
		}, () => {
			const { port: port2 } = server.address();
			server.close(() => {
				resolve(isSafePort(port2) && port2);
			});
		});
	});
}
function _getLocalHosts(additional) {
	const hosts = new Set(additional);
	for (const _interface of Object.values(networkInterfaces())) for (const config of _interface || []) if (config.address && !config.internal && !config.address.startsWith("fe80::") && !config.address.startsWith("169.254")) hosts.add(config.address);
	return [...hosts];
}
async function _findPort(ports, host) {
	for (const port of ports) {
		const r = await _tryPort(port, host);
		if (r) return r;
	}
}
function _fmtOnHost(hostname) {
	return hostname ? `on host ${JSON.stringify(hostname)}` : "on any host";
}
const HOSTNAME_RE$1 = /^(?!-)[\d.:A-Za-z-]{1,63}(?<!-)$/;
function _validateHostname(hostname, _public, verbose) {
	if (hostname && !HOSTNAME_RE$1.test(hostname)) {
		const fallbackHost = _public ? "0.0.0.0" : "127.0.0.1";
		_log(verbose, `Invalid hostname: ${JSON.stringify(hostname)}. Using ${JSON.stringify(fallbackHost)} as fallback.`);
		return fallbackHost;
	}
	return hostname;
}
async function getPort(_userOptions = {}) {
	if (typeof _userOptions === "number" || typeof _userOptions === "string") _userOptions = { port: Number.parseInt(_userOptions + "") || 0 };
	const _port = Number(_userOptions.port ?? process.env.PORT);
	const _userSpecifiedAnyPort = Boolean(_userOptions.port || _userOptions.ports?.length || _userOptions.portRange?.length);
	const options = {
		random: _port === 0,
		ports: [],
		portRange: [],
		alternativePortRange: _userSpecifiedAnyPort ? [] : [3e3, 3100],
		verbose: false,
		..._userOptions,
		port: _port,
		host: _validateHostname(_userOptions.host ?? process.env.HOST, _userOptions.public, _userOptions.verbose)
	};
	if (options.random && !_userSpecifiedAnyPort) return getRandomPort(options.host);
	const portsToCheck = [
		options.port,
		...options.ports,
		..._generateRange(...options.portRange)
	].filter((port) => {
		if (!port) return false;
		if (!isSafePort(port)) {
			_log(options.verbose, `Ignoring unsafe port: ${port}`);
			return false;
		}
		return true;
	});
	if (portsToCheck.length === 0) portsToCheck.push(3e3);
	let availablePort = await _findPort(portsToCheck, options.host);
	if (!availablePort && options.alternativePortRange.length > 0) {
		availablePort = await _findPort(_generateRange(...options.alternativePortRange), options.host);
		if (portsToCheck.length > 0) {
			let message = `Unable to find an available port (tried ${portsToCheck.join("-")} ${_fmtOnHost(options.host)}).`;
			if (availablePort) message += ` Using alternative port ${availablePort}.`;
			_log(options.verbose, message);
		}
	}
	if (!availablePort && _userOptions.random !== false) {
		availablePort = await getRandomPort(options.host);
		if (availablePort) _log(options.verbose, `Using random port ${availablePort}`);
	}
	if (!availablePort) {
		const triedRanges = [
			options.port,
			options.portRange.join("-"),
			options.alternativePortRange.join("-")
		].filter(Boolean).join(", ");
		throw new GetPortError(`Unable to find an available port ${_fmtOnHost(options.host)} (tried ${triedRanges})`);
	}
	return availablePort;
}
async function getRandomPort(host) {
	const port = await checkPort(0, host);
	if (port === false) throw new GetPortError(`Unable to find a random port ${_fmtOnHost(host)}`);
	return port;
}
async function checkPort(port, host = process.env.HOST, verbose) {
	if (!host) host = _getLocalHosts([void 0, "0.0.0.0"]);
	if (!Array.isArray(host)) return _tryPort(port, host);
	for (const _host of host) {
		const _port = await _tryPort(port, _host);
		if (_port === false) {
			if (port < 1024 && verbose) _log(verbose, `Unable to listen to the privileged port ${port} ${_fmtOnHost(_host)}`);
			return false;
		}
		if (port === 0 && _port !== 0) port = _port;
	}
	return port;
}

//#endregion
//#region ../../node_modules/.pnpm/http-shutdown@1.2.2/node_modules/http-shutdown/index.js
var require_http_shutdown = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var http = __require("http");
	var https = __require("https");
	/**
	* Expose `addShutdown`.
	*/
	exports = module.exports = addShutdown;
	/**
	* Adds shutdown functionaility to the `http.Server` object
	* @param {http.Server} server The server to add shutdown functionaility to
	*/
	function addShutdown(server) {
		var connections = {};
		var isShuttingDown = false;
		var connectionCounter = 0;
		function destroy(socket, force) {
			if (force || socket._isIdle && isShuttingDown) {
				socket.destroy();
				delete connections[socket._connectionId];
			}
		}
		function onConnection(socket) {
			var id = connectionCounter++;
			socket._isIdle = true;
			socket._connectionId = id;
			connections[id] = socket;
			socket.on("close", function() {
				delete connections[id];
			});
		}
		server.on("request", function(req, res) {
			req.socket._isIdle = false;
			res.on("finish", function() {
				req.socket._isIdle = true;
				destroy(req.socket);
			});
		});
		server.on("connection", onConnection);
		server.on("secureConnection", onConnection);
		function shutdown(force, cb) {
			isShuttingDown = true;
			server.close(function(err) {
				if (cb) process.nextTick(function() {
					cb(err);
				});
			});
			Object.keys(connections).forEach(function(key) {
				destroy(connections[key], force);
			});
		}
		server.shutdown = function(cb) {
			shutdown(false, cb);
		};
		server.forceShutdown = function(cb) {
			shutdown(true, cb);
		};
		return server;
	}
	/**
	* Extends the {http.Server} object with shutdown functionaility.
	* @return {http.Server} The decorated server object
	*/
	exports.extend = function() {
		http.Server.prototype.withShutdown = function() {
			return addShutdown(this);
		};
		https.Server.prototype.withShutdown = function() {
			return addShutdown(this);
		};
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/uqr@0.1.2/node_modules/uqr/dist/index.mjs
var QrCodeDataType = /* @__PURE__ */ ((QrCodeDataType2) => {
	QrCodeDataType2[QrCodeDataType2["Border"] = -1] = "Border";
	QrCodeDataType2[QrCodeDataType2["Data"] = 0] = "Data";
	QrCodeDataType2[QrCodeDataType2["Function"] = 1] = "Function";
	QrCodeDataType2[QrCodeDataType2["Position"] = 2] = "Position";
	QrCodeDataType2[QrCodeDataType2["Timing"] = 3] = "Timing";
	QrCodeDataType2[QrCodeDataType2["Alignment"] = 4] = "Alignment";
	return QrCodeDataType2;
})(QrCodeDataType || {});
var __defProp$1 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
	enumerable: true,
	configurable: true,
	writable: true,
	value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
	__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
	return value;
};
const LOW = [0, 1];
const MEDIUM = [1, 0];
const QUARTILE = [2, 3];
const HIGH = [3, 2];
const EccMap = {
	L: LOW,
	M: MEDIUM,
	Q: QUARTILE,
	H: HIGH
};
const NUMERIC_REGEX = /^[0-9]*$/;
const ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
const ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
const MIN_VERSION = 1;
const MAX_VERSION = 40;
const PENALTY_N1 = 3;
const PENALTY_N2 = 3;
const PENALTY_N3 = 40;
const PENALTY_N4 = 10;
const ECC_CODEWORDS_PER_BLOCK = [
	[
		-1,
		7,
		10,
		15,
		20,
		26,
		18,
		20,
		24,
		30,
		18,
		20,
		24,
		26,
		30,
		22,
		24,
		28,
		30,
		28,
		28,
		28,
		28,
		30,
		30,
		26,
		28,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30
	],
	[
		-1,
		10,
		16,
		26,
		18,
		24,
		16,
		18,
		22,
		22,
		26,
		30,
		22,
		22,
		24,
		24,
		28,
		28,
		26,
		26,
		26,
		26,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28,
		28
	],
	[
		-1,
		13,
		22,
		18,
		26,
		18,
		24,
		18,
		22,
		20,
		24,
		28,
		26,
		24,
		20,
		30,
		24,
		28,
		28,
		26,
		30,
		28,
		30,
		30,
		30,
		30,
		28,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30
	],
	[
		-1,
		17,
		28,
		22,
		16,
		22,
		28,
		26,
		26,
		24,
		28,
		24,
		28,
		22,
		24,
		24,
		30,
		28,
		28,
		26,
		28,
		30,
		24,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30,
		30
	]
];
const NUM_ERROR_CORRECTION_BLOCKS = [
	[
		-1,
		1,
		1,
		1,
		1,
		1,
		2,
		2,
		2,
		2,
		4,
		4,
		4,
		4,
		4,
		6,
		6,
		6,
		6,
		7,
		8,
		8,
		9,
		9,
		10,
		12,
		12,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		19,
		19,
		20,
		21,
		22,
		24,
		25
	],
	[
		-1,
		1,
		1,
		1,
		2,
		2,
		4,
		4,
		4,
		5,
		5,
		5,
		8,
		9,
		9,
		10,
		10,
		11,
		13,
		14,
		16,
		17,
		17,
		18,
		20,
		21,
		23,
		25,
		26,
		28,
		29,
		31,
		33,
		35,
		37,
		38,
		40,
		43,
		45,
		47,
		49
	],
	[
		-1,
		1,
		1,
		2,
		2,
		4,
		4,
		6,
		6,
		8,
		8,
		8,
		10,
		12,
		16,
		12,
		17,
		16,
		18,
		21,
		20,
		23,
		23,
		25,
		27,
		29,
		34,
		34,
		35,
		38,
		40,
		43,
		45,
		48,
		51,
		53,
		56,
		59,
		62,
		65,
		68
	],
	[
		-1,
		1,
		1,
		2,
		4,
		4,
		4,
		5,
		6,
		8,
		8,
		11,
		11,
		16,
		16,
		18,
		16,
		19,
		21,
		25,
		25,
		25,
		34,
		30,
		32,
		35,
		37,
		40,
		42,
		45,
		48,
		51,
		54,
		57,
		60,
		63,
		66,
		70,
		74,
		77,
		81
	]
];
var QrCode = class {
	constructor(version, ecc, dataCodewords, msk) {
		this.version = version;
		this.ecc = ecc;
		__publicField(this, "size");
		__publicField(this, "mask");
		__publicField(this, "modules", []);
		__publicField(this, "types", []);
		if (version < MIN_VERSION || version > MAX_VERSION) throw new RangeError("Version value out of range");
		if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");
		this.size = version * 4 + 17;
		const row = Array.from({ length: this.size }, () => false);
		for (let i = 0; i < this.size; i++) {
			this.modules.push(row.slice());
			this.types.push(row.map(() => 0));
		}
		this.drawFunctionPatterns();
		const allCodewords = this.addEccAndInterleave(dataCodewords);
		this.drawCodewords(allCodewords);
		if (msk === -1) {
			let minPenalty = 1e9;
			for (let i = 0; i < 8; i++) {
				this.applyMask(i);
				this.drawFormatBits(i);
				const penalty = this.getPenaltyScore();
				if (penalty < minPenalty) {
					msk = i;
					minPenalty = penalty;
				}
				this.applyMask(i);
			}
		}
		this.mask = msk;
		this.applyMask(msk);
		this.drawFormatBits(msk);
	}
	getModule(x, y) {
		return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];
	}
	drawFunctionPatterns() {
		for (let i = 0; i < this.size; i++) {
			this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);
			this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);
		}
		this.drawFinderPattern(3, 3);
		this.drawFinderPattern(this.size - 4, 3);
		this.drawFinderPattern(3, this.size - 4);
		const alignPatPos = this.getAlignmentPatternPositions();
		const numAlign = alignPatPos.length;
		for (let i = 0; i < numAlign; i++) for (let j = 0; j < numAlign; j++) if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0)) this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
		this.drawFormatBits(0);
		this.drawVersion();
	}
	drawFormatBits(mask) {
		const data = this.ecc[1] << 3 | mask;
		let rem = data;
		for (let i = 0; i < 10; i++) rem = rem << 1 ^ (rem >>> 9) * 1335;
		const bits = (data << 10 | rem) ^ 21522;
		for (let i = 0; i <= 5; i++) this.setFunctionModule(8, i, getBit(bits, i));
		this.setFunctionModule(8, 7, getBit(bits, 6));
		this.setFunctionModule(8, 8, getBit(bits, 7));
		this.setFunctionModule(7, 8, getBit(bits, 8));
		for (let i = 9; i < 15; i++) this.setFunctionModule(14 - i, 8, getBit(bits, i));
		for (let i = 0; i < 8; i++) this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
		for (let i = 8; i < 15; i++) this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
		this.setFunctionModule(8, this.size - 8, true);
	}
	drawVersion() {
		if (this.version < 7) return;
		let rem = this.version;
		for (let i = 0; i < 12; i++) rem = rem << 1 ^ (rem >>> 11) * 7973;
		const bits = this.version << 12 | rem;
		for (let i = 0; i < 18; i++) {
			const color = getBit(bits, i);
			const a = this.size - 11 + i % 3;
			const b = Math.floor(i / 3);
			this.setFunctionModule(a, b, color);
			this.setFunctionModule(b, a, color);
		}
	}
	drawFinderPattern(x, y) {
		for (let dy = -4; dy <= 4; dy++) for (let dx = -4; dx <= 4; dx++) {
			const dist = Math.max(Math.abs(dx), Math.abs(dy));
			const xx = x + dx;
			const yy = y + dy;
			if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size) this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);
		}
	}
	drawAlignmentPattern(x, y) {
		for (let dy = -2; dy <= 2; dy++) for (let dx = -2; dx <= 2; dx++) this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) !== 1, QrCodeDataType.Alignment);
	}
	setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {
		this.modules[y][x] = isDark;
		this.types[y][x] = type;
	}
	addEccAndInterleave(data) {
		const ver = this.version;
		const ecl = this.ecc;
		if (data.length !== getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");
		const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
		const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];
		const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);
		const numShortBlocks = numBlocks - rawCodewords % numBlocks;
		const shortBlockLen = Math.floor(rawCodewords / numBlocks);
		const blocks = [];
		const rsDiv = reedSolomonComputeDivisor(blockEccLen);
		for (let i = 0, k = 0; i < numBlocks; i++) {
			const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
			k += dat.length;
			const ecc = reedSolomonComputeRemainder(dat, rsDiv);
			if (i < numShortBlocks) dat.push(0);
			blocks.push(dat.concat(ecc));
		}
		const result = [];
		for (let i = 0; i < blocks[0].length; i++) blocks.forEach((block, j) => {
			if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[i]);
		});
		return result;
	}
	drawCodewords(data) {
		if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");
		let i = 0;
		for (let right = this.size - 1; right >= 1; right -= 2) {
			if (right === 6) right = 5;
			for (let vert = 0; vert < this.size; vert++) for (let j = 0; j < 2; j++) {
				const x = right - j;
				const y = (right + 1 & 2) === 0 ? this.size - 1 - vert : vert;
				if (!this.types[y][x] && i < data.length * 8) {
					this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
					i++;
				}
			}
		}
	}
	applyMask(mask) {
		if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");
		for (let y = 0; y < this.size; y++) for (let x = 0; x < this.size; x++) {
			let invert;
			switch (mask) {
				case 0:
					invert = (x + y) % 2 === 0;
					break;
				case 1:
					invert = y % 2 === 0;
					break;
				case 2:
					invert = x % 3 === 0;
					break;
				case 3:
					invert = (x + y) % 3 === 0;
					break;
				case 4:
					invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;
					break;
				case 5:
					invert = x * y % 2 + x * y % 3 === 0;
					break;
				case 6:
					invert = (x * y % 2 + x * y % 3) % 2 === 0;
					break;
				case 7:
					invert = ((x + y) % 2 + x * y % 3) % 2 === 0;
					break;
				default: throw new Error("Unreachable");
			}
			if (!this.types[y][x] && invert) this.modules[y][x] = !this.modules[y][x];
		}
	}
	getPenaltyScore() {
		let result = 0;
		for (let y = 0; y < this.size; y++) {
			let runColor = false;
			let runX = 0;
			const runHistory = [
				0,
				0,
				0,
				0,
				0,
				0,
				0
			];
			for (let x = 0; x < this.size; x++) if (this.modules[y][x] === runColor) {
				runX++;
				if (runX === 5) result += PENALTY_N1;
				else if (runX > 5) result++;
			} else {
				this.finderPenaltyAddHistory(runX, runHistory);
				if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
				runColor = this.modules[y][x];
				runX = 1;
			}
			result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;
		}
		for (let x = 0; x < this.size; x++) {
			let runColor = false;
			let runY = 0;
			const runHistory = [
				0,
				0,
				0,
				0,
				0,
				0,
				0
			];
			for (let y = 0; y < this.size; y++) if (this.modules[y][x] === runColor) {
				runY++;
				if (runY === 5) result += PENALTY_N1;
				else if (runY > 5) result++;
			} else {
				this.finderPenaltyAddHistory(runY, runHistory);
				if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
				runColor = this.modules[y][x];
				runY = 1;
			}
			result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;
		}
		for (let y = 0; y < this.size - 1; y++) for (let x = 0; x < this.size - 1; x++) {
			const color = this.modules[y][x];
			if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1]) result += PENALTY_N2;
		}
		let dark = 0;
		for (const row of this.modules) dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
		const total = this.size * this.size;
		const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
		result += k * PENALTY_N4;
		return result;
	}
	getAlignmentPatternPositions() {
		if (this.version === 1) return [];
		else {
			const numAlign = Math.floor(this.version / 7) + 2;
			const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
			const result = [6];
			for (let pos = this.size - 7; result.length < numAlign; pos -= step) result.splice(1, 0, pos);
			return result;
		}
	}
	finderPenaltyCountPatterns(runHistory) {
		const n = runHistory[1];
		const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;
		return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
	}
	finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
		if (currentRunColor) {
			this.finderPenaltyAddHistory(currentRunLength, runHistory);
			currentRunLength = 0;
		}
		currentRunLength += this.size;
		this.finderPenaltyAddHistory(currentRunLength, runHistory);
		return this.finderPenaltyCountPatterns(runHistory);
	}
	finderPenaltyAddHistory(currentRunLength, runHistory) {
		if (runHistory[0] === 0) currentRunLength += this.size;
		runHistory.pop();
		runHistory.unshift(currentRunLength);
	}
};
function appendBits(val, len, bb) {
	if (len < 0 || len > 31 || val >>> len !== 0) throw new RangeError("Value out of range");
	for (let i = len - 1; i >= 0; i--) bb.push(val >>> i & 1);
}
function getBit(x, i) {
	return (x >>> i & 1) !== 0;
}
var QrSegment = class {
	constructor(mode, numChars, bitData) {
		this.mode = mode;
		this.numChars = numChars;
		this.bitData = bitData;
		if (numChars < 0) throw new RangeError("Invalid argument");
		this.bitData = bitData.slice();
	}
	getData() {
		return this.bitData.slice();
	}
};
const MODE_NUMERIC = [
	1,
	10,
	12,
	14
];
const MODE_ALPHANUMERIC = [
	2,
	9,
	11,
	13
];
const MODE_BYTE = [
	4,
	8,
	16,
	16
];
function numCharCountBits(mode, ver) {
	return mode[Math.floor((ver + 7) / 17) + 1];
}
function makeBytes(data) {
	const bb = [];
	for (const b of data) appendBits(b, 8, bb);
	return new QrSegment(MODE_BYTE, data.length, bb);
}
function makeNumeric(digits) {
	if (!isNumeric(digits)) throw new RangeError("String contains non-numeric characters");
	const bb = [];
	for (let i = 0; i < digits.length;) {
		const n = Math.min(digits.length - i, 3);
		appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
		i += n;
	}
	return new QrSegment(MODE_NUMERIC, digits.length, bb);
}
function makeAlphanumeric(text) {
	if (!isAlphanumeric(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
	const bb = [];
	let i;
	for (i = 0; i + 2 <= text.length; i += 2) {
		let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
		temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
		appendBits(temp, 11, bb);
	}
	if (i < text.length) appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
	return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);
}
function makeSegments(text) {
	if (text === "") return [];
	else if (isNumeric(text)) return [makeNumeric(text)];
	else if (isAlphanumeric(text)) return [makeAlphanumeric(text)];
	else return [makeBytes(toUtf8ByteArray(text))];
}
function isNumeric(text) {
	return NUMERIC_REGEX.test(text);
}
function isAlphanumeric(text) {
	return ALPHANUMERIC_REGEX.test(text);
}
function getTotalBits(segs, version) {
	let result = 0;
	for (const seg of segs) {
		const ccbits = numCharCountBits(seg.mode, version);
		if (seg.numChars >= 1 << ccbits) return Number.POSITIVE_INFINITY;
		result += 4 + ccbits + seg.bitData.length;
	}
	return result;
}
function toUtf8ByteArray(str) {
	str = encodeURI(str);
	const result = [];
	for (let i = 0; i < str.length; i++) if (str.charAt(i) !== "%") result.push(str.charCodeAt(i));
	else {
		result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));
		i += 2;
	}
	return result;
}
function getNumRawDataModules(ver) {
	if (ver < MIN_VERSION || ver > MAX_VERSION) throw new RangeError("Version number out of range");
	let result = (16 * ver + 128) * ver + 64;
	if (ver >= 2) {
		const numAlign = Math.floor(ver / 7) + 2;
		result -= (25 * numAlign - 10) * numAlign - 55;
		if (ver >= 7) result -= 36;
	}
	return result;
}
function getNumDataCodewords(ver, ecl) {
	return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
}
function reedSolomonComputeDivisor(degree) {
	if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");
	const result = [];
	for (let i = 0; i < degree - 1; i++) result.push(0);
	result.push(1);
	let root = 1;
	for (let i = 0; i < degree; i++) {
		for (let j = 0; j < result.length; j++) {
			result[j] = reedSolomonMultiply(result[j], root);
			if (j + 1 < result.length) result[j] ^= result[j + 1];
		}
		root = reedSolomonMultiply(root, 2);
	}
	return result;
}
function reedSolomonComputeRemainder(data, divisor) {
	const result = divisor.map((_) => 0);
	for (const b of data) {
		const factor = b ^ result.shift();
		result.push(0);
		divisor.forEach((coef, i) => result[i] ^= reedSolomonMultiply(coef, factor));
	}
	return result;
}
function reedSolomonMultiply(x, y) {
	if (x >>> 8 !== 0 || y >>> 8 !== 0) throw new RangeError("Byte out of range");
	let z = 0;
	for (let i = 7; i >= 0; i--) {
		z = z << 1 ^ (z >>> 7) * 285;
		z ^= (y >>> i & 1) * x;
	}
	return z;
}
function encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
	if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError("Invalid value");
	let version;
	let dataUsedBits;
	for (version = minVersion;; version++) {
		const dataCapacityBits2 = getNumDataCodewords(version, ecl) * 8;
		const usedBits = getTotalBits(segs, version);
		if (usedBits <= dataCapacityBits2) {
			dataUsedBits = usedBits;
			break;
		}
		if (version >= maxVersion) throw new RangeError("Data too long");
	}
	for (const newEcl of [
		MEDIUM,
		QUARTILE,
		HIGH
	]) if (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;
	const bb = [];
	for (const seg of segs) {
		appendBits(seg.mode[0], 4, bb);
		appendBits(seg.numChars, numCharCountBits(seg.mode, version), bb);
		for (const b of seg.getData()) bb.push(b);
	}
	const dataCapacityBits = getNumDataCodewords(version, ecl) * 8;
	appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
	appendBits(0, (8 - bb.length % 8) % 8, bb);
	for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 253) appendBits(padByte, 8, bb);
	const dataCodewords = Array.from({ length: Math.ceil(bb.length / 8) }, () => 0);
	bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
	return new QrCode(version, ecl, dataCodewords, mask);
}
function encode(data, options) {
	const { ecc = "L", boostEcc = false, minVersion = 1, maxVersion = 40, maskPattern = -1, border = 1 } = options || {};
	const segment = typeof data === "string" ? makeSegments(data) : Array.isArray(data) ? [makeBytes(data)] : void 0;
	if (!segment) throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);
	const qr = encodeSegments(segment, EccMap[ecc], minVersion, maxVersion, maskPattern, boostEcc);
	const result = addBorder({
		version: qr.version,
		maskPattern: qr.mask,
		size: qr.size,
		data: qr.modules,
		types: qr.types
	}, border);
	if (options?.invert) result.data = result.data.map((row) => row.map((mod) => !mod));
	options?.onEncoded?.(result);
	return result;
}
function addBorder(input, border = 1) {
	if (!border) return input;
	const { size } = input;
	const newSize = size + border * 2;
	input.size = newSize;
	input.data.forEach((row) => {
		for (let i = 0; i < border; i++) {
			row.unshift(false);
			row.push(false);
		}
	});
	for (let i = 0; i < border; i++) {
		input.data.unshift(Array.from({ length: newSize }, (_) => false));
		input.data.push(Array.from({ length: newSize }, (_) => false));
	}
	const b = QrCodeDataType.Border;
	input.types.forEach((row) => {
		for (let i = 0; i < border; i++) {
			row.unshift(b);
			row.push(b);
		}
	});
	for (let i = 0; i < border; i++) {
		input.types.unshift(Array.from({ length: newSize }, (_) => b));
		input.types.push(Array.from({ length: newSize }, (_) => b));
	}
	return input;
}
function getDataAt(data, x, y, defaults = false) {
	if (x < 0 || y < 0 || x >= data.length || y >= data.length) return defaults;
	return data[y][x];
}
function renderUnicodeCompact(data, options = {}) {
	const platte = {
		WHITE_ALL: "█",
		WHITE_BLACK: "▀",
		BLACK_WHITE: "▄",
		BLACK_ALL: " "
	};
	const result = encode(data, options);
	const WHITE = false;
	const BLACK = true;
	const at = (x, y) => getDataAt(result.data, x, y, true);
	const lines = [];
	let line = "";
	for (let row = 0; row < result.size; row += 2) {
		for (let col = 0; col < result.size; col++) if (at(col, row) === WHITE && at(col, row + 1) === WHITE) line += platte.WHITE_ALL;
		else if (at(col, row) === WHITE && at(col, row + 1) === BLACK) line += platte.WHITE_BLACK;
		else if (at(col, row) === BLACK && at(col, row + 1) === WHITE) line += platte.BLACK_WHITE;
		else line += platte.BLACK_ALL;
		lines.push(line);
		line = "";
	}
	return lines.join("\n");
}

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/forge.js
var require_forge = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for Forge.
	*
	* @author Dave Longley
	*
	* Copyright 2011-2016 Digital Bazaar, Inc.
	*/
	module.exports = { options: { usePureJavaScript: false } };
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/baseN.js
var require_baseN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Base-N/Base-X encoding/decoding functions.
	*
	* Original implementation from base-x:
	* https://github.com/cryptocoinjs/base-x
	*
	* Which is MIT licensed:
	*
	* The MIT License (MIT)
	*
	* Copyright base-x contributors (c) 2016
	*
	* Permission is hereby granted, free of charge, to any person obtaining a copy
	* of this software and associated documentation files (the "Software"), to deal
	* in the Software without restriction, including without limitation the rights
	* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	* copies of the Software, and to permit persons to whom the Software is
	* furnished to do so, subject to the following conditions:
	*
	* The above copyright notice and this permission notice shall be included in
	* all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	* DEALINGS IN THE SOFTWARE.
	*/
	var api = {};
	module.exports = api;
	var _reverseAlphabets = {};
	/**
	* BaseN-encodes a Uint8Array using the given alphabet.
	*
	* @param input the Uint8Array to encode.
	* @param maxline the maximum number of encoded characters per line to use,
	*          defaults to none.
	*
	* @return the baseN-encoded output string.
	*/
	api.encode = function(input, alphabet, maxline) {
		if (typeof alphabet !== "string") throw new TypeError("\"alphabet\" must be a string.");
		if (maxline !== void 0 && typeof maxline !== "number") throw new TypeError("\"maxline\" must be a number.");
		var output = "";
		if (!(input instanceof Uint8Array)) output = _encodeWithByteBuffer(input, alphabet);
		else {
			var i = 0;
			var base = alphabet.length;
			var first = alphabet.charAt(0);
			var digits = [0];
			for (i = 0; i < input.length; ++i) {
				for (var j = 0, carry = input[i]; j < digits.length; ++j) {
					carry += digits[j] << 8;
					digits[j] = carry % base;
					carry = carry / base | 0;
				}
				while (carry > 0) {
					digits.push(carry % base);
					carry = carry / base | 0;
				}
			}
			for (i = 0; input[i] === 0 && i < input.length - 1; ++i) output += first;
			for (i = digits.length - 1; i >= 0; --i) output += alphabet[digits[i]];
		}
		if (maxline) {
			var regex = new RegExp(".{1," + maxline + "}", "g");
			output = output.match(regex).join("\r\n");
		}
		return output;
	};
	/**
	* Decodes a baseN-encoded (using the given alphabet) string to a
	* Uint8Array.
	*
	* @param input the baseN-encoded input string.
	*
	* @return the Uint8Array.
	*/
	api.decode = function(input, alphabet) {
		if (typeof input !== "string") throw new TypeError("\"input\" must be a string.");
		if (typeof alphabet !== "string") throw new TypeError("\"alphabet\" must be a string.");
		var table = _reverseAlphabets[alphabet];
		if (!table) {
			table = _reverseAlphabets[alphabet] = [];
			for (var i = 0; i < alphabet.length; ++i) table[alphabet.charCodeAt(i)] = i;
		}
		input = input.replace(/\s/g, "");
		var base = alphabet.length;
		var first = alphabet.charAt(0);
		var bytes = [0];
		for (var i = 0; i < input.length; i++) {
			var value = table[input.charCodeAt(i)];
			if (value === void 0) return;
			for (var j = 0, carry = value; j < bytes.length; ++j) {
				carry += bytes[j] * base;
				bytes[j] = carry & 255;
				carry >>= 8;
			}
			while (carry > 0) {
				bytes.push(carry & 255);
				carry >>= 8;
			}
		}
		for (var k = 0; input[k] === first && k < input.length - 1; ++k) bytes.push(0);
		if (typeof Buffer !== "undefined") return Buffer.from(bytes.reverse());
		return new Uint8Array(bytes.reverse());
	};
	function _encodeWithByteBuffer(input, alphabet) {
		var i = 0;
		var base = alphabet.length;
		var first = alphabet.charAt(0);
		var digits = [0];
		for (i = 0; i < input.length(); ++i) {
			for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
				carry += digits[j] << 8;
				digits[j] = carry % base;
				carry = carry / base | 0;
			}
			while (carry > 0) {
				digits.push(carry % base);
				carry = carry / base | 0;
			}
		}
		var output = "";
		for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) output += first;
		for (i = digits.length - 1; i >= 0; --i) output += alphabet[digits[i]];
		return output;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/util.js
var require_util = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Utility functions for web applications.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2018 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	var baseN = require_baseN();
	var util = module.exports = forge.util = forge.util || {};
	(function() {
		if (typeof process !== "undefined" && process.nextTick && !process.browser) {
			util.nextTick = process.nextTick;
			if (typeof setImmediate === "function") util.setImmediate = setImmediate;
			else util.setImmediate = util.nextTick;
			return;
		}
		if (typeof setImmediate === "function") {
			util.setImmediate = function() {
				return setImmediate.apply(void 0, arguments);
			};
			util.nextTick = function(callback) {
				return setImmediate(callback);
			};
			return;
		}
		util.setImmediate = function(callback) {
			setTimeout(callback, 0);
		};
		if (typeof window !== "undefined" && typeof window.postMessage === "function") {
			var msg = "forge.setImmediate";
			var callbacks = [];
			util.setImmediate = function(callback) {
				callbacks.push(callback);
				if (callbacks.length === 1) window.postMessage(msg, "*");
			};
			function handler(event) {
				if (event.source === window && event.data === msg) {
					event.stopPropagation();
					var copy = callbacks.slice();
					callbacks.length = 0;
					copy.forEach(function(callback) {
						callback();
					});
				}
			}
			window.addEventListener("message", handler, true);
		}
		if (typeof MutationObserver !== "undefined") {
			var now = Date.now();
			var attr = true;
			var div = document.createElement("div");
			var callbacks = [];
			new MutationObserver(function() {
				var copy = callbacks.slice();
				callbacks.length = 0;
				copy.forEach(function(callback) {
					callback();
				});
			}).observe(div, { attributes: true });
			var oldSetImmediate = util.setImmediate;
			util.setImmediate = function(callback) {
				if (Date.now() - now > 15) {
					now = Date.now();
					oldSetImmediate(callback);
				} else {
					callbacks.push(callback);
					if (callbacks.length === 1) div.setAttribute("a", attr = !attr);
				}
			};
		}
		util.nextTick = util.setImmediate;
	})();
	util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
	util.globalScope = (function() {
		if (util.isNodejs) return global;
		return typeof self === "undefined" ? window : self;
	})();
	util.isArray = Array.isArray || function(x) {
		return Object.prototype.toString.call(x) === "[object Array]";
	};
	util.isArrayBuffer = function(x) {
		return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
	};
	util.isArrayBufferView = function(x) {
		return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
	};
	/**
	* Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
	* algorithms where bit manipulation, JavaScript limitations, and/or algorithm
	* design only allow for byte operations of a limited size.
	*
	* @param n number of bits.
	*
	* Throw Error if n invalid.
	*/
	function _checkBitsParam(n) {
		if (!(n === 8 || n === 16 || n === 24 || n === 32)) throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
	}
	util.ByteBuffer = ByteStringBuffer;
	/** Buffer w/BinaryString backing */
	/**
	* Constructor for a binary string backed byte buffer.
	*
	* @param [b] the bytes to wrap (either encoded as string, one byte per
	*          character, or as an ArrayBuffer or Typed Array).
	*/
	function ByteStringBuffer(b) {
		this.data = "";
		this.read = 0;
		if (typeof b === "string") this.data = b;
		else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) if (typeof Buffer !== "undefined" && b instanceof Buffer) this.data = b.toString("binary");
		else {
			var arr = new Uint8Array(b);
			try {
				this.data = String.fromCharCode.apply(null, arr);
			} catch (e) {
				for (var i = 0; i < arr.length; ++i) this.putByte(arr[i]);
			}
		}
		else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
			this.data = b.data;
			this.read = b.read;
		}
		this._constructedStringLength = 0;
	}
	util.ByteStringBuffer = ByteStringBuffer;
	var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
	util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
		this._constructedStringLength += x;
		if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
			this.data.substr(0, 1);
			this._constructedStringLength = 0;
		}
	};
	/**
	* Gets the number of bytes in this buffer.
	*
	* @return the number of bytes in this buffer.
	*/
	util.ByteStringBuffer.prototype.length = function() {
		return this.data.length - this.read;
	};
	/**
	* Gets whether or not this buffer is empty.
	*
	* @return true if this buffer is empty, false if not.
	*/
	util.ByteStringBuffer.prototype.isEmpty = function() {
		return this.length() <= 0;
	};
	/**
	* Puts a byte in this buffer.
	*
	* @param b the byte to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putByte = function(b) {
		return this.putBytes(String.fromCharCode(b));
	};
	/**
	* Puts a byte in this buffer N times.
	*
	* @param b the byte to put.
	* @param n the number of bytes of value b to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
		b = String.fromCharCode(b);
		var d = this.data;
		while (n > 0) {
			if (n & 1) d += b;
			n >>>= 1;
			if (n > 0) b += b;
		}
		this.data = d;
		this._optimizeConstructedString(n);
		return this;
	};
	/**
	* Puts bytes in this buffer.
	*
	* @param bytes the bytes (as a binary encoded string) to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putBytes = function(bytes) {
		this.data += bytes;
		this._optimizeConstructedString(bytes.length);
		return this;
	};
	/**
	* Puts a UTF-16 encoded string into this buffer.
	*
	* @param str the string to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putString = function(str) {
		return this.putBytes(util.encodeUtf8(str));
	};
	/**
	* Puts a 16-bit integer in this buffer in big-endian order.
	*
	* @param i the 16-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt16 = function(i) {
		return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
	};
	/**
	* Puts a 24-bit integer in this buffer in big-endian order.
	*
	* @param i the 24-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt24 = function(i) {
		return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
	};
	/**
	* Puts a 32-bit integer in this buffer in big-endian order.
	*
	* @param i the 32-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt32 = function(i) {
		return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
	};
	/**
	* Puts a 16-bit integer in this buffer in little-endian order.
	*
	* @param i the 16-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt16Le = function(i) {
		return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
	};
	/**
	* Puts a 24-bit integer in this buffer in little-endian order.
	*
	* @param i the 24-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt24Le = function(i) {
		return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
	};
	/**
	* Puts a 32-bit integer in this buffer in little-endian order.
	*
	* @param i the 32-bit integer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt32Le = function(i) {
		return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
	};
	/**
	* Puts an n-bit integer in this buffer in big-endian order.
	*
	* @param i the n-bit integer.
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putInt = function(i, n) {
		_checkBitsParam(n);
		var bytes = "";
		do {
			n -= 8;
			bytes += String.fromCharCode(i >> n & 255);
		} while (n > 0);
		return this.putBytes(bytes);
	};
	/**
	* Puts a signed n-bit integer in this buffer in big-endian order. Two's
	* complement representation is used.
	*
	* @param i the n-bit integer.
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
		if (i < 0) i += 2 << n - 1;
		return this.putInt(i, n);
	};
	/**
	* Puts the given buffer into this buffer.
	*
	* @param buffer the buffer to put into this one.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
		return this.putBytes(buffer.getBytes());
	};
	/**
	* Gets a byte from this buffer and advances the read pointer by 1.
	*
	* @return the byte.
	*/
	util.ByteStringBuffer.prototype.getByte = function() {
		return this.data.charCodeAt(this.read++);
	};
	/**
	* Gets a uint16 from this buffer in big-endian order and advances the read
	* pointer by 2.
	*
	* @return the uint16.
	*/
	util.ByteStringBuffer.prototype.getInt16 = function() {
		var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
		this.read += 2;
		return rval;
	};
	/**
	* Gets a uint24 from this buffer in big-endian order and advances the read
	* pointer by 3.
	*
	* @return the uint24.
	*/
	util.ByteStringBuffer.prototype.getInt24 = function() {
		var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
		this.read += 3;
		return rval;
	};
	/**
	* Gets a uint32 from this buffer in big-endian order and advances the read
	* pointer by 4.
	*
	* @return the word.
	*/
	util.ByteStringBuffer.prototype.getInt32 = function() {
		var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
		this.read += 4;
		return rval;
	};
	/**
	* Gets a uint16 from this buffer in little-endian order and advances the read
	* pointer by 2.
	*
	* @return the uint16.
	*/
	util.ByteStringBuffer.prototype.getInt16Le = function() {
		var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
		this.read += 2;
		return rval;
	};
	/**
	* Gets a uint24 from this buffer in little-endian order and advances the read
	* pointer by 3.
	*
	* @return the uint24.
	*/
	util.ByteStringBuffer.prototype.getInt24Le = function() {
		var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
		this.read += 3;
		return rval;
	};
	/**
	* Gets a uint32 from this buffer in little-endian order and advances the read
	* pointer by 4.
	*
	* @return the word.
	*/
	util.ByteStringBuffer.prototype.getInt32Le = function() {
		var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
		this.read += 4;
		return rval;
	};
	/**
	* Gets an n-bit integer from this buffer in big-endian order and advances the
	* read pointer by ceil(n/8).
	*
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return the integer.
	*/
	util.ByteStringBuffer.prototype.getInt = function(n) {
		_checkBitsParam(n);
		var rval = 0;
		do {
			rval = (rval << 8) + this.data.charCodeAt(this.read++);
			n -= 8;
		} while (n > 0);
		return rval;
	};
	/**
	* Gets a signed n-bit integer from this buffer in big-endian order, using
	* two's complement, and advances the read pointer by n/8.
	*
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return the integer.
	*/
	util.ByteStringBuffer.prototype.getSignedInt = function(n) {
		var x = this.getInt(n);
		var max = 2 << n - 2;
		if (x >= max) x -= max << 1;
		return x;
	};
	/**
	* Reads bytes out as a binary encoded string and clears them from the
	* buffer. Note that the resulting string is binary encoded (in node.js this
	* encoding is referred to as `binary`, it is *not* `utf8`).
	*
	* @param count the number of bytes to read, undefined or null for all.
	*
	* @return a binary encoded string of bytes.
	*/
	util.ByteStringBuffer.prototype.getBytes = function(count) {
		var rval;
		if (count) {
			count = Math.min(this.length(), count);
			rval = this.data.slice(this.read, this.read + count);
			this.read += count;
		} else if (count === 0) rval = "";
		else {
			rval = this.read === 0 ? this.data : this.data.slice(this.read);
			this.clear();
		}
		return rval;
	};
	/**
	* Gets a binary encoded string of the bytes from this buffer without
	* modifying the read pointer.
	*
	* @param count the number of bytes to get, omit to get all.
	*
	* @return a string full of binary encoded characters.
	*/
	util.ByteStringBuffer.prototype.bytes = function(count) {
		return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
	};
	/**
	* Gets a byte at the given index without modifying the read pointer.
	*
	* @param i the byte index.
	*
	* @return the byte.
	*/
	util.ByteStringBuffer.prototype.at = function(i) {
		return this.data.charCodeAt(this.read + i);
	};
	/**
	* Puts a byte at the given index without modifying the read pointer.
	*
	* @param i the byte index.
	* @param b the byte to put.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.setAt = function(i, b) {
		this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
		return this;
	};
	/**
	* Gets the last byte without modifying the read pointer.
	*
	* @return the last byte.
	*/
	util.ByteStringBuffer.prototype.last = function() {
		return this.data.charCodeAt(this.data.length - 1);
	};
	/**
	* Creates a copy of this buffer.
	*
	* @return the copy.
	*/
	util.ByteStringBuffer.prototype.copy = function() {
		var c = util.createBuffer(this.data);
		c.read = this.read;
		return c;
	};
	/**
	* Compacts this buffer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.compact = function() {
		if (this.read > 0) {
			this.data = this.data.slice(this.read);
			this.read = 0;
		}
		return this;
	};
	/**
	* Clears this buffer.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.clear = function() {
		this.data = "";
		this.read = 0;
		return this;
	};
	/**
	* Shortens this buffer by trimming bytes off of the end of this buffer.
	*
	* @param count the number of bytes to trim off.
	*
	* @return this buffer.
	*/
	util.ByteStringBuffer.prototype.truncate = function(count) {
		var len = Math.max(0, this.length() - count);
		this.data = this.data.substr(this.read, len);
		this.read = 0;
		return this;
	};
	/**
	* Converts this buffer to a hexadecimal string.
	*
	* @return a hexadecimal string.
	*/
	util.ByteStringBuffer.prototype.toHex = function() {
		var rval = "";
		for (var i = this.read; i < this.data.length; ++i) {
			var b = this.data.charCodeAt(i);
			if (b < 16) rval += "0";
			rval += b.toString(16);
		}
		return rval;
	};
	/**
	* Converts this buffer to a UTF-16 string (standard JavaScript string).
	*
	* @return a UTF-16 string.
	*/
	util.ByteStringBuffer.prototype.toString = function() {
		return util.decodeUtf8(this.bytes());
	};
	/** End Buffer w/BinaryString backing */
	/** Buffer w/UInt8Array backing */
	/**
	* FIXME: Experimental. Do not use yet.
	*
	* Constructor for an ArrayBuffer-backed byte buffer.
	*
	* The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
	* TypedArray.
	*
	* If a string is given, its encoding should be provided as an option,
	* otherwise it will default to 'binary'. A 'binary' string is encoded such
	* that each character is one byte in length and size.
	*
	* If an ArrayBuffer, DataView, or TypedArray is given, it will be used
	* *directly* without any copying. Note that, if a write to the buffer requires
	* more space, the buffer will allocate a new backing ArrayBuffer to
	* accommodate. The starting read and write offsets for the buffer may be
	* given as options.
	*
	* @param [b] the initial bytes for this buffer.
	* @param options the options to use:
	*          [readOffset] the starting read offset to use (default: 0).
	*          [writeOffset] the starting write offset to use (default: the
	*            length of the first parameter).
	*          [growSize] the minimum amount, in bytes, to grow the buffer by to
	*            accommodate writes (default: 1024).
	*          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
	*            first parameter, if it is a string (default: 'binary').
	*/
	function DataBuffer(b, options) {
		options = options || {};
		this.read = options.readOffset || 0;
		this.growSize = options.growSize || 1024;
		var isArrayBuffer = util.isArrayBuffer(b);
		var isArrayBufferView = util.isArrayBufferView(b);
		if (isArrayBuffer || isArrayBufferView) {
			if (isArrayBuffer) this.data = new DataView(b);
			else this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
			this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
			return;
		}
		this.data = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(0));
		this.write = 0;
		if (b !== null && b !== void 0) this.putBytes(b);
		if ("writeOffset" in options) this.write = options.writeOffset;
	}
	util.DataBuffer = DataBuffer;
	/**
	* Gets the number of bytes in this buffer.
	*
	* @return the number of bytes in this buffer.
	*/
	util.DataBuffer.prototype.length = function() {
		return this.write - this.read;
	};
	/**
	* Gets whether or not this buffer is empty.
	*
	* @return true if this buffer is empty, false if not.
	*/
	util.DataBuffer.prototype.isEmpty = function() {
		return this.length() <= 0;
	};
	/**
	* Ensures this buffer has enough empty space to accommodate the given number
	* of bytes. An optional parameter may be given that indicates a minimum
	* amount to grow the buffer if necessary. If the parameter is not given,
	* the buffer will be grown by some previously-specified default amount
	* or heuristic.
	*
	* @param amount the number of bytes to accommodate.
	* @param [growSize] the minimum amount, in bytes, to grow the buffer by if
	*          necessary.
	*/
	util.DataBuffer.prototype.accommodate = function(amount, growSize) {
		if (this.length() >= amount) return this;
		growSize = Math.max(growSize || this.growSize, amount);
		var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
		var dst = new Uint8Array(this.length() + growSize);
		dst.set(src);
		this.data = new DataView(dst.buffer);
		return this;
	};
	/**
	* Puts a byte in this buffer.
	*
	* @param b the byte to put.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putByte = function(b) {
		this.accommodate(1);
		this.data.setUint8(this.write++, b);
		return this;
	};
	/**
	* Puts a byte in this buffer N times.
	*
	* @param b the byte to put.
	* @param n the number of bytes of value b to put.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.fillWithByte = function(b, n) {
		this.accommodate(n);
		for (var i = 0; i < n; ++i) this.data.setUint8(b);
		return this;
	};
	/**
	* Puts bytes in this buffer. The bytes may be given as a string, an
	* ArrayBuffer, a DataView, or a TypedArray.
	*
	* @param bytes the bytes to put.
	* @param [encoding] the encoding for the first parameter ('binary', 'utf8',
	*          'utf16', 'hex'), if it is a string (default: 'binary').
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
		if (util.isArrayBufferView(bytes)) {
			var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
			var len = src.byteLength - src.byteOffset;
			this.accommodate(len);
			var dst = new Uint8Array(this.data.buffer, this.write);
			dst.set(src);
			this.write += len;
			return this;
		}
		if (util.isArrayBuffer(bytes)) {
			var src = new Uint8Array(bytes);
			this.accommodate(src.byteLength);
			var dst = new Uint8Array(this.data.buffer);
			dst.set(src, this.write);
			this.write += src.byteLength;
			return this;
		}
		if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
			var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
			this.accommodate(src.byteLength);
			var dst = new Uint8Array(bytes.data.byteLength, this.write);
			dst.set(src);
			this.write += src.byteLength;
			return this;
		}
		if (bytes instanceof util.ByteStringBuffer) {
			bytes = bytes.data;
			encoding = "binary";
		}
		encoding = encoding || "binary";
		if (typeof bytes === "string") {
			var view;
			if (encoding === "hex") {
				this.accommodate(Math.ceil(bytes.length / 2));
				view = new Uint8Array(this.data.buffer, this.write);
				this.write += util.binary.hex.decode(bytes, view, this.write);
				return this;
			}
			if (encoding === "base64") {
				this.accommodate(Math.ceil(bytes.length / 4) * 3);
				view = new Uint8Array(this.data.buffer, this.write);
				this.write += util.binary.base64.decode(bytes, view, this.write);
				return this;
			}
			if (encoding === "utf8") {
				bytes = util.encodeUtf8(bytes);
				encoding = "binary";
			}
			if (encoding === "binary" || encoding === "raw") {
				this.accommodate(bytes.length);
				view = new Uint8Array(this.data.buffer, this.write);
				this.write += util.binary.raw.decode(view);
				return this;
			}
			if (encoding === "utf16") {
				this.accommodate(bytes.length * 2);
				view = new Uint16Array(this.data.buffer, this.write);
				this.write += util.text.utf16.encode(view);
				return this;
			}
			throw new Error("Invalid encoding: " + encoding);
		}
		throw Error("Invalid parameter: " + bytes);
	};
	/**
	* Puts the given buffer into this buffer.
	*
	* @param buffer the buffer to put into this one.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putBuffer = function(buffer) {
		this.putBytes(buffer);
		buffer.clear();
		return this;
	};
	/**
	* Puts a string into this buffer.
	*
	* @param str the string to put.
	* @param [encoding] the encoding for the string (default: 'utf16').
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putString = function(str) {
		return this.putBytes(str, "utf16");
	};
	/**
	* Puts a 16-bit integer in this buffer in big-endian order.
	*
	* @param i the 16-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt16 = function(i) {
		this.accommodate(2);
		this.data.setInt16(this.write, i);
		this.write += 2;
		return this;
	};
	/**
	* Puts a 24-bit integer in this buffer in big-endian order.
	*
	* @param i the 24-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt24 = function(i) {
		this.accommodate(3);
		this.data.setInt16(this.write, i >> 8 & 65535);
		this.data.setInt8(this.write, i >> 16 & 255);
		this.write += 3;
		return this;
	};
	/**
	* Puts a 32-bit integer in this buffer in big-endian order.
	*
	* @param i the 32-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt32 = function(i) {
		this.accommodate(4);
		this.data.setInt32(this.write, i);
		this.write += 4;
		return this;
	};
	/**
	* Puts a 16-bit integer in this buffer in little-endian order.
	*
	* @param i the 16-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt16Le = function(i) {
		this.accommodate(2);
		this.data.setInt16(this.write, i, true);
		this.write += 2;
		return this;
	};
	/**
	* Puts a 24-bit integer in this buffer in little-endian order.
	*
	* @param i the 24-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt24Le = function(i) {
		this.accommodate(3);
		this.data.setInt8(this.write, i >> 16 & 255);
		this.data.setInt16(this.write, i >> 8 & 65535, true);
		this.write += 3;
		return this;
	};
	/**
	* Puts a 32-bit integer in this buffer in little-endian order.
	*
	* @param i the 32-bit integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt32Le = function(i) {
		this.accommodate(4);
		this.data.setInt32(this.write, i, true);
		this.write += 4;
		return this;
	};
	/**
	* Puts an n-bit integer in this buffer in big-endian order.
	*
	* @param i the n-bit integer.
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putInt = function(i, n) {
		_checkBitsParam(n);
		this.accommodate(n / 8);
		do {
			n -= 8;
			this.data.setInt8(this.write++, i >> n & 255);
		} while (n > 0);
		return this;
	};
	/**
	* Puts a signed n-bit integer in this buffer in big-endian order. Two's
	* complement representation is used.
	*
	* @param i the n-bit integer.
	* @param n the number of bits in the integer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.putSignedInt = function(i, n) {
		_checkBitsParam(n);
		this.accommodate(n / 8);
		if (i < 0) i += 2 << n - 1;
		return this.putInt(i, n);
	};
	/**
	* Gets a byte from this buffer and advances the read pointer by 1.
	*
	* @return the byte.
	*/
	util.DataBuffer.prototype.getByte = function() {
		return this.data.getInt8(this.read++);
	};
	/**
	* Gets a uint16 from this buffer in big-endian order and advances the read
	* pointer by 2.
	*
	* @return the uint16.
	*/
	util.DataBuffer.prototype.getInt16 = function() {
		var rval = this.data.getInt16(this.read);
		this.read += 2;
		return rval;
	};
	/**
	* Gets a uint24 from this buffer in big-endian order and advances the read
	* pointer by 3.
	*
	* @return the uint24.
	*/
	util.DataBuffer.prototype.getInt24 = function() {
		var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
		this.read += 3;
		return rval;
	};
	/**
	* Gets a uint32 from this buffer in big-endian order and advances the read
	* pointer by 4.
	*
	* @return the word.
	*/
	util.DataBuffer.prototype.getInt32 = function() {
		var rval = this.data.getInt32(this.read);
		this.read += 4;
		return rval;
	};
	/**
	* Gets a uint16 from this buffer in little-endian order and advances the read
	* pointer by 2.
	*
	* @return the uint16.
	*/
	util.DataBuffer.prototype.getInt16Le = function() {
		var rval = this.data.getInt16(this.read, true);
		this.read += 2;
		return rval;
	};
	/**
	* Gets a uint24 from this buffer in little-endian order and advances the read
	* pointer by 3.
	*
	* @return the uint24.
	*/
	util.DataBuffer.prototype.getInt24Le = function() {
		var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
		this.read += 3;
		return rval;
	};
	/**
	* Gets a uint32 from this buffer in little-endian order and advances the read
	* pointer by 4.
	*
	* @return the word.
	*/
	util.DataBuffer.prototype.getInt32Le = function() {
		var rval = this.data.getInt32(this.read, true);
		this.read += 4;
		return rval;
	};
	/**
	* Gets an n-bit integer from this buffer in big-endian order and advances the
	* read pointer by n/8.
	*
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return the integer.
	*/
	util.DataBuffer.prototype.getInt = function(n) {
		_checkBitsParam(n);
		var rval = 0;
		do {
			rval = (rval << 8) + this.data.getInt8(this.read++);
			n -= 8;
		} while (n > 0);
		return rval;
	};
	/**
	* Gets a signed n-bit integer from this buffer in big-endian order, using
	* two's complement, and advances the read pointer by n/8.
	*
	* @param n the number of bits in the integer (8, 16, 24, or 32).
	*
	* @return the integer.
	*/
	util.DataBuffer.prototype.getSignedInt = function(n) {
		var x = this.getInt(n);
		var max = 2 << n - 2;
		if (x >= max) x -= max << 1;
		return x;
	};
	/**
	* Reads bytes out as a binary encoded string and clears them from the
	* buffer.
	*
	* @param count the number of bytes to read, undefined or null for all.
	*
	* @return a binary encoded string of bytes.
	*/
	util.DataBuffer.prototype.getBytes = function(count) {
		var rval;
		if (count) {
			count = Math.min(this.length(), count);
			rval = this.data.slice(this.read, this.read + count);
			this.read += count;
		} else if (count === 0) rval = "";
		else {
			rval = this.read === 0 ? this.data : this.data.slice(this.read);
			this.clear();
		}
		return rval;
	};
	/**
	* Gets a binary encoded string of the bytes from this buffer without
	* modifying the read pointer.
	*
	* @param count the number of bytes to get, omit to get all.
	*
	* @return a string full of binary encoded characters.
	*/
	util.DataBuffer.prototype.bytes = function(count) {
		return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
	};
	/**
	* Gets a byte at the given index without modifying the read pointer.
	*
	* @param i the byte index.
	*
	* @return the byte.
	*/
	util.DataBuffer.prototype.at = function(i) {
		return this.data.getUint8(this.read + i);
	};
	/**
	* Puts a byte at the given index without modifying the read pointer.
	*
	* @param i the byte index.
	* @param b the byte to put.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.setAt = function(i, b) {
		this.data.setUint8(i, b);
		return this;
	};
	/**
	* Gets the last byte without modifying the read pointer.
	*
	* @return the last byte.
	*/
	util.DataBuffer.prototype.last = function() {
		return this.data.getUint8(this.write - 1);
	};
	/**
	* Creates a copy of this buffer.
	*
	* @return the copy.
	*/
	util.DataBuffer.prototype.copy = function() {
		return new util.DataBuffer(this);
	};
	/**
	* Compacts this buffer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.compact = function() {
		if (this.read > 0) {
			var src = new Uint8Array(this.data.buffer, this.read);
			var dst = new Uint8Array(src.byteLength);
			dst.set(src);
			this.data = new DataView(dst);
			this.write -= this.read;
			this.read = 0;
		}
		return this;
	};
	/**
	* Clears this buffer.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.clear = function() {
		this.data = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(0));
		this.read = this.write = 0;
		return this;
	};
	/**
	* Shortens this buffer by trimming bytes off of the end of this buffer.
	*
	* @param count the number of bytes to trim off.
	*
	* @return this buffer.
	*/
	util.DataBuffer.prototype.truncate = function(count) {
		this.write = Math.max(0, this.length() - count);
		this.read = Math.min(this.read, this.write);
		return this;
	};
	/**
	* Converts this buffer to a hexadecimal string.
	*
	* @return a hexadecimal string.
	*/
	util.DataBuffer.prototype.toHex = function() {
		var rval = "";
		for (var i = this.read; i < this.data.byteLength; ++i) {
			var b = this.data.getUint8(i);
			if (b < 16) rval += "0";
			rval += b.toString(16);
		}
		return rval;
	};
	/**
	* Converts this buffer to a string, using the given encoding. If no
	* encoding is given, 'utf8' (UTF-8) is used.
	*
	* @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
	*          'base64' (default: 'utf8').
	*
	* @return a string representation of the bytes in this buffer.
	*/
	util.DataBuffer.prototype.toString = function(encoding) {
		var view = new Uint8Array(this.data, this.read, this.length());
		encoding = encoding || "utf8";
		if (encoding === "binary" || encoding === "raw") return util.binary.raw.encode(view);
		if (encoding === "hex") return util.binary.hex.encode(view);
		if (encoding === "base64") return util.binary.base64.encode(view);
		if (encoding === "utf8") return util.text.utf8.decode(view);
		if (encoding === "utf16") return util.text.utf16.decode(view);
		throw new Error("Invalid encoding: " + encoding);
	};
	/** End Buffer w/UInt8Array backing */
	/**
	* Creates a buffer that stores bytes. A value may be given to populate the
	* buffer with data. This value can either be string of encoded bytes or a
	* regular string of characters. When passing a string of binary encoded
	* bytes, the encoding `raw` should be given. This is also the default. When
	* passing a string of characters, the encoding `utf8` should be given.
	*
	* @param [input] a string with encoded bytes to store in the buffer.
	* @param [encoding] (default: 'raw', other: 'utf8').
	*/
	util.createBuffer = function(input, encoding) {
		encoding = encoding || "raw";
		if (input !== void 0 && encoding === "utf8") input = util.encodeUtf8(input);
		return new util.ByteBuffer(input);
	};
	/**
	* Fills a string with a particular value. If you want the string to be a byte
	* string, pass in String.fromCharCode(theByte).
	*
	* @param c the character to fill the string with, use String.fromCharCode
	*          to fill the string with a byte value.
	* @param n the number of characters of value c to fill with.
	*
	* @return the filled string.
	*/
	util.fillString = function(c, n) {
		var s = "";
		while (n > 0) {
			if (n & 1) s += c;
			n >>>= 1;
			if (n > 0) c += c;
		}
		return s;
	};
	/**
	* Performs a per byte XOR between two byte strings and returns the result as a
	* string of bytes.
	*
	* @param s1 first string of bytes.
	* @param s2 second string of bytes.
	* @param n the number of bytes to XOR.
	*
	* @return the XOR'd result.
	*/
	util.xorBytes = function(s1, s2, n) {
		var s3 = "";
		var b = "";
		var t = "";
		var i = 0;
		var c = 0;
		for (; n > 0; --n, ++i) {
			b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
			if (c >= 10) {
				s3 += t;
				t = "";
				c = 0;
			}
			t += String.fromCharCode(b);
			++c;
		}
		s3 += t;
		return s3;
	};
	/**
	* Converts a hex string into a 'binary' encoded string of bytes.
	*
	* @param hex the hexadecimal string to convert.
	*
	* @return the binary-encoded string of bytes.
	*/
	util.hexToBytes = function(hex) {
		var rval = "";
		var i = 0;
		if (hex.length & true) {
			i = 1;
			rval += String.fromCharCode(parseInt(hex[0], 16));
		}
		for (; i < hex.length; i += 2) rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
		return rval;
	};
	/**
	* Converts a 'binary' encoded string of bytes to hex.
	*
	* @param bytes the byte string to convert.
	*
	* @return the string of hexadecimal characters.
	*/
	util.bytesToHex = function(bytes) {
		return util.createBuffer(bytes).toHex();
	};
	/**
	* Converts an 32-bit integer to 4-big-endian byte string.
	*
	* @param i the integer.
	*
	* @return the byte string.
	*/
	util.int32ToBytes = function(i) {
		return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
	};
	var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	var _base64Idx = [
		62,
		-1,
		-1,
		-1,
		63,
		52,
		53,
		54,
		55,
		56,
		57,
		58,
		59,
		60,
		61,
		-1,
		-1,
		-1,
		64,
		-1,
		-1,
		-1,
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		19,
		20,
		21,
		22,
		23,
		24,
		25,
		-1,
		-1,
		-1,
		-1,
		-1,
		-1,
		26,
		27,
		28,
		29,
		30,
		31,
		32,
		33,
		34,
		35,
		36,
		37,
		38,
		39,
		40,
		41,
		42,
		43,
		44,
		45,
		46,
		47,
		48,
		49,
		50,
		51
	];
	var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
	/**
	* Base64 encodes a 'binary' encoded string of bytes.
	*
	* @param input the binary encoded string of bytes to base64-encode.
	* @param maxline the maximum number of encoded characters per line to use,
	*          defaults to none.
	*
	* @return the base64-encoded output.
	*/
	util.encode64 = function(input, maxline) {
		var line = "";
		var output = "";
		var chr1, chr2, chr3;
		var i = 0;
		while (i < input.length) {
			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);
			line += _base64.charAt(chr1 >> 2);
			line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
			if (isNaN(chr2)) line += "==";
			else {
				line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
				line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
			}
			if (maxline && line.length > maxline) {
				output += line.substr(0, maxline) + "\r\n";
				line = line.substr(maxline);
			}
		}
		output += line;
		return output;
	};
	/**
	* Base64 decodes a string into a 'binary' encoded string of bytes.
	*
	* @param input the base64-encoded input.
	*
	* @return the binary encoded string.
	*/
	util.decode64 = function(input) {
		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
		var output = "";
		var enc1, enc2, enc3, enc4;
		var i = 0;
		while (i < input.length) {
			enc1 = _base64Idx[input.charCodeAt(i++) - 43];
			enc2 = _base64Idx[input.charCodeAt(i++) - 43];
			enc3 = _base64Idx[input.charCodeAt(i++) - 43];
			enc4 = _base64Idx[input.charCodeAt(i++) - 43];
			output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
			if (enc3 !== 64) {
				output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
				if (enc4 !== 64) output += String.fromCharCode((enc3 & 3) << 6 | enc4);
			}
		}
		return output;
	};
	/**
	* Encodes the given string of characters (a standard JavaScript
	* string) as a binary encoded string where the bytes represent
	* a UTF-8 encoded string of characters. Non-ASCII characters will be
	* encoded as multiple bytes according to UTF-8.
	*
	* @param str a standard string of characters to encode.
	*
	* @return the binary encoded string.
	*/
	util.encodeUtf8 = function(str) {
		return unescape(encodeURIComponent(str));
	};
	/**
	* Decodes a binary encoded string that contains bytes that
	* represent a UTF-8 encoded string of characters -- into a
	* string of characters (a standard JavaScript string).
	*
	* @param str the binary encoded string to decode.
	*
	* @return the resulting standard string of characters.
	*/
	util.decodeUtf8 = function(str) {
		return decodeURIComponent(escape(str));
	};
	util.binary = {
		raw: {},
		hex: {},
		base64: {},
		base58: {},
		baseN: {
			encode: baseN.encode,
			decode: baseN.decode
		}
	};
	/**
	* Encodes a Uint8Array as a binary-encoded string. This encoding uses
	* a value between 0 and 255 for each character.
	*
	* @param bytes the Uint8Array to encode.
	*
	* @return the binary-encoded string.
	*/
	util.binary.raw.encode = function(bytes) {
		return String.fromCharCode.apply(null, bytes);
	};
	/**
	* Decodes a binary-encoded string to a Uint8Array. This encoding uses
	* a value between 0 and 255 for each character.
	*
	* @param str the binary-encoded string to decode.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.binary.raw.decode = function(str, output, offset) {
		var out = output;
		if (!out) out = new Uint8Array(str.length);
		offset = offset || 0;
		var j = offset;
		for (var i = 0; i < str.length; ++i) out[j++] = str.charCodeAt(i);
		return output ? j - offset : out;
	};
	/**
	* Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
	* ByteBuffer as a string of hexadecimal characters.
	*
	* @param bytes the bytes to convert.
	*
	* @return the string of hexadecimal characters.
	*/
	util.binary.hex.encode = util.bytesToHex;
	/**
	* Decodes a hex-encoded string to a Uint8Array.
	*
	* @param hex the hexadecimal string to convert.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.binary.hex.decode = function(hex, output, offset) {
		var out = output;
		if (!out) out = new Uint8Array(Math.ceil(hex.length / 2));
		offset = offset || 0;
		var i = 0, j = offset;
		if (hex.length & 1) {
			i = 1;
			out[j++] = parseInt(hex[0], 16);
		}
		for (; i < hex.length; i += 2) out[j++] = parseInt(hex.substr(i, 2), 16);
		return output ? j - offset : out;
	};
	/**
	* Base64-encodes a Uint8Array.
	*
	* @param input the Uint8Array to encode.
	* @param maxline the maximum number of encoded characters per line to use,
	*          defaults to none.
	*
	* @return the base64-encoded output string.
	*/
	util.binary.base64.encode = function(input, maxline) {
		var line = "";
		var output = "";
		var chr1, chr2, chr3;
		var i = 0;
		while (i < input.byteLength) {
			chr1 = input[i++];
			chr2 = input[i++];
			chr3 = input[i++];
			line += _base64.charAt(chr1 >> 2);
			line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
			if (isNaN(chr2)) line += "==";
			else {
				line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
				line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
			}
			if (maxline && line.length > maxline) {
				output += line.substr(0, maxline) + "\r\n";
				line = line.substr(maxline);
			}
		}
		output += line;
		return output;
	};
	/**
	* Decodes a base64-encoded string to a Uint8Array.
	*
	* @param input the base64-encoded input string.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.binary.base64.decode = function(input, output, offset) {
		var out = output;
		if (!out) out = new Uint8Array(Math.ceil(input.length / 4) * 3);
		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
		offset = offset || 0;
		var enc1, enc2, enc3, enc4;
		var i = 0, j = offset;
		while (i < input.length) {
			enc1 = _base64Idx[input.charCodeAt(i++) - 43];
			enc2 = _base64Idx[input.charCodeAt(i++) - 43];
			enc3 = _base64Idx[input.charCodeAt(i++) - 43];
			enc4 = _base64Idx[input.charCodeAt(i++) - 43];
			out[j++] = enc1 << 2 | enc2 >> 4;
			if (enc3 !== 64) {
				out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
				if (enc4 !== 64) out[j++] = (enc3 & 3) << 6 | enc4;
			}
		}
		return output ? j - offset : out.subarray(0, j);
	};
	util.binary.base58.encode = function(input, maxline) {
		return util.binary.baseN.encode(input, _base58, maxline);
	};
	util.binary.base58.decode = function(input, maxline) {
		return util.binary.baseN.decode(input, _base58, maxline);
	};
	util.text = {
		utf8: {},
		utf16: {}
	};
	/**
	* Encodes the given string as UTF-8 in a Uint8Array.
	*
	* @param str the string to encode.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.text.utf8.encode = function(str, output, offset) {
		str = util.encodeUtf8(str);
		var out = output;
		if (!out) out = new Uint8Array(str.length);
		offset = offset || 0;
		var j = offset;
		for (var i = 0; i < str.length; ++i) out[j++] = str.charCodeAt(i);
		return output ? j - offset : out;
	};
	/**
	* Decodes the UTF-8 contents from a Uint8Array.
	*
	* @param bytes the Uint8Array to decode.
	*
	* @return the resulting string.
	*/
	util.text.utf8.decode = function(bytes) {
		return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
	};
	/**
	* Encodes the given string as UTF-16 in a Uint8Array.
	*
	* @param str the string to encode.
	* @param [output] an optional Uint8Array to write the output to; if it
	*          is too small, an exception will be thrown.
	* @param [offset] the start offset for writing to the output (default: 0).
	*
	* @return the Uint8Array or the number of bytes written if output was given.
	*/
	util.text.utf16.encode = function(str, output, offset) {
		var out = output;
		if (!out) out = new Uint8Array(str.length * 2);
		var view = new Uint16Array(out.buffer);
		offset = offset || 0;
		var j = offset;
		var k = offset;
		for (var i = 0; i < str.length; ++i) {
			view[k++] = str.charCodeAt(i);
			j += 2;
		}
		return output ? j - offset : out;
	};
	/**
	* Decodes the UTF-16 contents from a Uint8Array.
	*
	* @param bytes the Uint8Array to decode.
	*
	* @return the resulting string.
	*/
	util.text.utf16.decode = function(bytes) {
		return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
	};
	/**
	* Deflates the given data using a flash interface.
	*
	* @param api the flash interface.
	* @param bytes the data.
	* @param raw true to return only raw deflate data, false to include zlib
	*          header and trailer.
	*
	* @return the deflated data as a string.
	*/
	util.deflate = function(api, bytes, raw) {
		bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
		if (raw) {
			var start = 2;
			if (bytes.charCodeAt(1) & 32) start = 6;
			bytes = bytes.substring(start, bytes.length - 4);
		}
		return bytes;
	};
	/**
	* Inflates the given data using a flash interface.
	*
	* @param api the flash interface.
	* @param bytes the data.
	* @param raw true if the incoming data has no zlib header or trailer and is
	*          raw DEFLATE data.
	*
	* @return the inflated data as a string, null on error.
	*/
	util.inflate = function(api, bytes, raw) {
		var rval = api.inflate(util.encode64(bytes)).rval;
		return rval === null ? null : util.decode64(rval);
	};
	/**
	* Sets a storage object.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	* @param obj the storage object, null to remove.
	*/
	var _setStorageObject = function(api, id, obj) {
		if (!api) throw new Error("WebStorage not available.");
		var rval;
		if (obj === null) rval = api.removeItem(id);
		else {
			obj = util.encode64(JSON.stringify(obj));
			rval = api.setItem(id, obj);
		}
		if (typeof rval !== "undefined" && rval.rval !== true) {
			var error = new Error(rval.error.message);
			error.id = rval.error.id;
			error.name = rval.error.name;
			throw error;
		}
	};
	/**
	* Gets a storage object.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	*
	* @return the storage object entry or null if none exists.
	*/
	var _getStorageObject = function(api, id) {
		if (!api) throw new Error("WebStorage not available.");
		var rval = api.getItem(id);
		if (api.init) if (rval.rval === null) {
			if (rval.error) {
				var error = new Error(rval.error.message);
				error.id = rval.error.id;
				error.name = rval.error.name;
				throw error;
			}
			rval = null;
		} else rval = rval.rval;
		if (rval !== null) rval = JSON.parse(util.decode64(rval));
		return rval;
	};
	/**
	* Stores an item in local storage.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	* @param key the key for the item.
	* @param data the data for the item (any javascript object/primitive).
	*/
	var _setItem = function(api, id, key, data) {
		var obj = _getStorageObject(api, id);
		if (obj === null) obj = {};
		obj[key] = data;
		_setStorageObject(api, id, obj);
	};
	/**
	* Gets an item from local storage.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	* @param key the key for the item.
	*
	* @return the item.
	*/
	var _getItem = function(api, id, key) {
		var rval = _getStorageObject(api, id);
		if (rval !== null) rval = key in rval ? rval[key] : null;
		return rval;
	};
	/**
	* Removes an item from local storage.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	* @param key the key for the item.
	*/
	var _removeItem = function(api, id, key) {
		var obj = _getStorageObject(api, id);
		if (obj !== null && key in obj) {
			delete obj[key];
			var empty = true;
			for (var prop in obj) {
				empty = false;
				break;
			}
			if (empty) obj = null;
			_setStorageObject(api, id, obj);
		}
	};
	/**
	* Clears the local disk storage identified by the given ID.
	*
	* @param api the storage interface.
	* @param id the storage ID to use.
	*/
	var _clearItems = function(api, id) {
		_setStorageObject(api, id, null);
	};
	/**
	* Calls a storage function.
	*
	* @param func the function to call.
	* @param args the arguments for the function.
	* @param location the location argument.
	*
	* @return the return value from the function.
	*/
	var _callStorageFunction = function(func, args, location) {
		var rval = null;
		if (typeof location === "undefined") location = ["web", "flash"];
		var type;
		var done = false;
		var exception = null;
		for (var idx in location) {
			type = location[idx];
			try {
				if (type === "flash" || type === "both") {
					if (args[0] === null) throw new Error("Flash local storage not available.");
					rval = func.apply(this, args);
					done = type === "flash";
				}
				if (type === "web" || type === "both") {
					args[0] = localStorage;
					rval = func.apply(this, args);
					done = true;
				}
			} catch (ex) {
				exception = ex;
			}
			if (done) break;
		}
		if (!done) throw exception;
		return rval;
	};
	/**
	* Stores an item on local disk.
	*
	* The available types of local storage include 'flash', 'web', and 'both'.
	*
	* The type 'flash' refers to flash local storage (SharedObject). In order
	* to use flash local storage, the 'api' parameter must be valid. The type
	* 'web' refers to WebStorage, if supported by the browser. The type 'both'
	* refers to storing using both 'flash' and 'web', not just one or the
	* other.
	*
	* The location array should list the storage types to use in order of
	* preference:
	*
	* ['flash']: flash only storage
	* ['web']: web only storage
	* ['both']: try to store in both
	* ['flash','web']: store in flash first, but if not available, 'web'
	* ['web','flash']: store in web first, but if not available, 'flash'
	*
	* The location array defaults to: ['web', 'flash']
	*
	* @param api the flash interface, null to use only WebStorage.
	* @param id the storage ID to use.
	* @param key the key for the item.
	* @param data the data for the item (any javascript object/primitive).
	* @param location an array with the preferred types of storage to use.
	*/
	util.setItem = function(api, id, key, data, location) {
		_callStorageFunction(_setItem, arguments, location);
	};
	/**
	* Gets an item on local disk.
	*
	* Set setItem() for details on storage types.
	*
	* @param api the flash interface, null to use only WebStorage.
	* @param id the storage ID to use.
	* @param key the key for the item.
	* @param location an array with the preferred types of storage to use.
	*
	* @return the item.
	*/
	util.getItem = function(api, id, key, location) {
		return _callStorageFunction(_getItem, arguments, location);
	};
	/**
	* Removes an item on local disk.
	*
	* Set setItem() for details on storage types.
	*
	* @param api the flash interface.
	* @param id the storage ID to use.
	* @param key the key for the item.
	* @param location an array with the preferred types of storage to use.
	*/
	util.removeItem = function(api, id, key, location) {
		_callStorageFunction(_removeItem, arguments, location);
	};
	/**
	* Clears the local disk storage identified by the given ID.
	*
	* Set setItem() for details on storage types.
	*
	* @param api the flash interface if flash is available.
	* @param id the storage ID to use.
	* @param location an array with the preferred types of storage to use.
	*/
	util.clearItems = function(api, id, location) {
		_callStorageFunction(_clearItems, arguments, location);
	};
	/**
	* Check if an object is empty.
	*
	* Taken from:
	* http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
	*
	* @param object the object to check.
	*/
	util.isEmpty = function(obj) {
		for (var prop in obj) if (obj.hasOwnProperty(prop)) return false;
		return true;
	};
	/**
	* Format with simple printf-style interpolation.
	*
	* %%: literal '%'
	* %s,%o: convert next argument into a string.
	*
	* @param format the string to format.
	* @param ... arguments to interpolate into the format string.
	*/
	util.format = function(format) {
		var re = /%./g;
		var match;
		var part;
		var argi = 0;
		var parts = [];
		var last = 0;
		while (match = re.exec(format)) {
			part = format.substring(last, re.lastIndex - 2);
			if (part.length > 0) parts.push(part);
			last = re.lastIndex;
			var code = match[0][1];
			switch (code) {
				case "s":
				case "o":
					if (argi < arguments.length) parts.push(arguments[argi++ + 1]);
					else parts.push("<?>");
					break;
				case "%":
					parts.push("%");
					break;
				default: parts.push("<%" + code + "?>");
			}
		}
		parts.push(format.substring(last));
		return parts.join("");
	};
	/**
	* Formats a number.
	*
	* http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
	*/
	util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
		var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
		var d = dec_point === void 0 ? "," : dec_point;
		var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
		var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
		var j = i.length > 3 ? i.length % 3 : 0;
		return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
	};
	/**
	* Formats a byte size.
	*
	* http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
	*/
	util.formatSize = function(size) {
		if (size >= 1073741824) size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
		else if (size >= 1048576) size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
		else if (size >= 1024) size = util.formatNumber(size / 1024, 0) + " KiB";
		else size = util.formatNumber(size, 0) + " bytes";
		return size;
	};
	/**
	* Converts an IPv4 or IPv6 string representation into bytes (in network order).
	*
	* @param ip the IPv4 or IPv6 address to convert.
	*
	* @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
	*         be parsed.
	*/
	util.bytesFromIP = function(ip) {
		if (ip.indexOf(".") !== -1) return util.bytesFromIPv4(ip);
		if (ip.indexOf(":") !== -1) return util.bytesFromIPv6(ip);
		return null;
	};
	/**
	* Converts an IPv4 string representation into bytes (in network order).
	*
	* @param ip the IPv4 address to convert.
	*
	* @return the 4-byte address or null if the address can't be parsed.
	*/
	util.bytesFromIPv4 = function(ip) {
		ip = ip.split(".");
		if (ip.length !== 4) return null;
		var b = util.createBuffer();
		for (var i = 0; i < ip.length; ++i) {
			var num = parseInt(ip[i], 10);
			if (isNaN(num)) return null;
			b.putByte(num);
		}
		return b.getBytes();
	};
	/**
	* Converts an IPv6 string representation into bytes (in network order).
	*
	* @param ip the IPv6 address to convert.
	*
	* @return the 16-byte address or null if the address can't be parsed.
	*/
	util.bytesFromIPv6 = function(ip) {
		var blanks = 0;
		ip = ip.split(":").filter(function(e) {
			if (e.length === 0) ++blanks;
			return true;
		});
		var zeros = (8 - ip.length + blanks) * 2;
		var b = util.createBuffer();
		for (var i = 0; i < 8; ++i) {
			if (!ip[i] || ip[i].length === 0) {
				b.fillWithByte(0, zeros);
				zeros = 0;
				continue;
			}
			var bytes = util.hexToBytes(ip[i]);
			if (bytes.length < 2) b.putByte(0);
			b.putBytes(bytes);
		}
		return b.getBytes();
	};
	/**
	* Converts 4-bytes into an IPv4 string representation or 16-bytes into
	* an IPv6 string representation. The bytes must be in network order.
	*
	* @param bytes the bytes to convert.
	*
	* @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
	*         respectively, are given, otherwise null.
	*/
	util.bytesToIP = function(bytes) {
		if (bytes.length === 4) return util.bytesToIPv4(bytes);
		if (bytes.length === 16) return util.bytesToIPv6(bytes);
		return null;
	};
	/**
	* Converts 4-bytes into an IPv4 string representation. The bytes must be
	* in network order.
	*
	* @param bytes the bytes to convert.
	*
	* @return the IPv4 string representation or null for an invalid # of bytes.
	*/
	util.bytesToIPv4 = function(bytes) {
		if (bytes.length !== 4) return null;
		var ip = [];
		for (var i = 0; i < bytes.length; ++i) ip.push(bytes.charCodeAt(i));
		return ip.join(".");
	};
	/**
	* Converts 16-bytes into an IPv16 string representation. The bytes must be
	* in network order.
	*
	* @param bytes the bytes to convert.
	*
	* @return the IPv16 string representation or null for an invalid # of bytes.
	*/
	util.bytesToIPv6 = function(bytes) {
		if (bytes.length !== 16) return null;
		var ip = [];
		var zeroGroups = [];
		var zeroMaxGroup = 0;
		for (var i = 0; i < bytes.length; i += 2) {
			var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
			while (hex[0] === "0" && hex !== "0") hex = hex.substr(1);
			if (hex === "0") {
				var last = zeroGroups[zeroGroups.length - 1];
				var idx = ip.length;
				if (!last || idx !== last.end + 1) zeroGroups.push({
					start: idx,
					end: idx
				});
				else {
					last.end = idx;
					if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) zeroMaxGroup = zeroGroups.length - 1;
				}
			}
			ip.push(hex);
		}
		if (zeroGroups.length > 0) {
			var group = zeroGroups[zeroMaxGroup];
			if (group.end - group.start > 0) {
				ip.splice(group.start, group.end - group.start + 1, "");
				if (group.start === 0) ip.unshift("");
				if (group.end === 7) ip.push("");
			}
		}
		return ip.join(":");
	};
	/**
	* Estimates the number of processes that can be run concurrently. If
	* creating Web Workers, keep in mind that the main JavaScript process needs
	* its own core.
	*
	* @param options the options to use:
	*          update true to force an update (not use the cached value).
	* @param callback(err, max) called once the operation completes.
	*/
	util.estimateCores = function(options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}
		options = options || {};
		if ("cores" in util && !options.update) return callback(null, util.cores);
		if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
			util.cores = navigator.hardwareConcurrency;
			return callback(null, util.cores);
		}
		if (typeof Worker === "undefined") {
			util.cores = 1;
			return callback(null, util.cores);
		}
		if (typeof Blob === "undefined") {
			util.cores = 2;
			return callback(null, util.cores);
		}
		var blobUrl = URL.createObjectURL(new Blob([
			"(",
			function() {
				self.addEventListener("message", function(e) {
					var st = Date.now();
					var et = st + 4;
					while (Date.now() < et);
					self.postMessage({
						st,
						et
					});
				});
			}.toString(),
			")()"
		], { type: "application/javascript" }));
		sample([], 5, 16);
		function sample(max, samples, numWorkers) {
			if (samples === 0) {
				var avg = Math.floor(max.reduce(function(avg, x) {
					return avg + x;
				}, 0) / max.length);
				util.cores = Math.max(1, avg);
				URL.revokeObjectURL(blobUrl);
				return callback(null, util.cores);
			}
			map(numWorkers, function(err, results) {
				max.push(reduce(numWorkers, results));
				sample(max, samples - 1, numWorkers);
			});
		}
		function map(numWorkers, callback) {
			var workers = [];
			var results = [];
			for (var i = 0; i < numWorkers; ++i) {
				var worker = new Worker(blobUrl);
				worker.addEventListener("message", function(e) {
					results.push(e.data);
					if (results.length === numWorkers) {
						for (var i = 0; i < numWorkers; ++i) workers[i].terminate();
						callback(null, results);
					}
				});
				workers.push(worker);
			}
			for (var i = 0; i < numWorkers; ++i) workers[i].postMessage(i);
		}
		function reduce(numWorkers, results) {
			var overlaps = [];
			for (var n = 0; n < numWorkers; ++n) {
				var r1 = results[n];
				var overlap = overlaps[n] = [];
				for (var i = 0; i < numWorkers; ++i) {
					if (n === i) continue;
					var r2 = results[i];
					if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) overlap.push(i);
				}
			}
			return overlaps.reduce(function(max, overlap) {
				return Math.max(max, overlap.length);
			}, 0);
		}
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/cipher.js
var require_cipher = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Cipher base API.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	module.exports = forge.cipher = forge.cipher || {};
	forge.cipher.algorithms = forge.cipher.algorithms || {};
	/**
	* Creates a cipher object that can be used to encrypt data using the given
	* algorithm and key. The algorithm may be provided as a string value for a
	* previously registered algorithm or it may be given as a cipher algorithm
	* API object.
	*
	* @param algorithm the algorithm to use, either a string or an algorithm API
	*          object.
	* @param key the key to use, as a binary-encoded string of bytes or a
	*          byte buffer.
	*
	* @return the cipher.
	*/
	forge.cipher.createCipher = function(algorithm, key) {
		var api = algorithm;
		if (typeof api === "string") {
			api = forge.cipher.getAlgorithm(api);
			if (api) api = api();
		}
		if (!api) throw new Error("Unsupported algorithm: " + algorithm);
		return new forge.cipher.BlockCipher({
			algorithm: api,
			key,
			decrypt: false
		});
	};
	/**
	* Creates a decipher object that can be used to decrypt data using the given
	* algorithm and key. The algorithm may be provided as a string value for a
	* previously registered algorithm or it may be given as a cipher algorithm
	* API object.
	*
	* @param algorithm the algorithm to use, either a string or an algorithm API
	*          object.
	* @param key the key to use, as a binary-encoded string of bytes or a
	*          byte buffer.
	*
	* @return the cipher.
	*/
	forge.cipher.createDecipher = function(algorithm, key) {
		var api = algorithm;
		if (typeof api === "string") {
			api = forge.cipher.getAlgorithm(api);
			if (api) api = api();
		}
		if (!api) throw new Error("Unsupported algorithm: " + algorithm);
		return new forge.cipher.BlockCipher({
			algorithm: api,
			key,
			decrypt: true
		});
	};
	/**
	* Registers an algorithm by name. If the name was already registered, the
	* algorithm API object will be overwritten.
	*
	* @param name the name of the algorithm.
	* @param algorithm the algorithm API object.
	*/
	forge.cipher.registerAlgorithm = function(name, algorithm) {
		name = name.toUpperCase();
		forge.cipher.algorithms[name] = algorithm;
	};
	/**
	* Gets a registered algorithm by name.
	*
	* @param name the name of the algorithm.
	*
	* @return the algorithm, if found, null if not.
	*/
	forge.cipher.getAlgorithm = function(name) {
		name = name.toUpperCase();
		if (name in forge.cipher.algorithms) return forge.cipher.algorithms[name];
		return null;
	};
	var BlockCipher = forge.cipher.BlockCipher = function(options) {
		this.algorithm = options.algorithm;
		this.mode = this.algorithm.mode;
		this.blockSize = this.mode.blockSize;
		this._finish = false;
		this._input = null;
		this.output = null;
		this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
		this._decrypt = options.decrypt;
		this.algorithm.initialize(options);
	};
	/**
	* Starts or restarts the encryption or decryption process, whichever
	* was previously configured.
	*
	* For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
	* of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in
	* bytes, then it must be Nb (16) bytes in length. If the IV is given in as
	* 32-bit integers, then it must be 4 integers long.
	*
	* Note: an IV is not required or used in ECB mode.
	*
	* For GCM-mode, the IV must be given as a binary-encoded string of bytes or
	* a byte buffer. The number of bytes should be 12 (96 bits) as recommended
	* by NIST SP-800-38D but another length may be given.
	*
	* @param options the options to use:
	*          iv the initialization vector to use as a binary-encoded string of
	*            bytes, null to reuse the last ciphered block from a previous
	*            update() (this "residue" method is for legacy support only).
	*          additionalData additional authentication data as a binary-encoded
	*            string of bytes, for 'GCM' mode, (default: none).
	*          tagLength desired length of authentication tag, in bits, for
	*            'GCM' mode (0-128, default: 128).
	*          tag the authentication tag to check if decrypting, as a
	*             binary-encoded string of bytes.
	*          output the output the buffer to write to, null to create one.
	*/
	BlockCipher.prototype.start = function(options) {
		options = options || {};
		var opts = {};
		for (var key in options) opts[key] = options[key];
		opts.decrypt = this._decrypt;
		this._finish = false;
		this._input = forge.util.createBuffer();
		this.output = options.output || forge.util.createBuffer();
		this.mode.start(opts);
	};
	/**
	* Updates the next block according to the cipher mode.
	*
	* @param input the buffer to read from.
	*/
	BlockCipher.prototype.update = function(input) {
		if (input) this._input.putBuffer(input);
		while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish);
		this._input.compact();
	};
	/**
	* Finishes encrypting or decrypting.
	*
	* @param pad a padding function to use in CBC mode, null for default,
	*          signature(blockSize, buffer, decrypt).
	*
	* @return true if successful, false on error.
	*/
	BlockCipher.prototype.finish = function(pad) {
		if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
			this.mode.pad = function(input) {
				return pad(this.blockSize, input, false);
			};
			this.mode.unpad = function(output) {
				return pad(this.blockSize, output, true);
			};
		}
		var options = {};
		options.decrypt = this._decrypt;
		options.overflow = this._input.length() % this.blockSize;
		if (!this._decrypt && this.mode.pad) {
			if (!this.mode.pad(this._input, options)) return false;
		}
		this._finish = true;
		this.update();
		if (this._decrypt && this.mode.unpad) {
			if (!this.mode.unpad(this.output, options)) return false;
		}
		if (this.mode.afterFinish) {
			if (!this.mode.afterFinish(this.output, options)) return false;
		}
		return true;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Supported cipher modes.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	forge.cipher = forge.cipher || {};
	var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};
	/** Electronic codebook (ECB) (Don't use this; it's not secure) **/
	modes.ecb = function(options) {
		options = options || {};
		this.name = "ECB";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = new Array(this._ints);
		this._outBlock = new Array(this._ints);
	};
	modes.ecb.prototype.start = function(options) {};
	modes.ecb.prototype.encrypt = function(input, output, finish) {
		if (input.length() < this.blockSize && !(finish && input.length() > 0)) return true;
		for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32();
		this.cipher.encrypt(this._inBlock, this._outBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i]);
	};
	modes.ecb.prototype.decrypt = function(input, output, finish) {
		if (input.length() < this.blockSize && !(finish && input.length() > 0)) return true;
		for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32();
		this.cipher.decrypt(this._inBlock, this._outBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i]);
	};
	modes.ecb.prototype.pad = function(input, options) {
		var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
		input.fillWithByte(padding, padding);
		return true;
	};
	modes.ecb.prototype.unpad = function(output, options) {
		if (options.overflow > 0) return false;
		var len = output.length();
		var count = output.at(len - 1);
		if (count > this.blockSize << 2) return false;
		output.truncate(count);
		return true;
	};
	/** Cipher-block Chaining (CBC) **/
	modes.cbc = function(options) {
		options = options || {};
		this.name = "CBC";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = new Array(this._ints);
		this._outBlock = new Array(this._ints);
	};
	modes.cbc.prototype.start = function(options) {
		if (options.iv === null) {
			if (!this._prev) throw new Error("Invalid IV parameter.");
			this._iv = this._prev.slice(0);
		} else if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		else {
			this._iv = transformIV(options.iv, this.blockSize);
			this._prev = this._iv.slice(0);
		}
	};
	modes.cbc.prototype.encrypt = function(input, output, finish) {
		if (input.length() < this.blockSize && !(finish && input.length() > 0)) return true;
		for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._prev[i] ^ input.getInt32();
		this.cipher.encrypt(this._inBlock, this._outBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i]);
		this._prev = this._outBlock;
	};
	modes.cbc.prototype.decrypt = function(input, output, finish) {
		if (input.length() < this.blockSize && !(finish && input.length() > 0)) return true;
		for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32();
		this.cipher.decrypt(this._inBlock, this._outBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._prev[i] ^ this._outBlock[i]);
		this._prev = this._inBlock.slice(0);
	};
	modes.cbc.prototype.pad = function(input, options) {
		var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
		input.fillWithByte(padding, padding);
		return true;
	};
	modes.cbc.prototype.unpad = function(output, options) {
		if (options.overflow > 0) return false;
		var len = output.length();
		var count = output.at(len - 1);
		if (count > this.blockSize << 2) return false;
		output.truncate(count);
		return true;
	};
	/** Cipher feedback (CFB) **/
	modes.cfb = function(options) {
		options = options || {};
		this.name = "CFB";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = null;
		this._outBlock = new Array(this._ints);
		this._partialBlock = new Array(this._ints);
		this._partialOutput = forge.util.createBuffer();
		this._partialBytes = 0;
	};
	modes.cfb.prototype.start = function(options) {
		if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		this._iv = transformIV(options.iv, this.blockSize);
		this._inBlock = this._iv.slice(0);
		this._partialBytes = 0;
	};
	modes.cfb.prototype.encrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) {
			for (var i = 0; i < this._ints; ++i) {
				this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
				output.putInt32(this._inBlock[i]);
			}
			return;
		}
		var partialBytes = (this.blockSize - inputLength) % this.blockSize;
		if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
		this._partialOutput.clear();
		for (var i = 0; i < this._ints; ++i) {
			this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
			this._partialOutput.putInt32(this._partialBlock[i]);
		}
		if (partialBytes > 0) input.read -= this.blockSize;
		else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i];
		if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
		if (partialBytes > 0 && !finish) {
			output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
			this._partialBytes = partialBytes;
			return true;
		}
		output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
		this._partialBytes = 0;
	};
	modes.cfb.prototype.decrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) {
			for (var i = 0; i < this._ints; ++i) {
				this._inBlock[i] = input.getInt32();
				output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
			}
			return;
		}
		var partialBytes = (this.blockSize - inputLength) % this.blockSize;
		if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
		this._partialOutput.clear();
		for (var i = 0; i < this._ints; ++i) {
			this._partialBlock[i] = input.getInt32();
			this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
		}
		if (partialBytes > 0) input.read -= this.blockSize;
		else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i];
		if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
		if (partialBytes > 0 && !finish) {
			output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
			this._partialBytes = partialBytes;
			return true;
		}
		output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
		this._partialBytes = 0;
	};
	/** Output feedback (OFB) **/
	modes.ofb = function(options) {
		options = options || {};
		this.name = "OFB";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = null;
		this._outBlock = new Array(this._ints);
		this._partialOutput = forge.util.createBuffer();
		this._partialBytes = 0;
	};
	modes.ofb.prototype.start = function(options) {
		if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		this._iv = transformIV(options.iv, this.blockSize);
		this._inBlock = this._iv.slice(0);
		this._partialBytes = 0;
	};
	modes.ofb.prototype.encrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (input.length() === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) {
			for (var i = 0; i < this._ints; ++i) {
				output.putInt32(input.getInt32() ^ this._outBlock[i]);
				this._inBlock[i] = this._outBlock[i];
			}
			return;
		}
		var partialBytes = (this.blockSize - inputLength) % this.blockSize;
		if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
		this._partialOutput.clear();
		for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
		if (partialBytes > 0) input.read -= this.blockSize;
		else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._outBlock[i];
		if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
		if (partialBytes > 0 && !finish) {
			output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
			this._partialBytes = partialBytes;
			return true;
		}
		output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
		this._partialBytes = 0;
	};
	modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
	/** Counter (CTR) **/
	modes.ctr = function(options) {
		options = options || {};
		this.name = "CTR";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = null;
		this._outBlock = new Array(this._ints);
		this._partialOutput = forge.util.createBuffer();
		this._partialBytes = 0;
	};
	modes.ctr.prototype.start = function(options) {
		if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		this._iv = transformIV(options.iv, this.blockSize);
		this._inBlock = this._iv.slice(0);
		this._partialBytes = 0;
	};
	modes.ctr.prototype.encrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) for (var i = 0; i < this._ints; ++i) output.putInt32(input.getInt32() ^ this._outBlock[i]);
		else {
			var partialBytes = (this.blockSize - inputLength) % this.blockSize;
			if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
			this._partialOutput.clear();
			for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
			if (partialBytes > 0) input.read -= this.blockSize;
			if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
			if (partialBytes > 0 && !finish) {
				output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
				this._partialBytes = partialBytes;
				return true;
			}
			output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
			this._partialBytes = 0;
		}
		inc32(this._inBlock);
	};
	modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
	/** Galois/Counter Mode (GCM) **/
	modes.gcm = function(options) {
		options = options || {};
		this.name = "GCM";
		this.cipher = options.cipher;
		this.blockSize = options.blockSize || 16;
		this._ints = this.blockSize / 4;
		this._inBlock = new Array(this._ints);
		this._outBlock = new Array(this._ints);
		this._partialOutput = forge.util.createBuffer();
		this._partialBytes = 0;
		this._R = 3774873600;
	};
	modes.gcm.prototype.start = function(options) {
		if (!("iv" in options)) throw new Error("Invalid IV parameter.");
		var iv = forge.util.createBuffer(options.iv);
		this._cipherLength = 0;
		var additionalData;
		if ("additionalData" in options) additionalData = forge.util.createBuffer(options.additionalData);
		else additionalData = forge.util.createBuffer();
		if ("tagLength" in options) this._tagLength = options.tagLength;
		else this._tagLength = 128;
		this._tag = null;
		if (options.decrypt) {
			this._tag = forge.util.createBuffer(options.tag).getBytes();
			if (this._tag.length !== this._tagLength / 8) throw new Error("Authentication tag does not match tag length.");
		}
		this._hashBlock = new Array(this._ints);
		this.tag = null;
		this._hashSubkey = new Array(this._ints);
		this.cipher.encrypt([
			0,
			0,
			0,
			0
		], this._hashSubkey);
		this.componentBits = 4;
		this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
		var ivLength = iv.length();
		if (ivLength === 12) this._j0 = [
			iv.getInt32(),
			iv.getInt32(),
			iv.getInt32(),
			1
		];
		else {
			this._j0 = [
				0,
				0,
				0,
				0
			];
			while (iv.length() > 0) this._j0 = this.ghash(this._hashSubkey, this._j0, [
				iv.getInt32(),
				iv.getInt32(),
				iv.getInt32(),
				iv.getInt32()
			]);
			this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
		}
		this._inBlock = this._j0.slice(0);
		inc32(this._inBlock);
		this._partialBytes = 0;
		additionalData = forge.util.createBuffer(additionalData);
		this._aDataLength = from64To32(additionalData.length() * 8);
		var overflow = additionalData.length() % this.blockSize;
		if (overflow) additionalData.fillWithByte(0, this.blockSize - overflow);
		this._s = [
			0,
			0,
			0,
			0
		];
		while (additionalData.length() > 0) this._s = this.ghash(this._hashSubkey, this._s, [
			additionalData.getInt32(),
			additionalData.getInt32(),
			additionalData.getInt32(),
			additionalData.getInt32()
		]);
	};
	modes.gcm.prototype.encrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength === 0) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		if (this._partialBytes === 0 && inputLength >= this.blockSize) {
			for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i] ^= input.getInt32());
			this._cipherLength += this.blockSize;
		} else {
			var partialBytes = (this.blockSize - inputLength) % this.blockSize;
			if (partialBytes > 0) partialBytes = this.blockSize - partialBytes;
			this._partialOutput.clear();
			for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
			if (partialBytes <= 0 || finish) {
				if (finish) {
					var overflow = inputLength % this.blockSize;
					this._cipherLength += overflow;
					this._partialOutput.truncate(this.blockSize - overflow);
				} else this._cipherLength += this.blockSize;
				for (var i = 0; i < this._ints; ++i) this._outBlock[i] = this._partialOutput.getInt32();
				this._partialOutput.read -= this.blockSize;
			}
			if (this._partialBytes > 0) this._partialOutput.getBytes(this._partialBytes);
			if (partialBytes > 0 && !finish) {
				input.read -= this.blockSize;
				output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
				this._partialBytes = partialBytes;
				return true;
			}
			output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
			this._partialBytes = 0;
		}
		this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
		inc32(this._inBlock);
	};
	modes.gcm.prototype.decrypt = function(input, output, finish) {
		var inputLength = input.length();
		if (inputLength < this.blockSize && !(finish && inputLength > 0)) return true;
		this.cipher.encrypt(this._inBlock, this._outBlock);
		inc32(this._inBlock);
		this._hashBlock[0] = input.getInt32();
		this._hashBlock[1] = input.getInt32();
		this._hashBlock[2] = input.getInt32();
		this._hashBlock[3] = input.getInt32();
		this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
		for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
		if (inputLength < this.blockSize) this._cipherLength += inputLength % this.blockSize;
		else this._cipherLength += this.blockSize;
	};
	modes.gcm.prototype.afterFinish = function(output, options) {
		var rval = true;
		if (options.decrypt && options.overflow) output.truncate(this.blockSize - options.overflow);
		this.tag = forge.util.createBuffer();
		var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
		this._s = this.ghash(this._hashSubkey, this._s, lengths);
		var tag = [];
		this.cipher.encrypt(this._j0, tag);
		for (var i = 0; i < this._ints; ++i) this.tag.putInt32(this._s[i] ^ tag[i]);
		this.tag.truncate(this.tag.length() % (this._tagLength / 8));
		if (options.decrypt && this.tag.bytes() !== this._tag) rval = false;
		return rval;
	};
	/**
	* See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois
	* field multiplication. The field, GF(2^128), is defined by the polynomial:
	*
	* x^128 + x^7 + x^2 + x + 1
	*
	* Which is represented in little-endian binary form as: 11100001 (0xe1). When
	* the value of a coefficient is 1, a bit is set. The value R, is the
	* concatenation of this value and 120 zero bits, yielding a 128-bit value
	* which matches the block size.
	*
	* This function will multiply two elements (vectors of bytes), X and Y, in
	* the field GF(2^128). The result is initialized to zero. For each bit of
	* X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)
	* by the current value of Y. For each bit, the value of Y will be raised by
	* a power of x (multiplied by the polynomial x). This can be achieved by
	* shifting Y once to the right. If the current value of Y, prior to being
	* multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.
	* Otherwise, we must divide by R after shifting to find the remainder.
	*
	* @param x the first block to multiply by the second.
	* @param y the second block to multiply by the first.
	*
	* @return the block result of the multiplication.
	*/
	modes.gcm.prototype.multiply = function(x, y) {
		var z_i = [
			0,
			0,
			0,
			0
		];
		var v_i = y.slice(0);
		for (var i = 0; i < 128; ++i) {
			if (x[i / 32 | 0] & 1 << 31 - i % 32) {
				z_i[0] ^= v_i[0];
				z_i[1] ^= v_i[1];
				z_i[2] ^= v_i[2];
				z_i[3] ^= v_i[3];
			}
			this.pow(v_i, v_i);
		}
		return z_i;
	};
	modes.gcm.prototype.pow = function(x, out) {
		var lsb = x[3] & 1;
		for (var i = 3; i > 0; --i) out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
		out[0] = x[0] >>> 1;
		if (lsb) out[0] ^= this._R;
	};
	modes.gcm.prototype.tableMultiply = function(x) {
		var z = [
			0,
			0,
			0,
			0
		];
		for (var i = 0; i < 32; ++i) {
			var x_i = x[i / 8 | 0] >>> (7 - i % 8) * 4 & 15;
			var ah = this._m[i][x_i];
			z[0] ^= ah[0];
			z[1] ^= ah[1];
			z[2] ^= ah[2];
			z[3] ^= ah[3];
		}
		return z;
	};
	/**
	* A continuing version of the GHASH algorithm that operates on a single
	* block. The hash block, last hash value (Ym) and the new block to hash
	* are given.
	*
	* @param h the hash block.
	* @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.
	* @param x the block to hash.
	*
	* @return the hashed value (Ym).
	*/
	modes.gcm.prototype.ghash = function(h, y, x) {
		y[0] ^= x[0];
		y[1] ^= x[1];
		y[2] ^= x[2];
		y[3] ^= x[3];
		return this.tableMultiply(y);
	};
	/**
	* Precomputes a table for multiplying against the hash subkey. This
	* mechanism provides a substantial speed increase over multiplication
	* performed without a table. The table-based multiplication this table is
	* for solves X * H by multiplying each component of X by H and then
	* composing the results together using XOR.
	*
	* This function can be used to generate tables with different bit sizes
	* for the components, however, this implementation assumes there are
	* 32 components of X (which is a 16 byte vector), therefore each component
	* takes 4-bits (so the table is constructed with bits=4).
	*
	* @param h the hash subkey.
	* @param bits the bit size for a component.
	*/
	modes.gcm.prototype.generateHashTable = function(h, bits) {
		var multiplier = 8 / bits;
		var perInt = 4 * multiplier;
		var size = 16 * multiplier;
		var m = new Array(size);
		for (var i = 0; i < size; ++i) {
			var tmp = [
				0,
				0,
				0,
				0
			];
			var idx = i / perInt | 0;
			var shft = (perInt - 1 - i % perInt) * bits;
			tmp[idx] = 1 << bits - 1 << shft;
			m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
		}
		return m;
	};
	/**
	* Generates a table for multiplying against the hash subkey for one
	* particular component (out of all possible component values).
	*
	* @param mid the pre-multiplied value for the middle key of the table.
	* @param bits the bit size for a component.
	*/
	modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
		var size = 1 << bits;
		var half = size >>> 1;
		var m = new Array(size);
		m[half] = mid.slice(0);
		var i = half >>> 1;
		while (i > 0) {
			this.pow(m[2 * i], m[i] = []);
			i >>= 1;
		}
		i = 2;
		while (i < half) {
			for (var j = 1; j < i; ++j) {
				var m_i = m[i];
				var m_j = m[j];
				m[i + j] = [
					m_i[0] ^ m_j[0],
					m_i[1] ^ m_j[1],
					m_i[2] ^ m_j[2],
					m_i[3] ^ m_j[3]
				];
			}
			i *= 2;
		}
		m[0] = [
			0,
			0,
			0,
			0
		];
		for (i = half + 1; i < size; ++i) {
			var c = m[i ^ half];
			m[i] = [
				mid[0] ^ c[0],
				mid[1] ^ c[1],
				mid[2] ^ c[2],
				mid[3] ^ c[3]
			];
		}
		return m;
	};
	/** Utility functions */
	function transformIV(iv, blockSize) {
		if (typeof iv === "string") iv = forge.util.createBuffer(iv);
		if (forge.util.isArray(iv) && iv.length > 4) {
			var tmp = iv;
			iv = forge.util.createBuffer();
			for (var i = 0; i < tmp.length; ++i) iv.putByte(tmp[i]);
		}
		if (iv.length() < blockSize) throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
		if (!forge.util.isArray(iv)) {
			var ints = [];
			var blocks = blockSize / 4;
			for (var i = 0; i < blocks; ++i) ints.push(iv.getInt32());
			iv = ints;
		}
		return iv;
	}
	function inc32(block) {
		block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
	}
	function from64To32(num) {
		return [num / 4294967296 | 0, num & 4294967295];
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/aes.js
var require_aes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Advanced Encryption Standard (AES) implementation.
	*
	* This implementation is based on the public domain library 'jscrypto' which
	* was written by:
	*
	* Emily Stark (estark@stanford.edu)
	* Mike Hamburg (mhamburg@stanford.edu)
	* Dan Boneh (dabo@cs.stanford.edu)
	*
	* Parts of this code are based on the OpenSSL implementation of AES:
	* http://www.openssl.org
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_cipher();
	require_cipherModes();
	require_util();
	module.exports = forge.aes = forge.aes || {};
	/**
	* Deprecated. Instead, use:
	*
	* var cipher = forge.cipher.createCipher('AES-<mode>', key);
	* cipher.start({iv: iv});
	*
	* Creates an AES cipher object to encrypt data using the given symmetric key.
	* The output will be stored in the 'output' member of the returned cipher.
	*
	* The key and iv may be given as a string of bytes, an array of bytes,
	* a byte buffer, or an array of 32-bit words.
	*
	* @param key the symmetric key to use.
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.aes.startEncrypting = function(key, iv, output, mode) {
		var cipher = _createCipher({
			key,
			output,
			decrypt: false,
			mode
		});
		cipher.start(iv);
		return cipher;
	};
	/**
	* Deprecated. Instead, use:
	*
	* var cipher = forge.cipher.createCipher('AES-<mode>', key);
	*
	* Creates an AES cipher object to encrypt data using the given symmetric key.
	*
	* The key may be given as a string of bytes, an array of bytes, a
	* byte buffer, or an array of 32-bit words.
	*
	* @param key the symmetric key to use.
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.aes.createEncryptionCipher = function(key, mode) {
		return _createCipher({
			key,
			output: null,
			decrypt: false,
			mode
		});
	};
	/**
	* Deprecated. Instead, use:
	*
	* var decipher = forge.cipher.createDecipher('AES-<mode>', key);
	* decipher.start({iv: iv});
	*
	* Creates an AES cipher object to decrypt data using the given symmetric key.
	* The output will be stored in the 'output' member of the returned cipher.
	*
	* The key and iv may be given as a string of bytes, an array of bytes,
	* a byte buffer, or an array of 32-bit words.
	*
	* @param key the symmetric key to use.
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.aes.startDecrypting = function(key, iv, output, mode) {
		var cipher = _createCipher({
			key,
			output,
			decrypt: true,
			mode
		});
		cipher.start(iv);
		return cipher;
	};
	/**
	* Deprecated. Instead, use:
	*
	* var decipher = forge.cipher.createDecipher('AES-<mode>', key);
	*
	* Creates an AES cipher object to decrypt data using the given symmetric key.
	*
	* The key may be given as a string of bytes, an array of bytes, a
	* byte buffer, or an array of 32-bit words.
	*
	* @param key the symmetric key to use.
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.aes.createDecryptionCipher = function(key, mode) {
		return _createCipher({
			key,
			output: null,
			decrypt: true,
			mode
		});
	};
	/**
	* Creates a new AES cipher algorithm object.
	*
	* @param name the name of the algorithm.
	* @param mode the mode factory function.
	*
	* @return the AES algorithm object.
	*/
	forge.aes.Algorithm = function(name, mode) {
		if (!init) initialize();
		var self = this;
		self.name = name;
		self.mode = new mode({
			blockSize: 16,
			cipher: {
				encrypt: function(inBlock, outBlock) {
					return _updateBlock(self._w, inBlock, outBlock, false);
				},
				decrypt: function(inBlock, outBlock) {
					return _updateBlock(self._w, inBlock, outBlock, true);
				}
			}
		});
		self._init = false;
	};
	/**
	* Initializes this AES algorithm by expanding its key.
	*
	* @param options the options to use.
	*          key the key to use with this algorithm.
	*          decrypt true if the algorithm should be initialized for decryption,
	*            false for encryption.
	*/
	forge.aes.Algorithm.prototype.initialize = function(options) {
		if (this._init) return;
		var key = options.key;
		var tmp;
		if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) key = forge.util.createBuffer(key);
		else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
			tmp = key;
			key = forge.util.createBuffer();
			for (var i = 0; i < tmp.length; ++i) key.putByte(tmp[i]);
		}
		if (!forge.util.isArray(key)) {
			tmp = key;
			key = [];
			var len = tmp.length();
			if (len === 16 || len === 24 || len === 32) {
				len = len >>> 2;
				for (var i = 0; i < len; ++i) key.push(tmp.getInt32());
			}
		}
		if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) throw new Error("Invalid key parameter.");
		var mode = this.mode.name;
		var encryptOp = [
			"CFB",
			"OFB",
			"CTR",
			"GCM"
		].indexOf(mode) !== -1;
		this._w = _expandKey(key, options.decrypt && !encryptOp);
		this._init = true;
	};
	/**
	* Expands a key. Typically only used for testing.
	*
	* @param key the symmetric key to expand, as an array of 32-bit words.
	* @param decrypt true to expand for decryption, false for encryption.
	*
	* @return the expanded key.
	*/
	forge.aes._expandKey = function(key, decrypt) {
		if (!init) initialize();
		return _expandKey(key, decrypt);
	};
	/**
	* Updates a single block. Typically only used for testing.
	*
	* @param w the expanded key to use.
	* @param input an array of block-size 32-bit words.
	* @param output an array of block-size 32-bit words.
	* @param decrypt true to decrypt, false to encrypt.
	*/
	forge.aes._updateBlock = _updateBlock;
	/** Register AES algorithms **/
	registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
	registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
	registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
	registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
	registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
	registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
	function registerAlgorithm(name, mode) {
		var factory = function() {
			return new forge.aes.Algorithm(name, mode);
		};
		forge.cipher.registerAlgorithm(name, factory);
	}
	/** AES implementation **/
	var init = false;
	var Nb = 4;
	var sbox;
	var isbox;
	var rcon;
	var mix;
	var imix;
	/**
	* Performs initialization, ie: precomputes tables to optimize for speed.
	*
	* One way to understand how AES works is to imagine that 'addition' and
	* 'multiplication' are interfaces that require certain mathematical
	* properties to hold true (ie: they are associative) but they might have
	* different implementations and produce different kinds of results ...
	* provided that their mathematical properties remain true. AES defines
	* its own methods of addition and multiplication but keeps some important
	* properties the same, ie: associativity and distributivity. The
	* explanation below tries to shed some light on how AES defines addition
	* and multiplication of bytes and 32-bit words in order to perform its
	* encryption and decryption algorithms.
	*
	* The basics:
	*
	* The AES algorithm views bytes as binary representations of polynomials
	* that have either 1 or 0 as the coefficients. It defines the addition
	* or subtraction of two bytes as the XOR operation. It also defines the
	* multiplication of two bytes as a finite field referred to as GF(2^8)
	* (Note: 'GF' means "Galois Field" which is a field that contains a finite
	* number of elements so GF(2^8) has 256 elements).
	*
	* This means that any two bytes can be represented as binary polynomials;
	* when they multiplied together and modularly reduced by an irreducible
	* polynomial of the 8th degree, the results are the field GF(2^8). The
	* specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
	* This multiplication is associative with 0x01 as the identity:
	*
	* (b * 0x01 = GF(b, 0x01) = b).
	*
	* The operation GF(b, 0x02) can be performed at the byte level by left
	* shifting b once and then XOR'ing it (to perform the modular reduction)
	* with 0x11b if b is >= 128. Repeated application of the multiplication
	* of 0x02 can be used to implement the multiplication of any two bytes.
	*
	* For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
	* be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
	* factors can each be multiplied by 0x57 and then added together. To do
	* the multiplication, values for 0x57 multiplied by each of these 3 factors
	* can be precomputed and stored in a table. To add them, the values from
	* the table are XOR'd together.
	*
	* AES also defines addition and multiplication of words, that is 4-byte
	* numbers represented as polynomials of 3 degrees where the coefficients
	* are the values of the bytes.
	*
	* The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
	*
	* Addition is performed by XOR'ing like powers of x. Multiplication
	* is performed in two steps, the first is an algebraic expansion as
	* you would do normally (where addition is XOR). But the result is
	* a polynomial larger than 3 degrees and thus it cannot fit in a word. So
	* next the result is modularly reduced by an AES-specific polynomial of
	* degree 4 which will always produce a polynomial of less than 4 degrees
	* such that it will fit in a word. In AES, this polynomial is x^4 + 1.
	*
	* The modular product of two polynomials 'a' and 'b' is thus:
	*
	* d(x) = d3x^3 + d2x^2 + d1x + d0
	* with
	* d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
	* d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
	* d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
	* d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
	*
	* As a matrix:
	*
	* [d0] = [a0 a3 a2 a1][b0]
	* [d1]   [a1 a0 a3 a2][b1]
	* [d2]   [a2 a1 a0 a3][b2]
	* [d3]   [a3 a2 a1 a0][b3]
	*
	* Special polynomials defined by AES (0x02 == {02}):
	* a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
	* a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
	*
	* These polynomials are used in the MixColumns() and InverseMixColumns()
	* operations, respectively, to cause each element in the state to affect
	* the output (referred to as diffusing).
	*
	* RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
	* polynomial x3.
	*
	* The ShiftRows() method modifies the last 3 rows in the state (where
	* the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
	* The 1st byte in the second row is moved to the end of the row. The 1st
	* and 2nd bytes in the third row are moved to the end of the row. The 1st,
	* 2nd, and 3rd bytes are moved in the fourth row.
	*
	* More details on how AES arithmetic works:
	*
	* In the polynomial representation of binary numbers, XOR performs addition
	* and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
	* corresponds with the multiplication of polynomials modulo an irreducible
	* polynomial of degree 8. In other words, for AES, GF(a, b) will multiply
	* polynomial 'a' with polynomial 'b' and then do a modular reduction by
	* an AES-specific irreducible polynomial of degree 8.
	*
	* A polynomial is irreducible if its only divisors are one and itself. For
	* the AES algorithm, this irreducible polynomial is:
	*
	* m(x) = x^8 + x^4 + x^3 + x + 1,
	*
	* or {01}{1b} in hexadecimal notation, where each coefficient is a bit:
	* 100011011 = 283 = 0x11b.
	*
	* For example, GF(0x57, 0x83) = 0xc1 because
	*
	* 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1
	* 0x85 = 131 = 10000101 = x^7 + x + 1
	*
	* (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)
	* =  x^13 + x^11 + x^9 + x^8 + x^7 +
	*    x^7 + x^5 + x^3 + x^2 + x +
	*    x^6 + x^4 + x^2 + x + 1
	* =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y
	*    y modulo (x^8 + x^4 + x^3 + x + 1)
	* =  x^7 + x^6 + 1.
	*
	* The modular reduction by m(x) guarantees the result will be a binary
	* polynomial of less than degree 8, so that it can fit in a byte.
	*
	* The operation to multiply a binary polynomial b with x (the polynomial
	* x in binary representation is 00000010) is:
	*
	* b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1
	*
	* To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the
	* most significant bit is 0 in b) then the result is already reduced. If
	* it is 1, then we can reduce it by subtracting m(x) via an XOR.
	*
	* It follows that multiplication by x (00000010 or 0x02) can be implemented
	* by performing a left shift followed by a conditional bitwise XOR with
	* 0x1b. This operation on bytes is denoted by xtime(). Multiplication by
	* higher powers of x can be implemented by repeated application of xtime().
	*
	* By adding intermediate results, multiplication by any constant can be
	* implemented. For instance:
	*
	* GF(0x57, 0x13) = 0xfe because:
	*
	* xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)
	*
	* Note: We XOR with 0x11b instead of 0x1b because in javascript our
	* datatype for b can be larger than 1 byte, so a left shift will not
	* automatically eliminate bits that overflow a byte ... by XOR'ing the
	* overflow bit with 1 (the extra one from 0x11b) we zero it out.
	*
	* GF(0x57, 0x02) = xtime(0x57) = 0xae
	* GF(0x57, 0x04) = xtime(0xae) = 0x47
	* GF(0x57, 0x08) = xtime(0x47) = 0x8e
	* GF(0x57, 0x10) = xtime(0x8e) = 0x07
	*
	* GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))
	*
	* And by the distributive property (since XOR is addition and GF() is
	* multiplication):
	*
	* = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)
	* = 0x57 ^ 0xae ^ 0x07
	* = 0xfe.
	*/
	function initialize() {
		init = true;
		rcon = [
			0,
			1,
			2,
			4,
			8,
			16,
			32,
			64,
			128,
			27,
			54
		];
		var xtime = new Array(256);
		for (var i = 0; i < 128; ++i) {
			xtime[i] = i << 1;
			xtime[i + 128] = i + 128 << 1 ^ 283;
		}
		sbox = new Array(256);
		isbox = new Array(256);
		mix = new Array(4);
		imix = new Array(4);
		for (var i = 0; i < 4; ++i) {
			mix[i] = new Array(256);
			imix[i] = new Array(256);
		}
		var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
		for (var i = 0; i < 256; ++i) {
			sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
			sx = sx >> 8 ^ sx & 255 ^ 99;
			sbox[e] = sx;
			isbox[sx] = e;
			sx2 = xtime[sx];
			e2 = xtime[e];
			e4 = xtime[e2];
			e8 = xtime[e4];
			me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
			ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
			for (var n = 0; n < 4; ++n) {
				mix[n][e] = me;
				imix[n][sx] = ime;
				me = me << 24 | me >>> 8;
				ime = ime << 24 | ime >>> 8;
			}
			if (e === 0) e = ei = 1;
			else {
				e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
				ei ^= xtime[xtime[ei]];
			}
		}
	}
	/**
	* Generates a key schedule using the AES key expansion algorithm.
	*
	* The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
	* routine to generate a key schedule. The Key Expansion generates a total
	* of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
	* and each of the Nr rounds requires Nb words of key data. The resulting
	* key schedule consists of a linear array of 4-byte words, denoted [wi ],
	* with i in the range 0 <= i < Nb(Nr + 1).
	*
	* KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
	* AES-128 (Nb=4, Nk=4, Nr=10)
	* AES-192 (Nb=4, Nk=6, Nr=12)
	* AES-256 (Nb=4, Nk=8, Nr=14)
	* Note: Nr=Nk+6.
	*
	* Nb is the number of columns (32-bit words) comprising the State (or
	* number of bytes in a block). For AES, Nb=4.
	*
	* @param key the key to schedule (as an array of 32-bit words).
	* @param decrypt true to modify the key schedule to decrypt, false not to.
	*
	* @return the generated key schedule.
	*/
	function _expandKey(key, decrypt) {
		var w = key.slice(0);
		var temp, iNk = 1;
		var Nk = w.length;
		var end = Nb * (Nk + 6 + 1);
		for (var i = Nk; i < end; ++i) {
			temp = w[i - 1];
			if (i % Nk === 0) {
				temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
				iNk++;
			} else if (Nk > 6 && i % Nk === 4) temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
			w[i] = w[i - Nk] ^ temp;
		}
		if (decrypt) {
			var tmp;
			var m0 = imix[0];
			var m1 = imix[1];
			var m2 = imix[2];
			var m3 = imix[3];
			var wnew = w.slice(0);
			end = w.length;
			for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) if (i === 0 || i === end - Nb) {
				wnew[i] = w[wi];
				wnew[i + 1] = w[wi + 3];
				wnew[i + 2] = w[wi + 2];
				wnew[i + 3] = w[wi + 1];
			} else for (var n = 0; n < Nb; ++n) {
				tmp = w[wi + n];
				wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
			}
			w = wnew;
		}
		return w;
	}
	/**
	* Updates a single block (16 bytes) using AES. The update will either
	* encrypt or decrypt the block.
	*
	* @param w the key schedule.
	* @param input the input block (an array of 32-bit words).
	* @param output the updated output block.
	* @param decrypt true to decrypt the block, false to encrypt it.
	*/
	function _updateBlock(w, input, output, decrypt) {
		var Nr = w.length / 4 - 1;
		var m0, m1, m2, m3, sub;
		if (decrypt) {
			m0 = imix[0];
			m1 = imix[1];
			m2 = imix[2];
			m3 = imix[3];
			sub = isbox;
		} else {
			m0 = mix[0];
			m1 = mix[1];
			m2 = mix[2];
			m3 = mix[3];
			sub = sbox;
		}
		var a = input[0] ^ w[0], b = input[decrypt ? 3 : 1] ^ w[1], c = input[2] ^ w[2], d = input[decrypt ? 1 : 3] ^ w[3], a2, b2, c2;
		var i = 3;
		for (var round = 1; round < Nr; ++round) {
			a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
			b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
			c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
			d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
			a = a2;
			b = b2;
			c = c2;
		}
		output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
		output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
		output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
		output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
	}
	/**
	* Deprecated. Instead, use:
	*
	* forge.cipher.createCipher('AES-<mode>', key);
	* forge.cipher.createDecipher('AES-<mode>', key);
	*
	* Creates a deprecated AES cipher object. This object's mode will default to
	* CBC (cipher-block-chaining).
	*
	* The key and iv may be given as a string of bytes, an array of bytes, a
	* byte buffer, or an array of 32-bit words.
	*
	* @param options the options to use.
	*          key the symmetric key to use.
	*          output the buffer to write to.
	*          decrypt true for decryption, false for encryption.
	*          mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	function _createCipher(options) {
		options = options || {};
		var algorithm = "AES-" + (options.mode || "CBC").toUpperCase();
		var cipher;
		if (options.decrypt) cipher = forge.cipher.createDecipher(algorithm, options.key);
		else cipher = forge.cipher.createCipher(algorithm, options.key);
		var start = cipher.start;
		cipher.start = function(iv, options) {
			var output = null;
			if (options instanceof forge.util.ByteBuffer) {
				output = options;
				options = {};
			}
			options = options || {};
			options.output = output;
			options.iv = iv;
			start.call(cipher, options);
		};
		return cipher;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/oids.js
var require_oids = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Object IDs for ASN.1.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2013 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	forge.pki = forge.pki || {};
	var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};
	function _IN(id, name) {
		oids[id] = name;
		oids[name] = id;
	}
	function _I_(id, name) {
		oids[id] = name;
	}
	_IN("1.2.840.113549.1.1.1", "rsaEncryption");
	_IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
	_IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
	_IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
	_IN("1.2.840.113549.1.1.8", "mgf1");
	_IN("1.2.840.113549.1.1.9", "pSpecified");
	_IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
	_IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
	_IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
	_IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
	_IN("1.3.101.112", "EdDSA25519");
	_IN("1.2.840.10040.4.3", "dsa-with-sha1");
	_IN("1.3.14.3.2.7", "desCBC");
	_IN("1.3.14.3.2.26", "sha1");
	_IN("1.3.14.3.2.29", "sha1WithRSASignature");
	_IN("2.16.840.1.101.3.4.2.1", "sha256");
	_IN("2.16.840.1.101.3.4.2.2", "sha384");
	_IN("2.16.840.1.101.3.4.2.3", "sha512");
	_IN("2.16.840.1.101.3.4.2.4", "sha224");
	_IN("2.16.840.1.101.3.4.2.5", "sha512-224");
	_IN("2.16.840.1.101.3.4.2.6", "sha512-256");
	_IN("1.2.840.113549.2.2", "md2");
	_IN("1.2.840.113549.2.5", "md5");
	_IN("1.2.840.113549.1.7.1", "data");
	_IN("1.2.840.113549.1.7.2", "signedData");
	_IN("1.2.840.113549.1.7.3", "envelopedData");
	_IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
	_IN("1.2.840.113549.1.7.5", "digestedData");
	_IN("1.2.840.113549.1.7.6", "encryptedData");
	_IN("1.2.840.113549.1.9.1", "emailAddress");
	_IN("1.2.840.113549.1.9.2", "unstructuredName");
	_IN("1.2.840.113549.1.9.3", "contentType");
	_IN("1.2.840.113549.1.9.4", "messageDigest");
	_IN("1.2.840.113549.1.9.5", "signingTime");
	_IN("1.2.840.113549.1.9.6", "counterSignature");
	_IN("1.2.840.113549.1.9.7", "challengePassword");
	_IN("1.2.840.113549.1.9.8", "unstructuredAddress");
	_IN("1.2.840.113549.1.9.14", "extensionRequest");
	_IN("1.2.840.113549.1.9.20", "friendlyName");
	_IN("1.2.840.113549.1.9.21", "localKeyId");
	_IN("1.2.840.113549.1.9.22.1", "x509Certificate");
	_IN("1.2.840.113549.1.12.10.1.1", "keyBag");
	_IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
	_IN("1.2.840.113549.1.12.10.1.3", "certBag");
	_IN("1.2.840.113549.1.12.10.1.4", "crlBag");
	_IN("1.2.840.113549.1.12.10.1.5", "secretBag");
	_IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
	_IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
	_IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
	_IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
	_IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
	_IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
	_IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
	_IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
	_IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
	_IN("1.2.840.113549.2.7", "hmacWithSHA1");
	_IN("1.2.840.113549.2.8", "hmacWithSHA224");
	_IN("1.2.840.113549.2.9", "hmacWithSHA256");
	_IN("1.2.840.113549.2.10", "hmacWithSHA384");
	_IN("1.2.840.113549.2.11", "hmacWithSHA512");
	_IN("1.2.840.113549.3.7", "des-EDE3-CBC");
	_IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
	_IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
	_IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
	_IN("2.5.4.3", "commonName");
	_IN("2.5.4.4", "surname");
	_IN("2.5.4.5", "serialNumber");
	_IN("2.5.4.6", "countryName");
	_IN("2.5.4.7", "localityName");
	_IN("2.5.4.8", "stateOrProvinceName");
	_IN("2.5.4.9", "streetAddress");
	_IN("2.5.4.10", "organizationName");
	_IN("2.5.4.11", "organizationalUnitName");
	_IN("2.5.4.12", "title");
	_IN("2.5.4.13", "description");
	_IN("2.5.4.15", "businessCategory");
	_IN("2.5.4.17", "postalCode");
	_IN("2.5.4.42", "givenName");
	_IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
	_IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
	_IN("2.16.840.1.113730.1.1", "nsCertType");
	_IN("2.16.840.1.113730.1.13", "nsComment");
	_I_("2.5.29.1", "authorityKeyIdentifier");
	_I_("2.5.29.2", "keyAttributes");
	_I_("2.5.29.3", "certificatePolicies");
	_I_("2.5.29.4", "keyUsageRestriction");
	_I_("2.5.29.5", "policyMapping");
	_I_("2.5.29.6", "subtreesConstraint");
	_I_("2.5.29.7", "subjectAltName");
	_I_("2.5.29.8", "issuerAltName");
	_I_("2.5.29.9", "subjectDirectoryAttributes");
	_I_("2.5.29.10", "basicConstraints");
	_I_("2.5.29.11", "nameConstraints");
	_I_("2.5.29.12", "policyConstraints");
	_I_("2.5.29.13", "basicConstraints");
	_IN("2.5.29.14", "subjectKeyIdentifier");
	_IN("2.5.29.15", "keyUsage");
	_I_("2.5.29.16", "privateKeyUsagePeriod");
	_IN("2.5.29.17", "subjectAltName");
	_IN("2.5.29.18", "issuerAltName");
	_IN("2.5.29.19", "basicConstraints");
	_I_("2.5.29.20", "cRLNumber");
	_I_("2.5.29.21", "cRLReason");
	_I_("2.5.29.22", "expirationDate");
	_I_("2.5.29.23", "instructionCode");
	_I_("2.5.29.24", "invalidityDate");
	_I_("2.5.29.25", "cRLDistributionPoints");
	_I_("2.5.29.26", "issuingDistributionPoint");
	_I_("2.5.29.27", "deltaCRLIndicator");
	_I_("2.5.29.28", "issuingDistributionPoint");
	_I_("2.5.29.29", "certificateIssuer");
	_I_("2.5.29.30", "nameConstraints");
	_IN("2.5.29.31", "cRLDistributionPoints");
	_IN("2.5.29.32", "certificatePolicies");
	_I_("2.5.29.33", "policyMappings");
	_I_("2.5.29.34", "policyConstraints");
	_IN("2.5.29.35", "authorityKeyIdentifier");
	_I_("2.5.29.36", "policyConstraints");
	_IN("2.5.29.37", "extKeyUsage");
	_I_("2.5.29.46", "freshestCRL");
	_I_("2.5.29.54", "inhibitAnyPolicy");
	_IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
	_IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
	_IN("1.3.6.1.5.5.7.3.1", "serverAuth");
	_IN("1.3.6.1.5.5.7.3.2", "clientAuth");
	_IN("1.3.6.1.5.5.7.3.3", "codeSigning");
	_IN("1.3.6.1.5.5.7.3.4", "emailProtection");
	_IN("1.3.6.1.5.5.7.3.8", "timeStamping");
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/asn1.js
var require_asn1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of Abstract Syntax Notation Number One.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2015 Digital Bazaar, Inc.
	*
	* An API for storing data using the Abstract Syntax Notation Number One
	* format using DER (Distinguished Encoding Rules) encoding. This encoding is
	* commonly used to store data for PKI, i.e. X.509 Certificates, and this
	* implementation exists for that purpose.
	*
	* Abstract Syntax Notation Number One (ASN.1) is used to define the abstract
	* syntax of information without restricting the way the information is encoded
	* for transmission. It provides a standard that allows for open systems
	* communication. ASN.1 defines the syntax of information data and a number of
	* simple data types as well as a notation for describing them and specifying
	* values for them.
	*
	* The RSA algorithm creates public and private keys that are often stored in
	* X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This
	* class provides the most basic functionality required to store and load DSA
	* keys that are encoded according to ASN.1.
	*
	* The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)
	* and DER (Distinguished Encoding Rules). DER is just a subset of BER that
	* has stricter requirements for how data must be encoded.
	*
	* Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)
	* and a byte array for the value of this ASN1 structure which may be data or a
	* list of ASN.1 structures.
	*
	* Each ASN.1 structure using BER is (Tag-Length-Value):
	*
	* | byte 0 | bytes X | bytes Y |
	* |--------|---------|----------
	* |  tag   | length  |  value  |
	*
	* ASN.1 allows for tags to be of "High-tag-number form" which allows a tag to
	* be two or more octets, but that is not supported by this class. A tag is
	* only 1 byte. Bits 1-5 give the tag number (ie the data type within a
	* particular 'class'), 6 indicates whether or not the ASN.1 value is
	* constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If
	* bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,
	* then the class is APPLICATION. If only bit 8 is set, then the class is
	* CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.
	* The tag numbers for the data types for the class UNIVERSAL are listed below:
	*
	* UNIVERSAL 0 Reserved for use by the encoding rules
	* UNIVERSAL 1 Boolean type
	* UNIVERSAL 2 Integer type
	* UNIVERSAL 3 Bitstring type
	* UNIVERSAL 4 Octetstring type
	* UNIVERSAL 5 Null type
	* UNIVERSAL 6 Object identifier type
	* UNIVERSAL 7 Object descriptor type
	* UNIVERSAL 8 External type and Instance-of type
	* UNIVERSAL 9 Real type
	* UNIVERSAL 10 Enumerated type
	* UNIVERSAL 11 Embedded-pdv type
	* UNIVERSAL 12 UTF8String type
	* UNIVERSAL 13 Relative object identifier type
	* UNIVERSAL 14-15 Reserved for future editions
	* UNIVERSAL 16 Sequence and Sequence-of types
	* UNIVERSAL 17 Set and Set-of types
	* UNIVERSAL 18-22, 25-30 Character string types
	* UNIVERSAL 23-24 Time types
	*
	* The length of an ASN.1 structure is specified after the tag identifier.
	* There is a definite form and an indefinite form. The indefinite form may
	* be used if the encoding is constructed and not all immediately available.
	* The indefinite form is encoded using a length byte with only the 8th bit
	* set. The end of the constructed object is marked using end-of-contents
	* octets (two zero bytes).
	*
	* The definite form looks like this:
	*
	* The length may take up 1 or more bytes, it depends on the length of the
	* value of the ASN.1 structure. DER encoding requires that if the ASN.1
	* structure has a value that has a length greater than 127, more than 1 byte
	* will be used to store its length, otherwise just one byte will be used.
	* This is strict.
	*
	* In the case that the length of the ASN.1 value is less than 127, 1 octet
	* (byte) is used to store the "short form" length. The 8th bit has a value of
	* 0 indicating the length is "short form" and not "long form" and bits 7-1
	* give the length of the data. (The 8th bit is the left-most, most significant
	* bit: also known as big endian or network format).
	*
	* In the case that the length of the ASN.1 value is greater than 127, 2 to
	* 127 octets (bytes) are used to store the "long form" length. The first
	* byte's 8th bit is set to 1 to indicate the length is "long form." Bits 7-1
	* give the number of additional octets. All following octets are in base 256
	* with the most significant digit first (typical big-endian binary unsigned
	* integer storage). So, for instance, if the length of a value was 257, the
	* first byte would be set to:
	*
	* 10000010 = 130 = 0x82.
	*
	* This indicates there are 2 octets (base 256) for the length. The second and
	* third bytes (the octets just mentioned) would store the length in base 256:
	*
	* octet 2: 00000001 = 1 * 256^1 = 256
	* octet 3: 00000001 = 1 * 256^0 = 1
	* total = 257
	*
	* The algorithm for converting a js integer value of 257 to base-256 is:
	*
	* var value = 257;
	* var bytes = [];
	* bytes[0] = (value >>> 8) & 0xFF; // most significant byte first
	* bytes[1] = value & 0xFF;        // least significant byte last
	*
	* On the ASN.1 UNIVERSAL Object Identifier (OID) type:
	*
	* An OID can be written like: "value1.value2.value3...valueN"
	*
	* The DER encoding rules:
	*
	* The first byte has the value 40 * value1 + value2.
	* The following bytes, if any, encode the remaining values. Each value is
	* encoded in base 128, most significant digit first (big endian), with as
	* few digits as possible, and the most significant bit of each byte set
	* to 1 except the last in each value's encoding. For example: Given the
	* OID "1.2.840.113549", its DER encoding is (remember each byte except the
	* last one in each encoding is OR'd with 0x80):
	*
	* byte 1: 40 * 1 + 2 = 42 = 0x2A.
	* bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648
	* bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D
	*
	* The final value is: 0x2A864886F70D.
	* The full OID (including ASN.1 tag and length of 6 bytes) is:
	* 0x06062A864886F70D
	*/
	var forge = require_forge();
	require_util();
	require_oids();
	var asn1 = module.exports = forge.asn1 = forge.asn1 || {};
	/**
	* ASN.1 classes.
	*/
	asn1.Class = {
		UNIVERSAL: 0,
		APPLICATION: 64,
		CONTEXT_SPECIFIC: 128,
		PRIVATE: 192
	};
	/**
	* ASN.1 types. Not all types are supported by this implementation, only
	* those necessary to implement a simple PKI are implemented.
	*/
	asn1.Type = {
		NONE: 0,
		BOOLEAN: 1,
		INTEGER: 2,
		BITSTRING: 3,
		OCTETSTRING: 4,
		NULL: 5,
		OID: 6,
		ODESC: 7,
		EXTERNAL: 8,
		REAL: 9,
		ENUMERATED: 10,
		EMBEDDED: 11,
		UTF8: 12,
		ROID: 13,
		SEQUENCE: 16,
		SET: 17,
		PRINTABLESTRING: 19,
		IA5STRING: 22,
		UTCTIME: 23,
		GENERALIZEDTIME: 24,
		BMPSTRING: 30
	};
	/**
	* Sets the default maximum recursion depth when parsing ASN.1 structures.
	*/
	asn1.maxDepth = 256;
	/**
	* Creates a new asn1 object.
	*
	* @param tagClass the tag class for the object.
	* @param type the data type (tag number) for the object.
	* @param constructed true if the asn1 object is in constructed form.
	* @param value the value for the object, if it is not constructed.
	* @param [options] the options to use:
	*          [bitStringContents] the plain BIT STRING content including padding
	*            byte.
	*
	* @return the asn1 object.
	*/
	asn1.create = function(tagClass, type, constructed, value, options) {
		if (forge.util.isArray(value)) {
			var tmp = [];
			for (var i = 0; i < value.length; ++i) if (value[i] !== void 0) tmp.push(value[i]);
			value = tmp;
		}
		var obj = {
			tagClass,
			type,
			constructed,
			composed: constructed || forge.util.isArray(value),
			value
		};
		if (options && "bitStringContents" in options) {
			obj.bitStringContents = options.bitStringContents;
			obj.original = asn1.copy(obj);
		}
		return obj;
	};
	/**
	* Copies an asn1 object.
	*
	* @param obj the asn1 object.
	* @param [options] copy options:
	*          [excludeBitStringContents] true to not copy bitStringContents
	*
	* @return the a copy of the asn1 object.
	*/
	asn1.copy = function(obj, options) {
		var copy;
		if (forge.util.isArray(obj)) {
			copy = [];
			for (var i = 0; i < obj.length; ++i) copy.push(asn1.copy(obj[i], options));
			return copy;
		}
		if (typeof obj === "string") return obj;
		copy = {
			tagClass: obj.tagClass,
			type: obj.type,
			constructed: obj.constructed,
			composed: obj.composed,
			value: asn1.copy(obj.value, options)
		};
		if (options && !options.excludeBitStringContents) copy.bitStringContents = obj.bitStringContents;
		return copy;
	};
	/**
	* Compares asn1 objects for equality.
	*
	* Note this function does not run in constant time.
	*
	* @param obj1 the first asn1 object.
	* @param obj2 the second asn1 object.
	* @param [options] compare options:
	*          [includeBitStringContents] true to compare bitStringContents
	*
	* @return true if the asn1 objects are equal.
	*/
	asn1.equals = function(obj1, obj2, options) {
		if (forge.util.isArray(obj1)) {
			if (!forge.util.isArray(obj2)) return false;
			if (obj1.length !== obj2.length) return false;
			for (var i = 0; i < obj1.length; ++i) if (!asn1.equals(obj1[i], obj2[i])) return false;
			return true;
		}
		if (typeof obj1 !== typeof obj2) return false;
		if (typeof obj1 === "string") return obj1 === obj2;
		var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
		if (options && options.includeBitStringContents) equal = equal && obj1.bitStringContents === obj2.bitStringContents;
		return equal;
	};
	/**
	* Gets the length of a BER-encoded ASN.1 value.
	*
	* In case the length is not specified, undefined is returned.
	*
	* @param b the BER-encoded ASN.1 byte buffer, starting with the first
	*          length byte.
	*
	* @return the length of the BER-encoded ASN.1 value or undefined.
	*/
	asn1.getBerValueLength = function(b) {
		var b2 = b.getByte();
		if (b2 === 128) return;
		var length;
		if (!(b2 & 128)) length = b2;
		else length = b.getInt((b2 & 127) << 3);
		return length;
	};
	/**
	* Check if the byte buffer has enough bytes. Throws an Error if not.
	*
	* @param bytes the byte buffer to parse from.
	* @param remaining the bytes remaining in the current parsing state.
	* @param n the number of bytes the buffer must have.
	*/
	function _checkBufferLength(bytes, remaining, n) {
		if (n > remaining) {
			var error = /* @__PURE__ */ new Error("Too few bytes to parse DER.");
			error.available = bytes.length();
			error.remaining = remaining;
			error.requested = n;
			throw error;
		}
	}
	/**
	* Gets the length of a BER-encoded ASN.1 value.
	*
	* In case the length is not specified, undefined is returned.
	*
	* @param bytes the byte buffer to parse from.
	* @param remaining the bytes remaining in the current parsing state.
	*
	* @return the length of the BER-encoded ASN.1 value or undefined.
	*/
	var _getValueLength = function(bytes, remaining) {
		var b2 = bytes.getByte();
		remaining--;
		if (b2 === 128) return;
		var length;
		if (!(b2 & 128)) length = b2;
		else {
			var longFormBytes = b2 & 127;
			_checkBufferLength(bytes, remaining, longFormBytes);
			length = bytes.getInt(longFormBytes << 3);
		}
		if (length < 0) throw new Error("Negative length: " + length);
		return length;
	};
	/**
	* Parses an asn1 object from a byte buffer in DER format.
	*
	* @param bytes the byte buffer to parse from.
	* @param [strict] true to be strict when checking value lengths, false to
	*          allow truncated values (default: true).
	* @param [options] object with options or boolean strict flag
	*          [strict] true to be strict when checking value lengths, false to
	*            allow truncated values (default: true).
	*          [parseAllBytes] true to ensure all bytes are parsed
	*            (default: true)
	*          [decodeBitStrings] true to attempt to decode the content of
	*            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
	*            without schema support to understand the data context this can
	*            erroneously decode values that happen to be valid ASN.1. This
	*            flag will be deprecated or removed as soon as schema support is
	*            available. (default: true)
	*          [maxDepth] override asn1.maxDepth recursion limit
	*            (default: asn1.maxDepth)
	*
	* @throws Will throw an error for various malformed input conditions.
	*
	* @return the parsed asn1 object.
	*/
	asn1.fromDer = function(bytes, options) {
		if (options === void 0) options = {
			strict: true,
			parseAllBytes: true,
			decodeBitStrings: true
		};
		if (typeof options === "boolean") options = {
			strict: options,
			parseAllBytes: true,
			decodeBitStrings: true
		};
		if (!("strict" in options)) options.strict = true;
		if (!("parseAllBytes" in options)) options.parseAllBytes = true;
		if (!("decodeBitStrings" in options)) options.decodeBitStrings = true;
		if (!("maxDepth" in options)) options.maxDepth = asn1.maxDepth;
		if (typeof bytes === "string") bytes = forge.util.createBuffer(bytes);
		var byteCount = bytes.length();
		var value = _fromDer(bytes, bytes.length(), 0, options);
		if (options.parseAllBytes && bytes.length() !== 0) {
			var error = /* @__PURE__ */ new Error("Unparsed DER bytes remain after ASN.1 parsing.");
			error.byteCount = byteCount;
			error.remaining = bytes.length();
			throw error;
		}
		return value;
	};
	/**
	* Internal function to parse an asn1 object from a byte buffer in DER format.
	*
	* @param bytes the byte buffer to parse from.
	* @param remaining the number of bytes remaining for this chunk.
	* @param depth the current parsing depth.
	* @param options object with same options as fromDer().
	*
	* @return the parsed asn1 object.
	*/
	function _fromDer(bytes, remaining, depth, options) {
		if (depth >= options.maxDepth) throw new Error("ASN.1 parsing error: Max depth exceeded.");
		var start;
		_checkBufferLength(bytes, remaining, 2);
		var b1 = bytes.getByte();
		remaining--;
		var tagClass = b1 & 192;
		var type = b1 & 31;
		start = bytes.length();
		var length = _getValueLength(bytes, remaining);
		remaining -= start - bytes.length();
		if (length !== void 0 && length > remaining) {
			if (options.strict) {
				var error = /* @__PURE__ */ new Error("Too few bytes to read ASN.1 value.");
				error.available = bytes.length();
				error.remaining = remaining;
				error.requested = length;
				throw error;
			}
			length = remaining;
		}
		var value;
		var bitStringContents;
		var constructed = (b1 & 32) === 32;
		if (constructed) {
			value = [];
			if (length === void 0) for (;;) {
				_checkBufferLength(bytes, remaining, 2);
				if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
					bytes.getBytes(2);
					remaining -= 2;
					break;
				}
				start = bytes.length();
				value.push(_fromDer(bytes, remaining, depth + 1, options));
				remaining -= start - bytes.length();
			}
			else while (length > 0) {
				start = bytes.length();
				value.push(_fromDer(bytes, length, depth + 1, options));
				remaining -= start - bytes.length();
				length -= start - bytes.length();
			}
		}
		if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) bitStringContents = bytes.bytes(length);
		if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length > 1) {
			var savedRead = bytes.read;
			var savedRemaining = remaining;
			var unused = 0;
			if (type === asn1.Type.BITSTRING) {
				_checkBufferLength(bytes, remaining, 1);
				unused = bytes.getByte();
				remaining--;
			}
			if (unused === 0) try {
				start = bytes.length();
				var composed = _fromDer(bytes, remaining, depth + 1, {
					strict: true,
					decodeBitStrings: true
				});
				var used = start - bytes.length();
				remaining -= used;
				if (type == asn1.Type.BITSTRING) used++;
				var tc = composed.tagClass;
				if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) value = [composed];
			} catch (ex) {}
			if (value === void 0) {
				bytes.read = savedRead;
				remaining = savedRemaining;
			}
		}
		if (value === void 0) {
			if (length === void 0) {
				if (options.strict) throw new Error("Non-constructed ASN.1 object of indefinite length.");
				length = remaining;
			}
			if (type === asn1.Type.BMPSTRING) {
				value = "";
				for (; length > 0; length -= 2) {
					_checkBufferLength(bytes, remaining, 2);
					value += String.fromCharCode(bytes.getInt16());
					remaining -= 2;
				}
			} else {
				value = bytes.getBytes(length);
				remaining -= length;
			}
		}
		var asn1Options = bitStringContents === void 0 ? null : { bitStringContents };
		return asn1.create(tagClass, type, constructed, value, asn1Options);
	}
	/**
	* Converts the given asn1 object to a buffer of bytes in DER format.
	*
	* @param asn1 the asn1 object to convert to bytes.
	*
	* @return the buffer of bytes.
	*/
	asn1.toDer = function(obj) {
		var bytes = forge.util.createBuffer();
		var b1 = obj.tagClass | obj.type;
		var value = forge.util.createBuffer();
		var useBitStringContents = false;
		if ("bitStringContents" in obj) {
			useBitStringContents = true;
			if (obj.original) useBitStringContents = asn1.equals(obj, obj.original);
		}
		if (useBitStringContents) value.putBytes(obj.bitStringContents);
		else if (obj.composed) {
			if (obj.constructed) b1 |= 32;
			else value.putByte(0);
			for (var i = 0; i < obj.value.length; ++i) if (obj.value[i] !== void 0) value.putBuffer(asn1.toDer(obj.value[i]));
		} else if (obj.type === asn1.Type.BMPSTRING) for (var i = 0; i < obj.value.length; ++i) value.putInt16(obj.value.charCodeAt(i));
		else if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) value.putBytes(obj.value.substr(1));
		else value.putBytes(obj.value);
		bytes.putByte(b1);
		if (value.length() <= 127) bytes.putByte(value.length() & 127);
		else {
			var len = value.length();
			var lenBytes = "";
			do {
				lenBytes += String.fromCharCode(len & 255);
				len = len >>> 8;
			} while (len > 0);
			bytes.putByte(lenBytes.length | 128);
			for (var i = lenBytes.length - 1; i >= 0; --i) bytes.putByte(lenBytes.charCodeAt(i));
		}
		bytes.putBuffer(value);
		return bytes;
	};
	/**
	* Converts an OID dot-separated string to a byte buffer. The byte buffer
	* contains only the DER-encoded value, not any tag or length bytes.
	*
	* @param oid the OID dot-separated string.
	*
	* @return the byte buffer.
	*/
	asn1.oidToDer = function(oid) {
		var values = oid.split(".");
		var bytes = forge.util.createBuffer();
		bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
		var last, valueBytes, value, b;
		for (var i = 2; i < values.length; ++i) {
			last = true;
			valueBytes = [];
			value = parseInt(values[i], 10);
			if (value > 4294967295) throw new Error("OID value too large; max is 32-bits.");
			do {
				b = value & 127;
				value = value >>> 7;
				if (!last) b |= 128;
				valueBytes.push(b);
				last = false;
			} while (value > 0);
			for (var n = valueBytes.length - 1; n >= 0; --n) bytes.putByte(valueBytes[n]);
		}
		return bytes;
	};
	/**
	* Converts a DER-encoded byte buffer to an OID dot-separated string. The
	* byte buffer should contain only the DER-encoded value, not any tag or
	* length bytes.
	*
	* @param bytes the byte buffer.
	*
	* @return the OID dot-separated string.
	*/
	asn1.derToOid = function(bytes) {
		var oid;
		if (typeof bytes === "string") bytes = forge.util.createBuffer(bytes);
		var b = bytes.getByte();
		oid = Math.floor(b / 40) + "." + b % 40;
		var value = 0;
		while (bytes.length() > 0) {
			if (value > 70368744177663) throw new Error("OID value too large; max is 53-bits.");
			b = bytes.getByte();
			value = value * 128;
			if (b & 128) value += b & 127;
			else {
				oid += "." + (value + b);
				value = 0;
			}
		}
		return oid;
	};
	/**
	* Converts a UTCTime value to a date.
	*
	* Note: GeneralizedTime has 4 digits for the year and is used for X.509
	* dates past 2049. Parsing that structure hasn't been implemented yet.
	*
	* @param utc the UTCTime value to convert.
	*
	* @return the date.
	*/
	asn1.utcTimeToDate = function(utc) {
		var date = /* @__PURE__ */ new Date();
		var year = parseInt(utc.substr(0, 2), 10);
		year = year >= 50 ? 1900 + year : 2e3 + year;
		var MM = parseInt(utc.substr(2, 2), 10) - 1;
		var DD = parseInt(utc.substr(4, 2), 10);
		var hh = parseInt(utc.substr(6, 2), 10);
		var mm = parseInt(utc.substr(8, 2), 10);
		var ss = 0;
		if (utc.length > 11) {
			var c = utc.charAt(10);
			var end = 10;
			if (c !== "+" && c !== "-") {
				ss = parseInt(utc.substr(10, 2), 10);
				end += 2;
			}
		}
		date.setUTCFullYear(year, MM, DD);
		date.setUTCHours(hh, mm, ss, 0);
		if (end) {
			c = utc.charAt(end);
			if (c === "+" || c === "-") {
				var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
				var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
				var offset = hhoffset * 60 + mmoffset;
				offset *= 6e4;
				if (c === "+") date.setTime(+date - offset);
				else date.setTime(+date + offset);
			}
		}
		return date;
	};
	/**
	* Converts a GeneralizedTime value to a date.
	*
	* @param gentime the GeneralizedTime value to convert.
	*
	* @return the date.
	*/
	asn1.generalizedTimeToDate = function(gentime) {
		var date = /* @__PURE__ */ new Date();
		var YYYY = parseInt(gentime.substr(0, 4), 10);
		var MM = parseInt(gentime.substr(4, 2), 10) - 1;
		var DD = parseInt(gentime.substr(6, 2), 10);
		var hh = parseInt(gentime.substr(8, 2), 10);
		var mm = parseInt(gentime.substr(10, 2), 10);
		var ss = parseInt(gentime.substr(12, 2), 10);
		var fff = 0;
		var offset = 0;
		var isUTC = false;
		if (gentime.charAt(gentime.length - 1) === "Z") isUTC = true;
		var end = gentime.length - 5, c = gentime.charAt(end);
		if (c === "+" || c === "-") {
			var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
			var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
			offset = hhoffset * 60 + mmoffset;
			offset *= 6e4;
			if (c === "+") offset *= -1;
			isUTC = true;
		}
		if (gentime.charAt(14) === ".") fff = parseFloat(gentime.substr(14), 10) * 1e3;
		if (isUTC) {
			date.setUTCFullYear(YYYY, MM, DD);
			date.setUTCHours(hh, mm, ss, fff);
			date.setTime(+date + offset);
		} else {
			date.setFullYear(YYYY, MM, DD);
			date.setHours(hh, mm, ss, fff);
		}
		return date;
	};
	/**
	* Converts a date to a UTCTime value.
	*
	* Note: GeneralizedTime has 4 digits for the year and is used for X.509
	* dates past 2049. Converting to a GeneralizedTime hasn't been
	* implemented yet.
	*
	* @param date the date to convert.
	*
	* @return the UTCTime value.
	*/
	asn1.dateToUtcTime = function(date) {
		if (typeof date === "string") return date;
		var rval = "";
		var format = [];
		format.push(("" + date.getUTCFullYear()).substr(2));
		format.push("" + (date.getUTCMonth() + 1));
		format.push("" + date.getUTCDate());
		format.push("" + date.getUTCHours());
		format.push("" + date.getUTCMinutes());
		format.push("" + date.getUTCSeconds());
		for (var i = 0; i < format.length; ++i) {
			if (format[i].length < 2) rval += "0";
			rval += format[i];
		}
		rval += "Z";
		return rval;
	};
	/**
	* Converts a date to a GeneralizedTime value.
	*
	* @param date the date to convert.
	*
	* @return the GeneralizedTime value as a string.
	*/
	asn1.dateToGeneralizedTime = function(date) {
		if (typeof date === "string") return date;
		var rval = "";
		var format = [];
		format.push("" + date.getUTCFullYear());
		format.push("" + (date.getUTCMonth() + 1));
		format.push("" + date.getUTCDate());
		format.push("" + date.getUTCHours());
		format.push("" + date.getUTCMinutes());
		format.push("" + date.getUTCSeconds());
		for (var i = 0; i < format.length; ++i) {
			if (format[i].length < 2) rval += "0";
			rval += format[i];
		}
		rval += "Z";
		return rval;
	};
	/**
	* Converts a javascript integer to a DER-encoded byte buffer to be used
	* as the value for an INTEGER type.
	*
	* @param x the integer.
	*
	* @return the byte buffer.
	*/
	asn1.integerToDer = function(x) {
		var rval = forge.util.createBuffer();
		if (x >= -128 && x < 128) return rval.putSignedInt(x, 8);
		if (x >= -32768 && x < 32768) return rval.putSignedInt(x, 16);
		if (x >= -8388608 && x < 8388608) return rval.putSignedInt(x, 24);
		if (x >= -2147483648 && x < 2147483648) return rval.putSignedInt(x, 32);
		var error = /* @__PURE__ */ new Error("Integer too large; max is 32-bits.");
		error.integer = x;
		throw error;
	};
	/**
	* Converts a DER-encoded byte buffer to a javascript integer. This is
	* typically used to decode the value of an INTEGER type.
	*
	* @param bytes the byte buffer.
	*
	* @return the integer.
	*/
	asn1.derToInteger = function(bytes) {
		if (typeof bytes === "string") bytes = forge.util.createBuffer(bytes);
		var n = bytes.length() * 8;
		if (n > 32) throw new Error("Integer too large; max is 32-bits.");
		return bytes.getSignedInt(n);
	};
	/**
	* Validates that the given ASN.1 object is at least a super set of the
	* given ASN.1 structure. Only tag classes and types are checked. An
	* optional map may also be provided to capture ASN.1 values while the
	* structure is checked.
	*
	* To capture an ASN.1 value, set an object in the validator's 'capture'
	* parameter to the key to use in the capture map. To capture the full
	* ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including
	* the leading unused bits counter byte, specify 'captureBitStringContents'.
	* To capture BIT STRING bytes, without the leading unused bits counter byte,
	* specify 'captureBitStringValue'.
	*
	* Objects in the validator may set a field 'optional' to true to indicate
	* that it isn't necessary to pass validation.
	*
	* @param obj the ASN.1 object to validate.
	* @param v the ASN.1 structure validator.
	* @param capture an optional map to capture values in.
	* @param errors an optional array for storing validation errors.
	*
	* @return true on success, false on failure.
	*/
	asn1.validate = function(obj, v, capture, errors) {
		var rval = false;
		if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
			if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
				rval = true;
				if (v.value && forge.util.isArray(v.value)) {
					var j = 0;
					for (var i = 0; rval && i < v.value.length; ++i) {
						var schemaItem = v.value[i];
						rval = !!schemaItem.optional;
						var objChild = obj.value[j];
						if (!objChild) {
							if (!schemaItem.optional) {
								rval = false;
								if (errors) errors.push("[" + v.name + "] Missing required element. Expected tag class \"" + schemaItem.tagClass + "\", type \"" + schemaItem.type + "\"");
							}
							continue;
						}
						if (typeof schemaItem.tagClass !== "undefined" && typeof schemaItem.type !== "undefined" && (objChild.tagClass !== schemaItem.tagClass || objChild.type !== schemaItem.type)) if (schemaItem.optional) {
							rval = true;
							continue;
						} else {
							rval = false;
							if (errors) errors.push("[" + v.name + "] Tag mismatch. Expected (" + schemaItem.tagClass + "," + schemaItem.type + "), got (" + objChild.tagClass + "," + objChild.type + ")");
							break;
						}
						if (asn1.validate(objChild, schemaItem, capture, errors)) {
							++j;
							rval = true;
						} else if (schemaItem.optional) rval = true;
						else {
							rval = false;
							break;
						}
					}
				}
				if (rval && capture) {
					if (v.capture) capture[v.capture] = obj.value;
					if (v.captureAsn1) capture[v.captureAsn1] = obj;
					if (v.captureBitStringContents && "bitStringContents" in obj) capture[v.captureBitStringContents] = obj.bitStringContents;
					if (v.captureBitStringValue && "bitStringContents" in obj) if (obj.bitStringContents.length < 2) capture[v.captureBitStringValue] = "";
					else {
						if (obj.bitStringContents.charCodeAt(0) !== 0) throw new Error("captureBitStringValue only supported for zero unused bits");
						capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
					}
				}
			} else if (errors) errors.push("[" + v.name + "] Expected constructed \"" + v.constructed + "\", got \"" + obj.constructed + "\"");
		} else if (errors) {
			if (obj.tagClass !== v.tagClass) errors.push("[" + v.name + "] Expected tag class \"" + v.tagClass + "\", got \"" + obj.tagClass + "\"");
			if (obj.type !== v.type) errors.push("[" + v.name + "] Expected type \"" + v.type + "\", got \"" + obj.type + "\"");
		}
		return rval;
	};
	var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
	/**
	* Pretty prints an ASN.1 object to a string.
	*
	* @param obj the object to write out.
	* @param level the level in the tree.
	* @param indentation the indentation to use.
	*
	* @return the string.
	*/
	asn1.prettyPrint = function(obj, level, indentation) {
		var rval = "";
		level = level || 0;
		indentation = indentation || 2;
		if (level > 0) rval += "\n";
		var indent = "";
		for (var i = 0; i < level * indentation; ++i) indent += " ";
		rval += indent + "Tag: ";
		switch (obj.tagClass) {
			case asn1.Class.UNIVERSAL:
				rval += "Universal:";
				break;
			case asn1.Class.APPLICATION:
				rval += "Application:";
				break;
			case asn1.Class.CONTEXT_SPECIFIC:
				rval += "Context-Specific:";
				break;
			case asn1.Class.PRIVATE:
				rval += "Private:";
				break;
		}
		if (obj.tagClass === asn1.Class.UNIVERSAL) {
			rval += obj.type;
			switch (obj.type) {
				case asn1.Type.NONE:
					rval += " (None)";
					break;
				case asn1.Type.BOOLEAN:
					rval += " (Boolean)";
					break;
				case asn1.Type.INTEGER:
					rval += " (Integer)";
					break;
				case asn1.Type.BITSTRING:
					rval += " (Bit string)";
					break;
				case asn1.Type.OCTETSTRING:
					rval += " (Octet string)";
					break;
				case asn1.Type.NULL:
					rval += " (Null)";
					break;
				case asn1.Type.OID:
					rval += " (Object Identifier)";
					break;
				case asn1.Type.ODESC:
					rval += " (Object Descriptor)";
					break;
				case asn1.Type.EXTERNAL:
					rval += " (External or Instance of)";
					break;
				case asn1.Type.REAL:
					rval += " (Real)";
					break;
				case asn1.Type.ENUMERATED:
					rval += " (Enumerated)";
					break;
				case asn1.Type.EMBEDDED:
					rval += " (Embedded PDV)";
					break;
				case asn1.Type.UTF8:
					rval += " (UTF8)";
					break;
				case asn1.Type.ROID:
					rval += " (Relative Object Identifier)";
					break;
				case asn1.Type.SEQUENCE:
					rval += " (Sequence)";
					break;
				case asn1.Type.SET:
					rval += " (Set)";
					break;
				case asn1.Type.PRINTABLESTRING:
					rval += " (Printable String)";
					break;
				case asn1.Type.IA5String:
					rval += " (IA5String (ASCII))";
					break;
				case asn1.Type.UTCTIME:
					rval += " (UTC time)";
					break;
				case asn1.Type.GENERALIZEDTIME:
					rval += " (Generalized time)";
					break;
				case asn1.Type.BMPSTRING:
					rval += " (BMP String)";
					break;
			}
		} else rval += obj.type;
		rval += "\n";
		rval += indent + "Constructed: " + obj.constructed + "\n";
		if (obj.composed) {
			var subvalues = 0;
			var sub = "";
			for (var i = 0; i < obj.value.length; ++i) if (obj.value[i] !== void 0) {
				subvalues += 1;
				sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
				if (i + 1 < obj.value.length) sub += ",";
			}
			rval += indent + "Sub values: " + subvalues + sub;
		} else {
			rval += indent + "Value: ";
			if (obj.type === asn1.Type.OID) {
				var oid = asn1.derToOid(obj.value);
				rval += oid;
				if (forge.pki && forge.pki.oids) {
					if (oid in forge.pki.oids) rval += " (" + forge.pki.oids[oid] + ") ";
				}
			}
			if (obj.type === asn1.Type.INTEGER) try {
				rval += asn1.derToInteger(obj.value);
			} catch (ex) {
				rval += "0x" + forge.util.bytesToHex(obj.value);
			}
			else if (obj.type === asn1.Type.BITSTRING) {
				if (obj.value.length > 1) rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
				else rval += "(none)";
				if (obj.value.length > 0) {
					var unused = obj.value.charCodeAt(0);
					if (unused == 1) rval += " (1 unused bit shown)";
					else if (unused > 1) rval += " (" + unused + " unused bits shown)";
				}
			} else if (obj.type === asn1.Type.OCTETSTRING) {
				if (!_nonLatinRegex.test(obj.value)) rval += "(" + obj.value + ") ";
				rval += "0x" + forge.util.bytesToHex(obj.value);
			} else if (obj.type === asn1.Type.UTF8) try {
				rval += forge.util.decodeUtf8(obj.value);
			} catch (e) {
				if (e.message === "URI malformed") rval += "0x" + forge.util.bytesToHex(obj.value) + " (malformed UTF8)";
				else throw e;
			}
			else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) rval += obj.value;
			else if (_nonLatinRegex.test(obj.value)) rval += "0x" + forge.util.bytesToHex(obj.value);
			else if (obj.value.length === 0) rval += "[null]";
			else rval += obj.value;
		}
		return rval;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/md.js
var require_md = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for Forge message digests.
	*
	* @author Dave Longley
	*
	* Copyright 2011-2017 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	module.exports = forge.md = forge.md || {};
	forge.md.algorithms = forge.md.algorithms || {};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/hmac.js
var require_hmac = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Hash-based Message Authentication Code implementation. Requires a message
	* digest object that can be obtained, for example, from forge.md.sha1 or
	* forge.md.md5.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var hmac = module.exports = forge.hmac = forge.hmac || {};
	/**
	* Creates an HMAC object that uses the given message digest object.
	*
	* @return an HMAC object.
	*/
	hmac.create = function() {
		var _key = null;
		var _md = null;
		var _ipadding = null;
		var _opadding = null;
		var ctx = {};
		/**
		* Starts or restarts the HMAC with the given key and message digest.
		*
		* @param md the message digest to use, null to reuse the previous one,
		*           a string to use builtin 'sha1', 'md5', 'sha256'.
		* @param key the key to use as a string, array of bytes, byte buffer,
		*           or null to reuse the previous key.
		*/
		ctx.start = function(md, key) {
			if (md !== null) if (typeof md === "string") {
				md = md.toLowerCase();
				if (md in forge.md.algorithms) _md = forge.md.algorithms[md].create();
				else throw new Error("Unknown hash algorithm \"" + md + "\"");
			} else _md = md;
			if (key === null) key = _key;
			else {
				if (typeof key === "string") key = forge.util.createBuffer(key);
				else if (forge.util.isArray(key)) {
					var tmp = key;
					key = forge.util.createBuffer();
					for (var i = 0; i < tmp.length; ++i) key.putByte(tmp[i]);
				}
				var keylen = key.length();
				if (keylen > _md.blockLength) {
					_md.start();
					_md.update(key.bytes());
					key = _md.digest();
				}
				_ipadding = forge.util.createBuffer();
				_opadding = forge.util.createBuffer();
				keylen = key.length();
				for (var i = 0; i < keylen; ++i) {
					var tmp = key.at(i);
					_ipadding.putByte(54 ^ tmp);
					_opadding.putByte(92 ^ tmp);
				}
				if (keylen < _md.blockLength) {
					var tmp = _md.blockLength - keylen;
					for (var i = 0; i < tmp; ++i) {
						_ipadding.putByte(54);
						_opadding.putByte(92);
					}
				}
				_key = key;
				_ipadding = _ipadding.bytes();
				_opadding = _opadding.bytes();
			}
			_md.start();
			_md.update(_ipadding);
		};
		/**
		* Updates the HMAC with the given message bytes.
		*
		* @param bytes the bytes to update with.
		*/
		ctx.update = function(bytes) {
			_md.update(bytes);
		};
		/**
		* Produces the Message Authentication Code (MAC).
		*
		* @return a byte buffer containing the digest value.
		*/
		ctx.getMac = function() {
			var inner = _md.digest().bytes();
			_md.start();
			_md.update(_opadding);
			_md.update(inner);
			return _md.digest();
		};
		ctx.digest = ctx.getMac;
		return ctx;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/md5.js
var require_md5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Message Digest Algorithm 5 with 128-bit digest (MD5) implementation.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var md5 = module.exports = forge.md5 = forge.md5 || {};
	forge.md.md5 = forge.md.algorithms.md5 = md5;
	/**
	* Creates an MD5 message digest object.
	*
	* @return a message digest object.
	*/
	md5.create = function() {
		if (!_initialized) _init();
		var _state = null;
		var _input = forge.util.createBuffer();
		var _w = new Array(16);
		var md = {
			algorithm: "md5",
			blockLength: 64,
			digestLength: 16,
			messageLength: 0,
			fullMessageLength: null,
			messageLengthSize: 8
		};
		/**
		* Starts the digest.
		*
		* @return this digest object.
		*/
		md.start = function() {
			md.messageLength = 0;
			md.fullMessageLength = md.messageLength64 = [];
			var int32s = md.messageLengthSize / 4;
			for (var i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
			_input = forge.util.createBuffer();
			_state = {
				h0: 1732584193,
				h1: 4023233417,
				h2: 2562383102,
				h3: 271733878
			};
			return md;
		};
		md.start();
		/**
		* Updates the digest with the given message input. The given input can
		* treated as raw input (no encoding will be applied) or an encoding of
		* 'utf8' maybe given to encode the input using UTF-8.
		*
		* @param msg the message input to update with.
		* @param encoding the encoding to use (default: 'raw', other: 'utf8').
		*
		* @return this digest object.
		*/
		md.update = function(msg, encoding) {
			if (encoding === "utf8") msg = forge.util.encodeUtf8(msg);
			var len = msg.length;
			md.messageLength += len;
			len = [len / 4294967296 >>> 0, len >>> 0];
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				md.fullMessageLength[i] += len[1];
				len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
				md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
				len[0] = len[1] / 4294967296 >>> 0;
			}
			_input.putBytes(msg);
			_update(_state, _w, _input);
			if (_input.read > 2048 || _input.length() === 0) _input.compact();
			return md;
		};
		/**
		* Produces the digest.
		*
		* @return a byte buffer containing the digest value.
		*/
		md.digest = function() {
			var finalBlock = forge.util.createBuffer();
			finalBlock.putBytes(_input.bytes());
			var overflow = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize & md.blockLength - 1;
			finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
			var bits, carry = 0;
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				bits = md.fullMessageLength[i] * 8 + carry;
				carry = bits / 4294967296 >>> 0;
				finalBlock.putInt32Le(bits >>> 0);
			}
			var s2 = {
				h0: _state.h0,
				h1: _state.h1,
				h2: _state.h2,
				h3: _state.h3
			};
			_update(s2, _w, finalBlock);
			var rval = forge.util.createBuffer();
			rval.putInt32Le(s2.h0);
			rval.putInt32Le(s2.h1);
			rval.putInt32Le(s2.h2);
			rval.putInt32Le(s2.h3);
			return rval;
		};
		return md;
	};
	var _padding = null;
	var _g = null;
	var _r = null;
	var _k = null;
	var _initialized = false;
	/**
	* Initializes the constant tables.
	*/
	function _init() {
		_padding = String.fromCharCode(128);
		_padding += forge.util.fillString(String.fromCharCode(0), 64);
		_g = [
			0,
			1,
			2,
			3,
			4,
			5,
			6,
			7,
			8,
			9,
			10,
			11,
			12,
			13,
			14,
			15,
			1,
			6,
			11,
			0,
			5,
			10,
			15,
			4,
			9,
			14,
			3,
			8,
			13,
			2,
			7,
			12,
			5,
			8,
			11,
			14,
			1,
			4,
			7,
			10,
			13,
			0,
			3,
			6,
			9,
			12,
			15,
			2,
			0,
			7,
			14,
			5,
			12,
			3,
			10,
			1,
			8,
			15,
			6,
			13,
			4,
			11,
			2,
			9
		];
		_r = [
			7,
			12,
			17,
			22,
			7,
			12,
			17,
			22,
			7,
			12,
			17,
			22,
			7,
			12,
			17,
			22,
			5,
			9,
			14,
			20,
			5,
			9,
			14,
			20,
			5,
			9,
			14,
			20,
			5,
			9,
			14,
			20,
			4,
			11,
			16,
			23,
			4,
			11,
			16,
			23,
			4,
			11,
			16,
			23,
			4,
			11,
			16,
			23,
			6,
			10,
			15,
			21,
			6,
			10,
			15,
			21,
			6,
			10,
			15,
			21,
			6,
			10,
			15,
			21
		];
		_k = new Array(64);
		for (var i = 0; i < 64; ++i) _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
		_initialized = true;
	}
	/**
	* Updates an MD5 state with the given byte buffer.
	*
	* @param s the MD5 state to update.
	* @param w the array to use to store words.
	* @param bytes the byte buffer to update with.
	*/
	function _update(s, w, bytes) {
		var t, a, b, c, d, f, r, i;
		var len = bytes.length();
		while (len >= 64) {
			a = s.h0;
			b = s.h1;
			c = s.h2;
			d = s.h3;
			for (i = 0; i < 16; ++i) {
				w[i] = bytes.getInt32Le();
				f = d ^ b & (c ^ d);
				t = a + f + _k[i] + w[i];
				r = _r[i];
				a = d;
				d = c;
				c = b;
				b += t << r | t >>> 32 - r;
			}
			for (; i < 32; ++i) {
				f = c ^ d & (b ^ c);
				t = a + f + _k[i] + w[_g[i]];
				r = _r[i];
				a = d;
				d = c;
				c = b;
				b += t << r | t >>> 32 - r;
			}
			for (; i < 48; ++i) {
				f = b ^ c ^ d;
				t = a + f + _k[i] + w[_g[i]];
				r = _r[i];
				a = d;
				d = c;
				c = b;
				b += t << r | t >>> 32 - r;
			}
			for (; i < 64; ++i) {
				f = c ^ (b | ~d);
				t = a + f + _k[i] + w[_g[i]];
				r = _r[i];
				a = d;
				d = c;
				c = b;
				b += t << r | t >>> 32 - r;
			}
			s.h0 = s.h0 + a | 0;
			s.h1 = s.h1 + b | 0;
			s.h2 = s.h2 + c | 0;
			s.h3 = s.h3 + d | 0;
			len -= 64;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/pem.js
var require_pem = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
	*
	* See: RFC 1421.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2013-2014 Digital Bazaar, Inc.
	*
	* A Forge PEM object has the following fields:
	*
	* type: identifies the type of message (eg: "RSA PRIVATE KEY").
	*
	* procType: identifies the type of processing performed on the message,
	*   it has two subfields: version and type, eg: 4,ENCRYPTED.
	*
	* contentDomain: identifies the type of content in the message, typically
	*   only uses the value: "RFC822".
	*
	* dekInfo: identifies the message encryption algorithm and mode and includes
	*   any parameters for the algorithm, it has two subfields: algorithm and
	*   parameters, eg: DES-CBC,F8143EDE5960C597.
	*
	* headers: contains all other PEM encapsulated headers -- where order is
	*   significant (for pairing data like recipient ID + key info).
	*
	* body: the binary-encoded body.
	*/
	var forge = require_forge();
	require_util();
	var pem = module.exports = forge.pem = forge.pem || {};
	/**
	* Encodes (serializes) the given PEM object.
	*
	* @param msg the PEM message object to encode.
	* @param options the options to use:
	*          maxline the maximum characters per line for the body, (default: 64).
	*
	* @return the PEM-formatted string.
	*/
	pem.encode = function(msg, options) {
		options = options || {};
		var rval = "-----BEGIN " + msg.type + "-----\r\n";
		var header;
		if (msg.procType) {
			header = {
				name: "Proc-Type",
				values: [String(msg.procType.version), msg.procType.type]
			};
			rval += foldHeader(header);
		}
		if (msg.contentDomain) {
			header = {
				name: "Content-Domain",
				values: [msg.contentDomain]
			};
			rval += foldHeader(header);
		}
		if (msg.dekInfo) {
			header = {
				name: "DEK-Info",
				values: [msg.dekInfo.algorithm]
			};
			if (msg.dekInfo.parameters) header.values.push(msg.dekInfo.parameters);
			rval += foldHeader(header);
		}
		if (msg.headers) for (var i = 0; i < msg.headers.length; ++i) rval += foldHeader(msg.headers[i]);
		if (msg.procType) rval += "\r\n";
		rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
		rval += "-----END " + msg.type + "-----\r\n";
		return rval;
	};
	/**
	* Decodes (deserializes) all PEM messages found in the given string.
	*
	* @param str the PEM-formatted string to decode.
	*
	* @return the PEM message objects in an array.
	*/
	pem.decode = function(str) {
		var rval = [];
		var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
		var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
		var rCRLF = /\r?\n/;
		var match;
		while (true) {
			match = rMessage.exec(str);
			if (!match) break;
			var type = match[1];
			if (type === "NEW CERTIFICATE REQUEST") type = "CERTIFICATE REQUEST";
			var msg = {
				type,
				procType: null,
				contentDomain: null,
				dekInfo: null,
				headers: [],
				body: forge.util.decode64(match[3])
			};
			rval.push(msg);
			if (!match[2]) continue;
			var lines = match[2].split(rCRLF);
			var li = 0;
			while (match && li < lines.length) {
				var line = lines[li].replace(/\s+$/, "");
				for (var nl = li + 1; nl < lines.length; ++nl) {
					var next = lines[nl];
					if (!/\s/.test(next[0])) break;
					line += next;
					li = nl;
				}
				match = line.match(rHeader);
				if (match) {
					var header = {
						name: match[1],
						values: []
					};
					var values = match[2].split(",");
					for (var vi = 0; vi < values.length; ++vi) header.values.push(ltrim(values[vi]));
					if (!msg.procType) {
						if (header.name !== "Proc-Type") throw new Error("Invalid PEM formatted message. The first encapsulated header must be \"Proc-Type\".");
						else if (header.values.length !== 2) throw new Error("Invalid PEM formatted message. The \"Proc-Type\" header must have two subfields.");
						msg.procType = {
							version: values[0],
							type: values[1]
						};
					} else if (!msg.contentDomain && header.name === "Content-Domain") msg.contentDomain = values[0] || "";
					else if (!msg.dekInfo && header.name === "DEK-Info") {
						if (header.values.length === 0) throw new Error("Invalid PEM formatted message. The \"DEK-Info\" header must have at least one subfield.");
						msg.dekInfo = {
							algorithm: values[0],
							parameters: values[1] || null
						};
					} else msg.headers.push(header);
				}
				++li;
			}
			if (msg.procType === "ENCRYPTED" && !msg.dekInfo) throw new Error("Invalid PEM formatted message. The \"DEK-Info\" header must be present if \"Proc-Type\" is \"ENCRYPTED\".");
		}
		if (rval.length === 0) throw new Error("Invalid PEM formatted message.");
		return rval;
	};
	function foldHeader(header) {
		var rval = header.name + ": ";
		var values = [];
		var insertSpace = function(match, $1) {
			return " " + $1;
		};
		for (var i = 0; i < header.values.length; ++i) values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
		rval += values.join(",") + "\r\n";
		var length = 0;
		var candidate = -1;
		for (var i = 0; i < rval.length; ++i, ++length) if (length > 65 && candidate !== -1) {
			var insert = rval[candidate];
			if (insert === ",") {
				++candidate;
				rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
			} else rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
			length = i - candidate - 1;
			candidate = -1;
			++i;
		} else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") candidate = i;
		return rval;
	}
	function ltrim(str) {
		return str.replace(/^\s+/, "");
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/des.js
var require_des = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* DES (Data Encryption Standard) implementation.
	*
	* This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.
	* It is based on the BSD-licensed implementation by Paul Tero:
	*
	* Paul Tero, July 2001
	* http://www.tero.co.uk/des/
	*
	* Optimised for performance with large blocks by
	* Michael Hayworth, November 2001
	* http://www.netdealing.com
	*
	* THIS SOFTWARE IS PROVIDED "AS IS" AND
	* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	* ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
	* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
	* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	* SUCH DAMAGE.
	*
	* @author Stefan Siegl
	* @author Dave Longley
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	* Copyright (c) 2012-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_cipher();
	require_cipherModes();
	require_util();
	module.exports = forge.des = forge.des || {};
	/**
	* Deprecated. Instead, use:
	*
	* var cipher = forge.cipher.createCipher('DES-<mode>', key);
	* cipher.start({iv: iv});
	*
	* Creates an DES cipher object to encrypt data using the given symmetric key.
	* The output will be stored in the 'output' member of the returned cipher.
	*
	* The key and iv may be given as binary-encoded strings of bytes or
	* byte buffers.
	*
	* @param key the symmetric key to use (64 or 192 bits).
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	* @param mode the cipher mode to use (default: 'CBC' if IV is
	*          given, 'ECB' if null).
	*
	* @return the cipher.
	*/
	forge.des.startEncrypting = function(key, iv, output, mode) {
		var cipher = _createCipher({
			key,
			output,
			decrypt: false,
			mode: mode || (iv === null ? "ECB" : "CBC")
		});
		cipher.start(iv);
		return cipher;
	};
	/**
	* Deprecated. Instead, use:
	*
	* var cipher = forge.cipher.createCipher('DES-<mode>', key);
	*
	* Creates an DES cipher object to encrypt data using the given symmetric key.
	*
	* The key may be given as a binary-encoded string of bytes or a byte buffer.
	*
	* @param key the symmetric key to use (64 or 192 bits).
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.des.createEncryptionCipher = function(key, mode) {
		return _createCipher({
			key,
			output: null,
			decrypt: false,
			mode
		});
	};
	/**
	* Deprecated. Instead, use:
	*
	* var decipher = forge.cipher.createDecipher('DES-<mode>', key);
	* decipher.start({iv: iv});
	*
	* Creates an DES cipher object to decrypt data using the given symmetric key.
	* The output will be stored in the 'output' member of the returned cipher.
	*
	* The key and iv may be given as binary-encoded strings of bytes or
	* byte buffers.
	*
	* @param key the symmetric key to use (64 or 192 bits).
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	* @param mode the cipher mode to use (default: 'CBC' if IV is
	*          given, 'ECB' if null).
	*
	* @return the cipher.
	*/
	forge.des.startDecrypting = function(key, iv, output, mode) {
		var cipher = _createCipher({
			key,
			output,
			decrypt: true,
			mode: mode || (iv === null ? "ECB" : "CBC")
		});
		cipher.start(iv);
		return cipher;
	};
	/**
	* Deprecated. Instead, use:
	*
	* var decipher = forge.cipher.createDecipher('DES-<mode>', key);
	*
	* Creates an DES cipher object to decrypt data using the given symmetric key.
	*
	* The key may be given as a binary-encoded string of bytes or a byte buffer.
	*
	* @param key the symmetric key to use (64 or 192 bits).
	* @param mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	forge.des.createDecryptionCipher = function(key, mode) {
		return _createCipher({
			key,
			output: null,
			decrypt: true,
			mode
		});
	};
	/**
	* Creates a new DES cipher algorithm object.
	*
	* @param name the name of the algorithm.
	* @param mode the mode factory function.
	*
	* @return the DES algorithm object.
	*/
	forge.des.Algorithm = function(name, mode) {
		var self = this;
		self.name = name;
		self.mode = new mode({
			blockSize: 8,
			cipher: {
				encrypt: function(inBlock, outBlock) {
					return _updateBlock(self._keys, inBlock, outBlock, false);
				},
				decrypt: function(inBlock, outBlock) {
					return _updateBlock(self._keys, inBlock, outBlock, true);
				}
			}
		});
		self._init = false;
	};
	/**
	* Initializes this DES algorithm by expanding its key.
	*
	* @param options the options to use.
	*          key the key to use with this algorithm.
	*          decrypt true if the algorithm should be initialized for decryption,
	*            false for encryption.
	*/
	forge.des.Algorithm.prototype.initialize = function(options) {
		if (this._init) return;
		var key = forge.util.createBuffer(options.key);
		if (this.name.indexOf("3DES") === 0) {
			if (key.length() !== 24) throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
		}
		this._keys = _createKeys(key);
		this._init = true;
	};
	/** Register DES algorithms **/
	registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
	registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
	registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
	registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
	registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
	registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
	registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
	registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
	registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
	registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
	function registerAlgorithm(name, mode) {
		var factory = function() {
			return new forge.des.Algorithm(name, mode);
		};
		forge.cipher.registerAlgorithm(name, factory);
	}
	/** DES implementation **/
	var spfunction1 = [
		16843776,
		0,
		65536,
		16843780,
		16842756,
		66564,
		4,
		65536,
		1024,
		16843776,
		16843780,
		1024,
		16778244,
		16842756,
		16777216,
		4,
		1028,
		16778240,
		16778240,
		66560,
		66560,
		16842752,
		16842752,
		16778244,
		65540,
		16777220,
		16777220,
		65540,
		0,
		1028,
		66564,
		16777216,
		65536,
		16843780,
		4,
		16842752,
		16843776,
		16777216,
		16777216,
		1024,
		16842756,
		65536,
		66560,
		16777220,
		1024,
		4,
		16778244,
		66564,
		16843780,
		65540,
		16842752,
		16778244,
		16777220,
		1028,
		66564,
		16843776,
		1028,
		16778240,
		16778240,
		0,
		65540,
		66560,
		0,
		16842756
	];
	var spfunction2 = [
		-2146402272,
		-2147450880,
		32768,
		1081376,
		1048576,
		32,
		-2146435040,
		-2147450848,
		-2147483616,
		-2146402272,
		-2146402304,
		-2147483648,
		-2147450880,
		1048576,
		32,
		-2146435040,
		1081344,
		1048608,
		-2147450848,
		0,
		-2147483648,
		32768,
		1081376,
		-2146435072,
		1048608,
		-2147483616,
		0,
		1081344,
		32800,
		-2146402304,
		-2146435072,
		32800,
		0,
		1081376,
		-2146435040,
		1048576,
		-2147450848,
		-2146435072,
		-2146402304,
		32768,
		-2146435072,
		-2147450880,
		32,
		-2146402272,
		1081376,
		32,
		32768,
		-2147483648,
		32800,
		-2146402304,
		1048576,
		-2147483616,
		1048608,
		-2147450848,
		-2147483616,
		1048608,
		1081344,
		0,
		-2147450880,
		32800,
		-2147483648,
		-2146435040,
		-2146402272,
		1081344
	];
	var spfunction3 = [
		520,
		134349312,
		0,
		134348808,
		134218240,
		0,
		131592,
		134218240,
		131080,
		134217736,
		134217736,
		131072,
		134349320,
		131080,
		134348800,
		520,
		134217728,
		8,
		134349312,
		512,
		131584,
		134348800,
		134348808,
		131592,
		134218248,
		131584,
		131072,
		134218248,
		8,
		134349320,
		512,
		134217728,
		134349312,
		134217728,
		131080,
		520,
		131072,
		134349312,
		134218240,
		0,
		512,
		131080,
		134349320,
		134218240,
		134217736,
		512,
		0,
		134348808,
		134218248,
		131072,
		134217728,
		134349320,
		8,
		131592,
		131584,
		134217736,
		134348800,
		134218248,
		520,
		134348800,
		131592,
		8,
		134348808,
		131584
	];
	var spfunction4 = [
		8396801,
		8321,
		8321,
		128,
		8396928,
		8388737,
		8388609,
		8193,
		0,
		8396800,
		8396800,
		8396929,
		129,
		0,
		8388736,
		8388609,
		1,
		8192,
		8388608,
		8396801,
		128,
		8388608,
		8193,
		8320,
		8388737,
		1,
		8320,
		8388736,
		8192,
		8396928,
		8396929,
		129,
		8388736,
		8388609,
		8396800,
		8396929,
		129,
		0,
		0,
		8396800,
		8320,
		8388736,
		8388737,
		1,
		8396801,
		8321,
		8321,
		128,
		8396929,
		129,
		1,
		8192,
		8388609,
		8193,
		8396928,
		8388737,
		8193,
		8320,
		8388608,
		8396801,
		128,
		8388608,
		8192,
		8396928
	];
	var spfunction5 = [
		256,
		34078976,
		34078720,
		1107296512,
		524288,
		256,
		1073741824,
		34078720,
		1074266368,
		524288,
		33554688,
		1074266368,
		1107296512,
		1107820544,
		524544,
		1073741824,
		33554432,
		1074266112,
		1074266112,
		0,
		1073742080,
		1107820800,
		1107820800,
		33554688,
		1107820544,
		1073742080,
		0,
		1107296256,
		34078976,
		33554432,
		1107296256,
		524544,
		524288,
		1107296512,
		256,
		33554432,
		1073741824,
		34078720,
		1107296512,
		1074266368,
		33554688,
		1073741824,
		1107820544,
		34078976,
		1074266368,
		256,
		33554432,
		1107820544,
		1107820800,
		524544,
		1107296256,
		1107820800,
		34078720,
		0,
		1074266112,
		1107296256,
		524544,
		33554688,
		1073742080,
		524288,
		0,
		1074266112,
		34078976,
		1073742080
	];
	var spfunction6 = [
		536870928,
		541065216,
		16384,
		541081616,
		541065216,
		16,
		541081616,
		4194304,
		536887296,
		4210704,
		4194304,
		536870928,
		4194320,
		536887296,
		536870912,
		16400,
		0,
		4194320,
		536887312,
		16384,
		4210688,
		536887312,
		16,
		541065232,
		541065232,
		0,
		4210704,
		541081600,
		16400,
		4210688,
		541081600,
		536870912,
		536887296,
		16,
		541065232,
		4210688,
		541081616,
		4194304,
		16400,
		536870928,
		4194304,
		536887296,
		536870912,
		16400,
		536870928,
		541081616,
		4210688,
		541065216,
		4210704,
		541081600,
		0,
		541065232,
		16,
		16384,
		541065216,
		4210704,
		16384,
		4194320,
		536887312,
		0,
		541081600,
		536870912,
		4194320,
		536887312
	];
	var spfunction7 = [
		2097152,
		69206018,
		67110914,
		0,
		2048,
		67110914,
		2099202,
		69208064,
		69208066,
		2097152,
		0,
		67108866,
		2,
		67108864,
		69206018,
		2050,
		67110912,
		2099202,
		2097154,
		67110912,
		67108866,
		69206016,
		69208064,
		2097154,
		69206016,
		2048,
		2050,
		69208066,
		2099200,
		2,
		67108864,
		2099200,
		67108864,
		2099200,
		2097152,
		67110914,
		67110914,
		69206018,
		69206018,
		2,
		2097154,
		67108864,
		67110912,
		2097152,
		69208064,
		2050,
		2099202,
		69208064,
		2050,
		67108866,
		69208066,
		69206016,
		2099200,
		0,
		2,
		69208066,
		0,
		2099202,
		69206016,
		2048,
		67108866,
		67110912,
		2048,
		2097154
	];
	var spfunction8 = [
		268439616,
		4096,
		262144,
		268701760,
		268435456,
		268439616,
		64,
		268435456,
		262208,
		268697600,
		268701760,
		266240,
		268701696,
		266304,
		4096,
		64,
		268697600,
		268435520,
		268439552,
		4160,
		266240,
		262208,
		268697664,
		268701696,
		4160,
		0,
		0,
		268697664,
		268435520,
		268439552,
		266304,
		262144,
		266304,
		262144,
		268701696,
		4096,
		64,
		268697664,
		4096,
		266304,
		268439552,
		64,
		268435520,
		268697600,
		268697664,
		268435456,
		262144,
		268439616,
		0,
		268701760,
		262208,
		268435520,
		268697600,
		268439552,
		268439616,
		0,
		268701760,
		266240,
		266240,
		4160,
		4160,
		262208,
		268435456,
		268701696
	];
	/**
	* Create necessary sub keys.
	*
	* @param key the 64-bit or 192-bit key.
	*
	* @return the expanded keys.
	*/
	function _createKeys(key) {
		var pc2bytes0 = [
			0,
			4,
			536870912,
			536870916,
			65536,
			65540,
			536936448,
			536936452,
			512,
			516,
			536871424,
			536871428,
			66048,
			66052,
			536936960,
			536936964
		], pc2bytes1 = [
			0,
			1,
			1048576,
			1048577,
			67108864,
			67108865,
			68157440,
			68157441,
			256,
			257,
			1048832,
			1048833,
			67109120,
			67109121,
			68157696,
			68157697
		], pc2bytes2 = [
			0,
			8,
			2048,
			2056,
			16777216,
			16777224,
			16779264,
			16779272,
			0,
			8,
			2048,
			2056,
			16777216,
			16777224,
			16779264,
			16779272
		], pc2bytes3 = [
			0,
			2097152,
			134217728,
			136314880,
			8192,
			2105344,
			134225920,
			136323072,
			131072,
			2228224,
			134348800,
			136445952,
			139264,
			2236416,
			134356992,
			136454144
		], pc2bytes4 = [
			0,
			262144,
			16,
			262160,
			0,
			262144,
			16,
			262160,
			4096,
			266240,
			4112,
			266256,
			4096,
			266240,
			4112,
			266256
		], pc2bytes5 = [
			0,
			1024,
			32,
			1056,
			0,
			1024,
			32,
			1056,
			33554432,
			33555456,
			33554464,
			33555488,
			33554432,
			33555456,
			33554464,
			33555488
		], pc2bytes6 = [
			0,
			268435456,
			524288,
			268959744,
			2,
			268435458,
			524290,
			268959746,
			0,
			268435456,
			524288,
			268959744,
			2,
			268435458,
			524290,
			268959746
		], pc2bytes7 = [
			0,
			65536,
			2048,
			67584,
			536870912,
			536936448,
			536872960,
			536938496,
			131072,
			196608,
			133120,
			198656,
			537001984,
			537067520,
			537004032,
			537069568
		], pc2bytes8 = [
			0,
			262144,
			0,
			262144,
			2,
			262146,
			2,
			262146,
			33554432,
			33816576,
			33554432,
			33816576,
			33554434,
			33816578,
			33554434,
			33816578
		], pc2bytes9 = [
			0,
			268435456,
			8,
			268435464,
			0,
			268435456,
			8,
			268435464,
			1024,
			268436480,
			1032,
			268436488,
			1024,
			268436480,
			1032,
			268436488
		], pc2bytes10 = [
			0,
			32,
			0,
			32,
			1048576,
			1048608,
			1048576,
			1048608,
			8192,
			8224,
			8192,
			8224,
			1056768,
			1056800,
			1056768,
			1056800
		], pc2bytes11 = [
			0,
			16777216,
			512,
			16777728,
			2097152,
			18874368,
			2097664,
			18874880,
			67108864,
			83886080,
			67109376,
			83886592,
			69206016,
			85983232,
			69206528,
			85983744
		], pc2bytes12 = [
			0,
			4096,
			134217728,
			134221824,
			524288,
			528384,
			134742016,
			134746112,
			16,
			4112,
			134217744,
			134221840,
			524304,
			528400,
			134742032,
			134746128
		], pc2bytes13 = [
			0,
			4,
			256,
			260,
			0,
			4,
			256,
			260,
			1,
			5,
			257,
			261,
			1,
			5,
			257,
			261
		];
		var iterations = key.length() > 8 ? 3 : 1;
		var keys = [];
		var shifts = [
			0,
			0,
			1,
			1,
			1,
			1,
			1,
			1,
			0,
			1,
			1,
			1,
			1,
			1,
			1,
			0
		];
		var n = 0, tmp;
		for (var j = 0; j < iterations; j++) {
			var left = key.getInt32();
			var right = key.getInt32();
			tmp = (left >>> 4 ^ right) & 252645135;
			right ^= tmp;
			left ^= tmp << 4;
			tmp = (right >>> -16 ^ left) & 65535;
			left ^= tmp;
			right ^= tmp << -16;
			tmp = (left >>> 2 ^ right) & 858993459;
			right ^= tmp;
			left ^= tmp << 2;
			tmp = (right >>> -16 ^ left) & 65535;
			left ^= tmp;
			right ^= tmp << -16;
			tmp = (left >>> 1 ^ right) & 1431655765;
			right ^= tmp;
			left ^= tmp << 1;
			tmp = (right >>> 8 ^ left) & 16711935;
			left ^= tmp;
			right ^= tmp << 8;
			tmp = (left >>> 1 ^ right) & 1431655765;
			right ^= tmp;
			left ^= tmp << 1;
			tmp = left << 8 | right >>> 20 & 240;
			left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
			right = tmp;
			for (var i = 0; i < shifts.length; ++i) {
				if (shifts[i]) {
					left = left << 2 | left >>> 26;
					right = right << 2 | right >>> 26;
				} else {
					left = left << 1 | left >>> 27;
					right = right << 1 | right >>> 27;
				}
				left &= -15;
				right &= -15;
				var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
				var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
				tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
				keys[n++] = lefttmp ^ tmp;
				keys[n++] = righttmp ^ tmp << 16;
			}
		}
		return keys;
	}
	/**
	* Updates a single block (1 byte) using DES. The update will either
	* encrypt or decrypt the block.
	*
	* @param keys the expanded keys.
	* @param input the input block (an array of 32-bit words).
	* @param output the updated output block.
	* @param decrypt true to decrypt the block, false to encrypt it.
	*/
	function _updateBlock(keys, input, output, decrypt) {
		var iterations = keys.length === 32 ? 3 : 9;
		var looping;
		if (iterations === 3) looping = decrypt ? [
			30,
			-2,
			-2
		] : [
			0,
			32,
			2
		];
		else looping = decrypt ? [
			94,
			62,
			-2,
			32,
			64,
			2,
			30,
			-2,
			-2
		] : [
			0,
			32,
			2,
			62,
			30,
			-2,
			64,
			96,
			2
		];
		var tmp;
		var left = input[0];
		var right = input[1];
		tmp = (left >>> 4 ^ right) & 252645135;
		right ^= tmp;
		left ^= tmp << 4;
		tmp = (left >>> 16 ^ right) & 65535;
		right ^= tmp;
		left ^= tmp << 16;
		tmp = (right >>> 2 ^ left) & 858993459;
		left ^= tmp;
		right ^= tmp << 2;
		tmp = (right >>> 8 ^ left) & 16711935;
		left ^= tmp;
		right ^= tmp << 8;
		tmp = (left >>> 1 ^ right) & 1431655765;
		right ^= tmp;
		left ^= tmp << 1;
		left = left << 1 | left >>> 31;
		right = right << 1 | right >>> 31;
		for (var j = 0; j < iterations; j += 3) {
			var endloop = looping[j + 1];
			var loopinc = looping[j + 2];
			for (var i = looping[j]; i != endloop; i += loopinc) {
				var right1 = right ^ keys[i];
				var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
				tmp = left;
				left = right;
				right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
			}
			tmp = left;
			left = right;
			right = tmp;
		}
		left = left >>> 1 | left << 31;
		right = right >>> 1 | right << 31;
		tmp = (left >>> 1 ^ right) & 1431655765;
		right ^= tmp;
		left ^= tmp << 1;
		tmp = (right >>> 8 ^ left) & 16711935;
		left ^= tmp;
		right ^= tmp << 8;
		tmp = (right >>> 2 ^ left) & 858993459;
		left ^= tmp;
		right ^= tmp << 2;
		tmp = (left >>> 16 ^ right) & 65535;
		right ^= tmp;
		left ^= tmp << 16;
		tmp = (left >>> 4 ^ right) & 252645135;
		right ^= tmp;
		left ^= tmp << 4;
		output[0] = left;
		output[1] = right;
	}
	/**
	* Deprecated. Instead, use:
	*
	* forge.cipher.createCipher('DES-<mode>', key);
	* forge.cipher.createDecipher('DES-<mode>', key);
	*
	* Creates a deprecated DES cipher object. This object's mode will default to
	* CBC (cipher-block-chaining).
	*
	* The key may be given as a binary-encoded string of bytes or a byte buffer.
	*
	* @param options the options to use.
	*          key the symmetric key to use (64 or 192 bits).
	*          output the buffer to write to.
	*          decrypt true for decryption, false for encryption.
	*          mode the cipher mode to use (default: 'CBC').
	*
	* @return the cipher.
	*/
	function _createCipher(options) {
		options = options || {};
		var algorithm = "DES-" + (options.mode || "CBC").toUpperCase();
		var cipher;
		if (options.decrypt) cipher = forge.cipher.createDecipher(algorithm, options.key);
		else cipher = forge.cipher.createCipher(algorithm, options.key);
		var start = cipher.start;
		cipher.start = function(iv, options) {
			var output = null;
			if (options instanceof forge.util.ByteBuffer) {
				output = options;
				options = {};
			}
			options = options || {};
			options.output = output;
			options.iv = iv;
			start.call(cipher, options);
		};
		return cipher;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Password-Based Key-Derivation Function #2 implementation.
	*
	* See RFC 2898 for details.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2013 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_hmac();
	require_md();
	require_util();
	var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
	var crypto;
	if (forge.util.isNodejs && !forge.options.usePureJavaScript) crypto = __require("crypto");
	/**
	* Derives a key from a password.
	*
	* @param p the password as a binary-encoded string of bytes.
	* @param s the salt as a binary-encoded string of bytes.
	* @param c the iteration count, a positive integer.
	* @param dkLen the intended length, in bytes, of the derived key,
	*          (max: 2^32 - 1) * hash length of the PRF.
	* @param [md] the message digest (or algorithm identifier as a string) to use
	*          in the PRF, defaults to SHA-1.
	* @param [callback(err, key)] presence triggers asynchronous version, called
	*          once the operation completes.
	*
	* @return the derived key, as a binary-encoded string of bytes, for the
	*           synchronous version (if no callback is specified).
	*/
	module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
		if (typeof md === "function") {
			callback = md;
			md = null;
		}
		if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md !== "object") && (crypto.pbkdf2Sync.length > 4 || !md || md === "sha1")) {
			if (typeof md !== "string") md = "sha1";
			p = Buffer.from(p, "binary");
			s = Buffer.from(s, "binary");
			if (!callback) {
				if (crypto.pbkdf2Sync.length === 4) return crypto.pbkdf2Sync(p, s, c, dkLen).toString("binary");
				return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
			}
			if (crypto.pbkdf2Sync.length === 4) return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {
				if (err) return callback(err);
				callback(null, key.toString("binary"));
			});
			return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {
				if (err) return callback(err);
				callback(null, key.toString("binary"));
			});
		}
		if (typeof md === "undefined" || md === null) md = "sha1";
		if (typeof md === "string") {
			if (!(md in forge.md.algorithms)) throw new Error("Unknown hash algorithm: " + md);
			md = forge.md[md].create();
		}
		var hLen = md.digestLength;
		if (dkLen > 4294967295 * hLen) {
			var err = /* @__PURE__ */ new Error("Derived key is too long.");
			if (callback) return callback(err);
			throw err;
		}
		var len = Math.ceil(dkLen / hLen);
		var r = dkLen - (len - 1) * hLen;
		var prf = forge.hmac.create();
		prf.start(md, p);
		var dk = "";
		var xor, u_c, u_c1;
		if (!callback) {
			for (var i = 1; i <= len; ++i) {
				prf.start(null, null);
				prf.update(s);
				prf.update(forge.util.int32ToBytes(i));
				xor = u_c1 = prf.digest().getBytes();
				for (var j = 2; j <= c; ++j) {
					prf.start(null, null);
					prf.update(u_c1);
					u_c = prf.digest().getBytes();
					xor = forge.util.xorBytes(xor, u_c, hLen);
					u_c1 = u_c;
				}
				dk += i < len ? xor : xor.substr(0, r);
			}
			return dk;
		}
		var i = 1, j;
		function outer() {
			if (i > len) return callback(null, dk);
			prf.start(null, null);
			prf.update(s);
			prf.update(forge.util.int32ToBytes(i));
			xor = u_c1 = prf.digest().getBytes();
			j = 2;
			inner();
		}
		function inner() {
			if (j <= c) {
				prf.start(null, null);
				prf.update(u_c1);
				u_c = prf.digest().getBytes();
				xor = forge.util.xorBytes(xor, u_c, hLen);
				u_c1 = u_c;
				++j;
				return forge.util.setImmediate(inner);
			}
			dk += i < len ? xor : xor.substr(0, r);
			++i;
			outer();
		}
		outer();
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/sha256.js
var require_sha256 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
	*
	* See FIPS 180-2 for details.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2015 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
	forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
	/**
	* Creates a SHA-256 message digest object.
	*
	* @return a message digest object.
	*/
	sha256.create = function() {
		if (!_initialized) _init();
		var _state = null;
		var _input = forge.util.createBuffer();
		var _w = new Array(64);
		var md = {
			algorithm: "sha256",
			blockLength: 64,
			digestLength: 32,
			messageLength: 0,
			fullMessageLength: null,
			messageLengthSize: 8
		};
		/**
		* Starts the digest.
		*
		* @return this digest object.
		*/
		md.start = function() {
			md.messageLength = 0;
			md.fullMessageLength = md.messageLength64 = [];
			var int32s = md.messageLengthSize / 4;
			for (var i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
			_input = forge.util.createBuffer();
			_state = {
				h0: 1779033703,
				h1: 3144134277,
				h2: 1013904242,
				h3: 2773480762,
				h4: 1359893119,
				h5: 2600822924,
				h6: 528734635,
				h7: 1541459225
			};
			return md;
		};
		md.start();
		/**
		* Updates the digest with the given message input. The given input can
		* treated as raw input (no encoding will be applied) or an encoding of
		* 'utf8' maybe given to encode the input using UTF-8.
		*
		* @param msg the message input to update with.
		* @param encoding the encoding to use (default: 'raw', other: 'utf8').
		*
		* @return this digest object.
		*/
		md.update = function(msg, encoding) {
			if (encoding === "utf8") msg = forge.util.encodeUtf8(msg);
			var len = msg.length;
			md.messageLength += len;
			len = [len / 4294967296 >>> 0, len >>> 0];
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				md.fullMessageLength[i] += len[1];
				len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
				md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
				len[0] = len[1] / 4294967296 >>> 0;
			}
			_input.putBytes(msg);
			_update(_state, _w, _input);
			if (_input.read > 2048 || _input.length() === 0) _input.compact();
			return md;
		};
		/**
		* Produces the digest.
		*
		* @return a byte buffer containing the digest value.
		*/
		md.digest = function() {
			var finalBlock = forge.util.createBuffer();
			finalBlock.putBytes(_input.bytes());
			var overflow = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize & md.blockLength - 1;
			finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
			var next, carry;
			var bits = md.fullMessageLength[0] * 8;
			for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
				next = md.fullMessageLength[i + 1] * 8;
				carry = next / 4294967296 >>> 0;
				bits += carry;
				finalBlock.putInt32(bits >>> 0);
				bits = next >>> 0;
			}
			finalBlock.putInt32(bits);
			var s2 = {
				h0: _state.h0,
				h1: _state.h1,
				h2: _state.h2,
				h3: _state.h3,
				h4: _state.h4,
				h5: _state.h5,
				h6: _state.h6,
				h7: _state.h7
			};
			_update(s2, _w, finalBlock);
			var rval = forge.util.createBuffer();
			rval.putInt32(s2.h0);
			rval.putInt32(s2.h1);
			rval.putInt32(s2.h2);
			rval.putInt32(s2.h3);
			rval.putInt32(s2.h4);
			rval.putInt32(s2.h5);
			rval.putInt32(s2.h6);
			rval.putInt32(s2.h7);
			return rval;
		};
		return md;
	};
	var _padding = null;
	var _initialized = false;
	var _k = null;
	/**
	* Initializes the constant tables.
	*/
	function _init() {
		_padding = String.fromCharCode(128);
		_padding += forge.util.fillString(String.fromCharCode(0), 64);
		_k = [
			1116352408,
			1899447441,
			3049323471,
			3921009573,
			961987163,
			1508970993,
			2453635748,
			2870763221,
			3624381080,
			310598401,
			607225278,
			1426881987,
			1925078388,
			2162078206,
			2614888103,
			3248222580,
			3835390401,
			4022224774,
			264347078,
			604807628,
			770255983,
			1249150122,
			1555081692,
			1996064986,
			2554220882,
			2821834349,
			2952996808,
			3210313671,
			3336571891,
			3584528711,
			113926993,
			338241895,
			666307205,
			773529912,
			1294757372,
			1396182291,
			1695183700,
			1986661051,
			2177026350,
			2456956037,
			2730485921,
			2820302411,
			3259730800,
			3345764771,
			3516065817,
			3600352804,
			4094571909,
			275423344,
			430227734,
			506948616,
			659060556,
			883997877,
			958139571,
			1322822218,
			1537002063,
			1747873779,
			1955562222,
			2024104815,
			2227730452,
			2361852424,
			2428436474,
			2756734187,
			3204031479,
			3329325298
		];
		_initialized = true;
	}
	/**
	* Updates a SHA-256 state with the given byte buffer.
	*
	* @param s the SHA-256 state to update.
	* @param w the array to use to store words.
	* @param bytes the byte buffer to update with.
	*/
	function _update(s, w, bytes) {
		var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
		var len = bytes.length();
		while (len >= 64) {
			for (i = 0; i < 16; ++i) w[i] = bytes.getInt32();
			for (; i < 64; ++i) {
				t1 = w[i - 2];
				t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
				t2 = w[i - 15];
				t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
				w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
			}
			a = s.h0;
			b = s.h1;
			c = s.h2;
			d = s.h3;
			e = s.h4;
			f = s.h5;
			g = s.h6;
			h = s.h7;
			for (i = 0; i < 64; ++i) {
				s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
				ch = g ^ e & (f ^ g);
				s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
				maj = a & b | c & (a ^ b);
				t1 = h + s1 + ch + _k[i] + w[i];
				t2 = s0 + maj;
				h = g;
				g = f;
				f = e;
				e = d + t1 >>> 0;
				d = c;
				c = b;
				b = a;
				a = t1 + t2 >>> 0;
			}
			s.h0 = s.h0 + a | 0;
			s.h1 = s.h1 + b | 0;
			s.h2 = s.h2 + c | 0;
			s.h3 = s.h3 + d | 0;
			s.h4 = s.h4 + e | 0;
			s.h5 = s.h5 + f | 0;
			s.h6 = s.h6 + g | 0;
			s.h7 = s.h7 + h | 0;
			len -= 64;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/prng.js
var require_prng = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* A javascript implementation of a cryptographically-secure
	* Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
	* here though the use of SHA-256 is not enforced; when generating an
	* a PRNG context, the hashing algorithm and block cipher used for
	* the generator are specified via a plugin.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	var _crypto = null;
	if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) _crypto = __require("crypto");
	var prng = module.exports = forge.prng = forge.prng || {};
	/**
	* Creates a new PRNG context.
	*
	* A PRNG plugin must be passed in that will provide:
	*
	* 1. A function that initializes the key and seed of a PRNG context. It
	*   will be given a 16 byte key and a 16 byte seed. Any key expansion
	*   or transformation of the seed from a byte string into an array of
	*   integers (or similar) should be performed.
	* 2. The cryptographic function used by the generator. It takes a key and
	*   a seed.
	* 3. A seed increment function. It takes the seed and returns seed + 1.
	* 4. An api to create a message digest.
	*
	* For an example, see random.js.
	*
	* @param plugin the PRNG plugin to use.
	*/
	prng.create = function(plugin) {
		var ctx = {
			plugin,
			key: null,
			seed: null,
			time: null,
			reseeds: 0,
			generated: 0,
			keyBytes: ""
		};
		var md = plugin.md;
		var pools = new Array(32);
		for (var i = 0; i < 32; ++i) pools[i] = md.create();
		ctx.pools = pools;
		ctx.pool = 0;
		/**
		* Generates random bytes. The bytes may be generated synchronously or
		* asynchronously. Web workers must use the asynchronous interface or
		* else the behavior is undefined.
		*
		* @param count the number of random bytes to generate.
		* @param [callback(err, bytes)] called once the operation completes.
		*
		* @return count random bytes as a string.
		*/
		ctx.generate = function(count, callback) {
			if (!callback) return ctx.generateSync(count);
			var cipher = ctx.plugin.cipher;
			var increment = ctx.plugin.increment;
			var formatKey = ctx.plugin.formatKey;
			var formatSeed = ctx.plugin.formatSeed;
			var b = forge.util.createBuffer();
			ctx.key = null;
			generate();
			function generate(err) {
				if (err) return callback(err);
				if (b.length() >= count) return callback(null, b.getBytes(count));
				if (ctx.generated > 1048575) ctx.key = null;
				if (ctx.key === null) return forge.util.nextTick(function() {
					_reseed(generate);
				});
				var bytes = cipher(ctx.key, ctx.seed);
				ctx.generated += bytes.length;
				b.putBytes(bytes);
				ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
				ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
				forge.util.setImmediate(generate);
			}
		};
		/**
		* Generates random bytes synchronously.
		*
		* @param count the number of random bytes to generate.
		*
		* @return count random bytes as a string.
		*/
		ctx.generateSync = function(count) {
			var cipher = ctx.plugin.cipher;
			var increment = ctx.plugin.increment;
			var formatKey = ctx.plugin.formatKey;
			var formatSeed = ctx.plugin.formatSeed;
			ctx.key = null;
			var b = forge.util.createBuffer();
			while (b.length() < count) {
				if (ctx.generated > 1048575) ctx.key = null;
				if (ctx.key === null) _reseedSync();
				var bytes = cipher(ctx.key, ctx.seed);
				ctx.generated += bytes.length;
				b.putBytes(bytes);
				ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
				ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
			}
			return b.getBytes(count);
		};
		/**
		* Private function that asynchronously reseeds a generator.
		*
		* @param callback(err) called once the operation completes.
		*/
		function _reseed(callback) {
			if (ctx.pools[0].messageLength >= 32) {
				_seed();
				return callback();
			}
			var needed = 32 - ctx.pools[0].messageLength << 5;
			ctx.seedFile(needed, function(err, bytes) {
				if (err) return callback(err);
				ctx.collect(bytes);
				_seed();
				callback();
			});
		}
		/**
		* Private function that synchronously reseeds a generator.
		*/
		function _reseedSync() {
			if (ctx.pools[0].messageLength >= 32) return _seed();
			var needed = 32 - ctx.pools[0].messageLength << 5;
			ctx.collect(ctx.seedFileSync(needed));
			_seed();
		}
		/**
		* Private function that seeds a generator once enough bytes are available.
		*/
		function _seed() {
			ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
			var md = ctx.plugin.md.create();
			md.update(ctx.keyBytes);
			var _2powK = 1;
			for (var k = 0; k < 32; ++k) {
				if (ctx.reseeds % _2powK === 0) {
					md.update(ctx.pools[k].digest().getBytes());
					ctx.pools[k].start();
				}
				_2powK = _2powK << 1;
			}
			ctx.keyBytes = md.digest().getBytes();
			md.start();
			md.update(ctx.keyBytes);
			var seedBytes = md.digest().getBytes();
			ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
			ctx.seed = ctx.plugin.formatSeed(seedBytes);
			ctx.generated = 0;
		}
		/**
		* The built-in default seedFile. This seedFile is used when entropy
		* is needed immediately.
		*
		* @param needed the number of bytes that are needed.
		*
		* @return the random bytes.
		*/
		function defaultSeedFile(needed) {
			var getRandomValues = null;
			var globalScope = forge.util.globalScope;
			var _crypto = globalScope.crypto || globalScope.msCrypto;
			if (_crypto && _crypto.getRandomValues) getRandomValues = function(arr) {
				return _crypto.getRandomValues(arr);
			};
			var b = forge.util.createBuffer();
			if (getRandomValues) while (b.length() < needed) {
				var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
				var entropy = new Uint32Array(Math.floor(count));
				try {
					getRandomValues(entropy);
					for (var i = 0; i < entropy.length; ++i) b.putInt32(entropy[i]);
				} catch (e) {
					if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) throw e;
				}
			}
			if (b.length() < needed) {
				var hi, lo, next;
				var seed = Math.floor(Math.random() * 65536);
				while (b.length() < needed) {
					lo = 16807 * (seed & 65535);
					hi = 16807 * (seed >> 16);
					lo += (hi & 32767) << 16;
					lo += hi >> 15;
					lo = (lo & 2147483647) + (lo >> 31);
					seed = lo & 4294967295;
					for (var i = 0; i < 3; ++i) {
						next = seed >>> (i << 3);
						next ^= Math.floor(Math.random() * 256);
						b.putByte(next & 255);
					}
				}
			}
			return b.getBytes(needed);
		}
		if (_crypto) {
			ctx.seedFile = function(needed, callback) {
				_crypto.randomBytes(needed, function(err, bytes) {
					if (err) return callback(err);
					callback(null, bytes.toString());
				});
			};
			ctx.seedFileSync = function(needed) {
				return _crypto.randomBytes(needed).toString();
			};
		} else {
			ctx.seedFile = function(needed, callback) {
				try {
					callback(null, defaultSeedFile(needed));
				} catch (e) {
					callback(e);
				}
			};
			ctx.seedFileSync = defaultSeedFile;
		}
		/**
		* Adds entropy to a prng ctx's accumulator.
		*
		* @param bytes the bytes of entropy as a string.
		*/
		ctx.collect = function(bytes) {
			var count = bytes.length;
			for (var i = 0; i < count; ++i) {
				ctx.pools[ctx.pool].update(bytes.substr(i, 1));
				ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
			}
		};
		/**
		* Collects an integer of n bits.
		*
		* @param i the integer entropy.
		* @param n the number of bits in the integer.
		*/
		ctx.collectInt = function(i, n) {
			var bytes = "";
			for (var x = 0; x < n; x += 8) bytes += String.fromCharCode(i >> x & 255);
			ctx.collect(bytes);
		};
		/**
		* Registers a Web Worker to receive immediate entropy from the main thread.
		* This method is required until Web Workers can access the native crypto
		* API. This method should be called twice for each created worker, once in
		* the main thread, and once in the worker itself.
		*
		* @param worker the worker to register.
		*/
		ctx.registerWorker = function(worker) {
			if (worker === self) ctx.seedFile = function(needed, callback) {
				function listener(e) {
					var data = e.data;
					if (data.forge && data.forge.prng) {
						self.removeEventListener("message", listener);
						callback(data.forge.prng.err, data.forge.prng.bytes);
					}
				}
				self.addEventListener("message", listener);
				self.postMessage({ forge: { prng: { needed } } });
			};
			else {
				var listener = function(e) {
					var data = e.data;
					if (data.forge && data.forge.prng) ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
						worker.postMessage({ forge: { prng: {
							err,
							bytes
						} } });
					});
				};
				worker.addEventListener("message", listener);
			}
		};
		return ctx;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/random.js
var require_random = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* An API for getting cryptographically-secure random bytes. The bytes are
	* generated using the Fortuna algorithm devised by Bruce Schneier and
	* Niels Ferguson.
	*
	* Getting strong random bytes is not yet easy to do in javascript. The only
	* truish random entropy that can be collected is from the mouse, keyboard, or
	* from timing with respect to page loads, etc. This generator makes a poor
	* attempt at providing random bytes when those sources haven't yet provided
	* enough entropy to initially seed or to reseed the PRNG.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2009-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_aes();
	require_sha256();
	require_prng();
	require_util();
	(function() {
		if (forge.random && forge.random.getBytes) {
			module.exports = forge.random;
			return;
		}
		(function(jQuery) {
			var prng_aes = {};
			var _prng_aes_output = new Array(4);
			var _prng_aes_buffer = forge.util.createBuffer();
			prng_aes.formatKey = function(key) {
				var tmp = forge.util.createBuffer(key);
				key = new Array(4);
				key[0] = tmp.getInt32();
				key[1] = tmp.getInt32();
				key[2] = tmp.getInt32();
				key[3] = tmp.getInt32();
				return forge.aes._expandKey(key, false);
			};
			prng_aes.formatSeed = function(seed) {
				var tmp = forge.util.createBuffer(seed);
				seed = new Array(4);
				seed[0] = tmp.getInt32();
				seed[1] = tmp.getInt32();
				seed[2] = tmp.getInt32();
				seed[3] = tmp.getInt32();
				return seed;
			};
			prng_aes.cipher = function(key, seed) {
				forge.aes._updateBlock(key, seed, _prng_aes_output, false);
				_prng_aes_buffer.putInt32(_prng_aes_output[0]);
				_prng_aes_buffer.putInt32(_prng_aes_output[1]);
				_prng_aes_buffer.putInt32(_prng_aes_output[2]);
				_prng_aes_buffer.putInt32(_prng_aes_output[3]);
				return _prng_aes_buffer.getBytes();
			};
			prng_aes.increment = function(seed) {
				++seed[3];
				return seed;
			};
			prng_aes.md = forge.md.sha256;
			/**
			* Creates a new PRNG.
			*/
			function spawnPrng() {
				var ctx = forge.prng.create(prng_aes);
				/**
				* Gets random bytes. If a native secure crypto API is unavailable, this
				* method tries to make the bytes more unpredictable by drawing from data that
				* can be collected from the user of the browser, eg: mouse movement.
				*
				* If a callback is given, this method will be called asynchronously.
				*
				* @param count the number of random bytes to get.
				* @param [callback(err, bytes)] called once the operation completes.
				*
				* @return the random bytes in a string.
				*/
				ctx.getBytes = function(count, callback) {
					return ctx.generate(count, callback);
				};
				/**
				* Gets random bytes asynchronously. If a native secure crypto API is
				* unavailable, this method tries to make the bytes more unpredictable by
				* drawing from data that can be collected from the user of the browser,
				* eg: mouse movement.
				*
				* @param count the number of random bytes to get.
				*
				* @return the random bytes in a string.
				*/
				ctx.getBytesSync = function(count) {
					return ctx.generate(count);
				};
				return ctx;
			}
			var _ctx = spawnPrng();
			var getRandomValues = null;
			var globalScope = forge.util.globalScope;
			var _crypto = globalScope.crypto || globalScope.msCrypto;
			if (_crypto && _crypto.getRandomValues) getRandomValues = function(arr) {
				return _crypto.getRandomValues(arr);
			};
			if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
				if (typeof window === "undefined" || window.document === void 0) {}
				_ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
				if (typeof navigator !== "undefined") {
					var _navBytes = "";
					for (var key in navigator) try {
						if (typeof navigator[key] == "string") _navBytes += navigator[key];
					} catch (e) {}
					_ctx.collect(_navBytes);
					_navBytes = null;
				}
				if (jQuery) {
					jQuery().mousemove(function(e) {
						_ctx.collectInt(e.clientX, 16);
						_ctx.collectInt(e.clientY, 16);
					});
					jQuery().keypress(function(e) {
						_ctx.collectInt(e.charCode, 8);
					});
				}
			}
			if (!forge.random) forge.random = _ctx;
			else for (var key in _ctx) forge.random[key] = _ctx[key];
			forge.random.createInstance = spawnPrng;
			module.exports = forge.random;
		})(typeof jQuery !== "undefined" ? jQuery : null);
	})();
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/rc2.js
var require_rc2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* RC2 implementation.
	*
	* @author Stefan Siegl
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*
	* Information on the RC2 cipher is available from RFC #2268,
	* http://www.ietf.org/rfc/rfc2268.txt
	*/
	var forge = require_forge();
	require_util();
	var piTable = [
		217,
		120,
		249,
		196,
		25,
		221,
		181,
		237,
		40,
		233,
		253,
		121,
		74,
		160,
		216,
		157,
		198,
		126,
		55,
		131,
		43,
		118,
		83,
		142,
		98,
		76,
		100,
		136,
		68,
		139,
		251,
		162,
		23,
		154,
		89,
		245,
		135,
		179,
		79,
		19,
		97,
		69,
		109,
		141,
		9,
		129,
		125,
		50,
		189,
		143,
		64,
		235,
		134,
		183,
		123,
		11,
		240,
		149,
		33,
		34,
		92,
		107,
		78,
		130,
		84,
		214,
		101,
		147,
		206,
		96,
		178,
		28,
		115,
		86,
		192,
		20,
		167,
		140,
		241,
		220,
		18,
		117,
		202,
		31,
		59,
		190,
		228,
		209,
		66,
		61,
		212,
		48,
		163,
		60,
		182,
		38,
		111,
		191,
		14,
		218,
		70,
		105,
		7,
		87,
		39,
		242,
		29,
		155,
		188,
		148,
		67,
		3,
		248,
		17,
		199,
		246,
		144,
		239,
		62,
		231,
		6,
		195,
		213,
		47,
		200,
		102,
		30,
		215,
		8,
		232,
		234,
		222,
		128,
		82,
		238,
		247,
		132,
		170,
		114,
		172,
		53,
		77,
		106,
		42,
		150,
		26,
		210,
		113,
		90,
		21,
		73,
		116,
		75,
		159,
		208,
		94,
		4,
		24,
		164,
		236,
		194,
		224,
		65,
		110,
		15,
		81,
		203,
		204,
		36,
		145,
		175,
		80,
		161,
		244,
		112,
		57,
		153,
		124,
		58,
		133,
		35,
		184,
		180,
		122,
		252,
		2,
		54,
		91,
		37,
		85,
		151,
		49,
		45,
		93,
		250,
		152,
		227,
		138,
		146,
		174,
		5,
		223,
		41,
		16,
		103,
		108,
		186,
		201,
		211,
		0,
		230,
		207,
		225,
		158,
		168,
		44,
		99,
		22,
		1,
		63,
		88,
		226,
		137,
		169,
		13,
		56,
		52,
		27,
		171,
		51,
		255,
		176,
		187,
		72,
		12,
		95,
		185,
		177,
		205,
		46,
		197,
		243,
		219,
		71,
		229,
		165,
		156,
		119,
		10,
		166,
		32,
		104,
		254,
		127,
		193,
		173
	];
	var s = [
		1,
		2,
		3,
		5
	];
	/**
	* Rotate a word left by given number of bits.
	*
	* Bits that are shifted out on the left are put back in on the right
	* hand side.
	*
	* @param word The word to shift left.
	* @param bits The number of bits to shift by.
	* @return The rotated word.
	*/
	var rol = function(word, bits) {
		return word << bits & 65535 | (word & 65535) >> 16 - bits;
	};
	/**
	* Rotate a word right by given number of bits.
	*
	* Bits that are shifted out on the right are put back in on the left
	* hand side.
	*
	* @param word The word to shift right.
	* @param bits The number of bits to shift by.
	* @return The rotated word.
	*/
	var ror = function(word, bits) {
		return (word & 65535) >> bits | word << 16 - bits & 65535;
	};
	module.exports = forge.rc2 = forge.rc2 || {};
	/**
	* Perform RC2 key expansion as per RFC #2268, section 2.
	*
	* @param key variable-length user key (between 1 and 128 bytes)
	* @param effKeyBits number of effective key bits (default: 128)
	* @return the expanded RC2 key (ByteBuffer of 128 bytes)
	*/
	forge.rc2.expandKey = function(key, effKeyBits) {
		if (typeof key === "string") key = forge.util.createBuffer(key);
		effKeyBits = effKeyBits || 128;
		var L = key;
		var T = key.length();
		var T1 = effKeyBits;
		var T8 = Math.ceil(T1 / 8);
		var TM = 255 >> (T1 & 7);
		var i;
		for (i = T; i < 128; i++) L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
		L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
		for (i = 127 - T8; i >= 0; i--) L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
		return L;
	};
	/**
	* Creates a RC2 cipher object.
	*
	* @param key the symmetric key to use (as base for key generation).
	* @param bits the number of effective key bits.
	* @param encrypt false for decryption, true for encryption.
	*
	* @return the cipher.
	*/
	var createCipher = function(key, bits, encrypt) {
		var _finish = false, _input = null, _output = null, _iv = null;
		var mixRound, mashRound;
		var i, j, K = [];
		key = forge.rc2.expandKey(key, bits);
		for (i = 0; i < 64; i++) K.push(key.getInt16Le());
		if (encrypt) {
			/**
			* Perform one mixing round "in place".
			*
			* @param R Array of four words to perform mixing on.
			*/
			mixRound = function(R) {
				for (i = 0; i < 4; i++) {
					R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
					R[i] = rol(R[i], s[i]);
					j++;
				}
			};
			/**
			* Perform one mashing round "in place".
			*
			* @param R Array of four words to perform mashing on.
			*/
			mashRound = function(R) {
				for (i = 0; i < 4; i++) R[i] += K[R[(i + 3) % 4] & 63];
			};
		} else {
			/**
			* Perform one r-mixing round "in place".
			*
			* @param R Array of four words to perform mixing on.
			*/
			mixRound = function(R) {
				for (i = 3; i >= 0; i--) {
					R[i] = ror(R[i], s[i]);
					R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
					j--;
				}
			};
			/**
			* Perform one r-mashing round "in place".
			*
			* @param R Array of four words to perform mashing on.
			*/
			mashRound = function(R) {
				for (i = 3; i >= 0; i--) R[i] -= K[R[(i + 3) % 4] & 63];
			};
		}
		/**
		* Run the specified cipher execution plan.
		*
		* This function takes four words from the input buffer, applies the IV on
		* it (if requested) and runs the provided execution plan.
		*
		* The plan must be put together in form of a array of arrays.  Where the
		* outer one is simply a list of steps to perform and the inner one needs
		* to have two elements: the first one telling how many rounds to perform,
		* the second one telling what to do (i.e. the function to call).
		*
		* @param {Array} plan The plan to execute.
		*/
		var runPlan = function(plan) {
			var R = [];
			for (i = 0; i < 4; i++) {
				var val = _input.getInt16Le();
				if (_iv !== null) if (encrypt) val ^= _iv.getInt16Le();
				else _iv.putInt16Le(val);
				R.push(val & 65535);
			}
			j = encrypt ? 0 : 63;
			for (var ptr = 0; ptr < plan.length; ptr++) for (var ctr = 0; ctr < plan[ptr][0]; ctr++) plan[ptr][1](R);
			for (i = 0; i < 4; i++) {
				if (_iv !== null) if (encrypt) _iv.putInt16Le(R[i]);
				else R[i] ^= _iv.getInt16Le();
				_output.putInt16Le(R[i]);
			}
		};
		var cipher = null;
		cipher = {
			start: function(iv, output) {
				if (iv) {
					if (typeof iv === "string") iv = forge.util.createBuffer(iv);
				}
				_finish = false;
				_input = forge.util.createBuffer();
				_output = output || new forge.util.createBuffer();
				_iv = iv;
				cipher.output = _output;
			},
			update: function(input) {
				if (!_finish) _input.putBuffer(input);
				while (_input.length() >= 8) runPlan([
					[5, mixRound],
					[1, mashRound],
					[6, mixRound],
					[1, mashRound],
					[5, mixRound]
				]);
			},
			finish: function(pad) {
				var rval = true;
				if (encrypt) if (pad) rval = pad(8, _input, !encrypt);
				else {
					var padding = _input.length() === 8 ? 8 : 8 - _input.length();
					_input.fillWithByte(padding, padding);
				}
				if (rval) {
					_finish = true;
					cipher.update();
				}
				if (!encrypt) {
					rval = _input.length() === 0;
					if (rval) if (pad) rval = pad(8, _output, !encrypt);
					else {
						var len = _output.length();
						var count = _output.at(len - 1);
						if (count > len) rval = false;
						else _output.truncate(count);
					}
				}
				return rval;
			}
		};
		return cipher;
	};
	/**
	* Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
	* given symmetric key. The output will be stored in the 'output' member
	* of the returned cipher.
	*
	* The key and iv may be given as a string of bytes or a byte buffer.
	* The cipher is initialized to use 128 effective key bits.
	*
	* @param key the symmetric key to use.
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	*
	* @return the cipher.
	*/
	forge.rc2.startEncrypting = function(key, iv, output) {
		var cipher = forge.rc2.createEncryptionCipher(key, 128);
		cipher.start(iv, output);
		return cipher;
	};
	/**
	* Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
	* given symmetric key.
	*
	* The key may be given as a string of bytes or a byte buffer.
	*
	* To start encrypting call start() on the cipher with an iv and optional
	* output buffer.
	*
	* @param key the symmetric key to use.
	*
	* @return the cipher.
	*/
	forge.rc2.createEncryptionCipher = function(key, bits) {
		return createCipher(key, bits, true);
	};
	/**
	* Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
	* given symmetric key. The output will be stored in the 'output' member
	* of the returned cipher.
	*
	* The key and iv may be given as a string of bytes or a byte buffer.
	* The cipher is initialized to use 128 effective key bits.
	*
	* @param key the symmetric key to use.
	* @param iv the initialization vector to use.
	* @param output the buffer to write to, null to create one.
	*
	* @return the cipher.
	*/
	forge.rc2.startDecrypting = function(key, iv, output) {
		var cipher = forge.rc2.createDecryptionCipher(key, 128);
		cipher.start(iv, output);
		return cipher;
	};
	/**
	* Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
	* given symmetric key.
	*
	* The key may be given as a string of bytes or a byte buffer.
	*
	* To start decrypting call start() on the cipher with an iv and optional
	* output buffer.
	*
	* @param key the symmetric key to use.
	*
	* @return the cipher.
	*/
	forge.rc2.createDecryptionCipher = function(key, bits) {
		return createCipher(key, bits, false);
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/jsbn.js
var require_jsbn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var forge = require_forge();
	module.exports = forge.jsbn = forge.jsbn || {};
	var dbits;
	var j_lm = true;
	function BigInteger(a, b, c) {
		this.data = [];
		if (a != null) if ("number" == typeof a) this.fromNumber(a, b, c);
		else if (b == null && "string" != typeof a) this.fromString(a, 256);
		else this.fromString(a, b);
	}
	forge.jsbn.BigInteger = BigInteger;
	function nbi() {
		return new BigInteger(null);
	}
	function am1(i, x, w, j, c, n) {
		while (--n >= 0) {
			var v = x * this.data[i++] + w.data[j] + c;
			c = Math.floor(v / 67108864);
			w.data[j++] = v & 67108863;
		}
		return c;
	}
	function am2(i, x, w, j, c, n) {
		var xl = x & 32767, xh = x >> 15;
		while (--n >= 0) {
			var l = this.data[i] & 32767;
			var h = this.data[i++] >> 15;
			var m = xh * l + h * xl;
			l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
			c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
			w.data[j++] = l & 1073741823;
		}
		return c;
	}
	function am3(i, x, w, j, c, n) {
		var xl = x & 16383, xh = x >> 14;
		while (--n >= 0) {
			var l = this.data[i] & 16383;
			var h = this.data[i++] >> 14;
			var m = xh * l + h * xl;
			l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
			c = (l >> 28) + (m >> 14) + xh * h;
			w.data[j++] = l & 268435455;
		}
		return c;
	}
	if (typeof navigator === "undefined") {
		BigInteger.prototype.am = am3;
		dbits = 28;
	} else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
		BigInteger.prototype.am = am2;
		dbits = 30;
	} else if (j_lm && navigator.appName != "Netscape") {
		BigInteger.prototype.am = am1;
		dbits = 26;
	} else {
		BigInteger.prototype.am = am3;
		dbits = 28;
	}
	BigInteger.prototype.DB = dbits;
	BigInteger.prototype.DM = (1 << dbits) - 1;
	BigInteger.prototype.DV = 1 << dbits;
	var BI_FP = 52;
	BigInteger.prototype.FV = Math.pow(2, BI_FP);
	BigInteger.prototype.F1 = BI_FP - dbits;
	BigInteger.prototype.F2 = 2 * dbits - BI_FP;
	var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	var BI_RC = new Array();
	var rr = "0".charCodeAt(0), vv;
	for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
	rr = "a".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	rr = "A".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	function int2char(n) {
		return BI_RM.charAt(n);
	}
	function intAt(s, i) {
		var c = BI_RC[s.charCodeAt(i)];
		return c == null ? -1 : c;
	}
	function bnpCopyTo(r) {
		for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
		r.t = this.t;
		r.s = this.s;
	}
	function bnpFromInt(x) {
		this.t = 1;
		this.s = x < 0 ? -1 : 0;
		if (x > 0) this.data[0] = x;
		else if (x < -1) this.data[0] = x + this.DV;
		else this.t = 0;
	}
	function nbv(i) {
		var r = nbi();
		r.fromInt(i);
		return r;
	}
	function bnpFromString(s, b) {
		var k;
		if (b == 16) k = 4;
		else if (b == 8) k = 3;
		else if (b == 256) k = 8;
		else if (b == 2) k = 1;
		else if (b == 32) k = 5;
		else if (b == 4) k = 2;
		else {
			this.fromRadix(s, b);
			return;
		}
		this.t = 0;
		this.s = 0;
		var i = s.length, mi = false, sh = 0;
		while (--i >= 0) {
			var x = k == 8 ? s[i] & 255 : intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-") mi = true;
				continue;
			}
			mi = false;
			if (sh == 0) this.data[this.t++] = x;
			else if (sh + k > this.DB) {
				this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
				this.data[this.t++] = x >> this.DB - sh;
			} else this.data[this.t - 1] |= x << sh;
			sh += k;
			if (sh >= this.DB) sh -= this.DB;
		}
		if (k == 8 && (s[0] & 128) != 0) {
			this.s = -1;
			if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
		}
		this.clamp();
		if (mi) BigInteger.ZERO.subTo(this, this);
	}
	function bnpClamp() {
		var c = this.s & this.DM;
		while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
	}
	function bnToString(b) {
		if (this.s < 0) return "-" + this.negate().toString(b);
		var k;
		if (b == 16) k = 4;
		else if (b == 8) k = 3;
		else if (b == 2) k = 1;
		else if (b == 32) k = 5;
		else if (b == 4) k = 2;
		else return this.toRadix(b);
		var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
		var p = this.DB - i * this.DB % k;
		if (i-- > 0) {
			if (p < this.DB && (d = this.data[i] >> p) > 0) {
				m = true;
				r = int2char(d);
			}
			while (i >= 0) {
				if (p < k) {
					d = (this.data[i] & (1 << p) - 1) << k - p;
					d |= this.data[--i] >> (p += this.DB - k);
				} else {
					d = this.data[i] >> (p -= k) & km;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if (d > 0) m = true;
				if (m) r += int2char(d);
			}
		}
		return m ? r : "0";
	}
	function bnNegate() {
		var r = nbi();
		BigInteger.ZERO.subTo(this, r);
		return r;
	}
	function bnAbs() {
		return this.s < 0 ? this.negate() : this;
	}
	function bnCompareTo(a) {
		var r = this.s - a.s;
		if (r != 0) return r;
		var i = this.t;
		r = i - a.t;
		if (r != 0) return this.s < 0 ? -r : r;
		while (--i >= 0) if ((r = this.data[i] - a.data[i]) != 0) return r;
		return 0;
	}
	function nbits(x) {
		var r = 1, t;
		if ((t = x >>> 16) != 0) {
			x = t;
			r += 16;
		}
		if ((t = x >> 8) != 0) {
			x = t;
			r += 8;
		}
		if ((t = x >> 4) != 0) {
			x = t;
			r += 4;
		}
		if ((t = x >> 2) != 0) {
			x = t;
			r += 2;
		}
		if ((t = x >> 1) != 0) {
			x = t;
			r += 1;
		}
		return r;
	}
	function bnBitLength() {
		if (this.t <= 0) return 0;
		return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
	}
	function bnpDLShiftTo(n, r) {
		var i;
		for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
		for (i = n - 1; i >= 0; --i) r.data[i] = 0;
		r.t = this.t + n;
		r.s = this.s;
	}
	function bnpDRShiftTo(n, r) {
		for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
		r.t = Math.max(this.t - n, 0);
		r.s = this.s;
	}
	function bnpLShiftTo(n, r) {
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << cbs) - 1;
		var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
		for (i = this.t - 1; i >= 0; --i) {
			r.data[i + ds + 1] = this.data[i] >> cbs | c;
			c = (this.data[i] & bm) << bs;
		}
		for (i = ds - 1; i >= 0; --i) r.data[i] = 0;
		r.data[ds] = c;
		r.t = this.t + ds + 1;
		r.s = this.s;
		r.clamp();
	}
	function bnpRShiftTo(n, r) {
		r.s = this.s;
		var ds = Math.floor(n / this.DB);
		if (ds >= this.t) {
			r.t = 0;
			return;
		}
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << bs) - 1;
		r.data[0] = this.data[ds] >> bs;
		for (var i = ds + 1; i < this.t; ++i) {
			r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
			r.data[i - ds] = this.data[i] >> bs;
		}
		if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
		r.t = this.t - ds;
		r.clamp();
	}
	function bnpSubTo(a, r) {
		var i = 0, c = 0, m = Math.min(a.t, this.t);
		while (i < m) {
			c += this.data[i] - a.data[i];
			r.data[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c -= a.s;
			while (i < this.t) {
				c += this.data[i];
				r.data[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c -= a.data[i];
				r.data[i++] = c & this.DM;
				c >>= this.DB;
			}
			c -= a.s;
		}
		r.s = c < 0 ? -1 : 0;
		if (c < -1) r.data[i++] = this.DV + c;
		else if (c > 0) r.data[i++] = c;
		r.t = i;
		r.clamp();
	}
	function bnpMultiplyTo(a, r) {
		var x = this.abs(), y = a.abs();
		var i = x.t;
		r.t = i + y.t;
		while (--i >= 0) r.data[i] = 0;
		for (i = 0; i < y.t; ++i) r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
		r.s = 0;
		r.clamp();
		if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
	}
	function bnpSquareTo(r) {
		var x = this.abs();
		var i = r.t = 2 * x.t;
		while (--i >= 0) r.data[i] = 0;
		for (i = 0; i < x.t - 1; ++i) {
			var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
			if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
				r.data[i + x.t] -= x.DV;
				r.data[i + x.t + 1] = 1;
			}
		}
		if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
		r.s = 0;
		r.clamp();
	}
	function bnpDivRemTo(m, q, r) {
		var pm = m.abs();
		if (pm.t <= 0) return;
		var pt = this.abs();
		if (pt.t < pm.t) {
			if (q != null) q.fromInt(0);
			if (r != null) this.copyTo(r);
			return;
		}
		if (r == null) r = nbi();
		var y = nbi(), ts = this.s, ms = m.s;
		var nsh = this.DB - nbits(pm.data[pm.t - 1]);
		if (nsh > 0) {
			pm.lShiftTo(nsh, y);
			pt.lShiftTo(nsh, r);
		} else {
			pm.copyTo(y);
			pt.copyTo(r);
		}
		var ys = y.t;
		var y0 = y.data[ys - 1];
		if (y0 == 0) return;
		var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
		var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
		var i = r.t, j = i - ys, t = q == null ? nbi() : q;
		y.dlShiftTo(j, t);
		if (r.compareTo(t) >= 0) {
			r.data[r.t++] = 1;
			r.subTo(t, r);
		}
		BigInteger.ONE.dlShiftTo(ys, t);
		t.subTo(y, y);
		while (y.t < ys) y.data[y.t++] = 0;
		while (--j >= 0) {
			var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
			if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
				y.dlShiftTo(j, t);
				r.subTo(t, r);
				while (r.data[i] < --qd) r.subTo(t, r);
			}
		}
		if (q != null) {
			r.drShiftTo(ys, q);
			if (ts != ms) BigInteger.ZERO.subTo(q, q);
		}
		r.t = ys;
		r.clamp();
		if (nsh > 0) r.rShiftTo(nsh, r);
		if (ts < 0) BigInteger.ZERO.subTo(r, r);
	}
	function bnMod(a) {
		var r = nbi();
		this.abs().divRemTo(a, null, r);
		if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
		return r;
	}
	function Classic(m) {
		this.m = m;
	}
	function cConvert(x) {
		if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
		else return x;
	}
	function cRevert(x) {
		return x;
	}
	function cReduce(x) {
		x.divRemTo(this.m, null, x);
	}
	function cMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	function cSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	}
	Classic.prototype.convert = cConvert;
	Classic.prototype.revert = cRevert;
	Classic.prototype.reduce = cReduce;
	Classic.prototype.mulTo = cMulTo;
	Classic.prototype.sqrTo = cSqrTo;
	function bnpInvDigit() {
		if (this.t < 1) return 0;
		var x = this.data[0];
		if ((x & 1) == 0) return 0;
		var y = x & 3;
		y = y * (2 - (x & 15) * y) & 15;
		y = y * (2 - (x & 255) * y) & 255;
		y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
		y = y * (2 - x * y % this.DV) % this.DV;
		return y > 0 ? this.DV - y : -y;
	}
	function Montgomery(m) {
		this.m = m;
		this.mp = m.invDigit();
		this.mpl = this.mp & 32767;
		this.mph = this.mp >> 15;
		this.um = (1 << m.DB - 15) - 1;
		this.mt2 = 2 * m.t;
	}
	function montConvert(x) {
		var r = nbi();
		x.abs().dlShiftTo(this.m.t, r);
		r.divRemTo(this.m, null, r);
		if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
		return r;
	}
	function montRevert(x) {
		var r = nbi();
		x.copyTo(r);
		this.reduce(r);
		return r;
	}
	function montReduce(x) {
		while (x.t <= this.mt2) x.data[x.t++] = 0;
		for (var i = 0; i < this.m.t; ++i) {
			var j = x.data[i] & 32767;
			var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
			j = i + this.m.t;
			x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
			while (x.data[j] >= x.DV) {
				x.data[j] -= x.DV;
				x.data[++j]++;
			}
		}
		x.clamp();
		x.drShiftTo(this.m.t, x);
		if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	}
	function montSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	}
	function montMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	Montgomery.prototype.convert = montConvert;
	Montgomery.prototype.revert = montRevert;
	Montgomery.prototype.reduce = montReduce;
	Montgomery.prototype.mulTo = montMulTo;
	Montgomery.prototype.sqrTo = montSqrTo;
	function bnpIsEven() {
		return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
	}
	function bnpExp(e, z) {
		if (e > 4294967295 || e < 1) return BigInteger.ONE;
		var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
		g.copyTo(r);
		while (--i >= 0) {
			z.sqrTo(r, r2);
			if ((e & 1 << i) > 0) z.mulTo(r2, g, r);
			else {
				var t = r;
				r = r2;
				r2 = t;
			}
		}
		return z.revert(r);
	}
	function bnModPowInt(e, m) {
		var z;
		if (e < 256 || m.isEven()) z = new Classic(m);
		else z = new Montgomery(m);
		return this.exp(e, z);
	}
	BigInteger.prototype.copyTo = bnpCopyTo;
	BigInteger.prototype.fromInt = bnpFromInt;
	BigInteger.prototype.fromString = bnpFromString;
	BigInteger.prototype.clamp = bnpClamp;
	BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
	BigInteger.prototype.drShiftTo = bnpDRShiftTo;
	BigInteger.prototype.lShiftTo = bnpLShiftTo;
	BigInteger.prototype.rShiftTo = bnpRShiftTo;
	BigInteger.prototype.subTo = bnpSubTo;
	BigInteger.prototype.multiplyTo = bnpMultiplyTo;
	BigInteger.prototype.squareTo = bnpSquareTo;
	BigInteger.prototype.divRemTo = bnpDivRemTo;
	BigInteger.prototype.invDigit = bnpInvDigit;
	BigInteger.prototype.isEven = bnpIsEven;
	BigInteger.prototype.exp = bnpExp;
	BigInteger.prototype.toString = bnToString;
	BigInteger.prototype.negate = bnNegate;
	BigInteger.prototype.abs = bnAbs;
	BigInteger.prototype.compareTo = bnCompareTo;
	BigInteger.prototype.bitLength = bnBitLength;
	BigInteger.prototype.mod = bnMod;
	BigInteger.prototype.modPowInt = bnModPowInt;
	BigInteger.ZERO = nbv(0);
	BigInteger.ONE = nbv(1);
	function bnClone() {
		var r = nbi();
		this.copyTo(r);
		return r;
	}
	function bnIntValue() {
		if (this.s < 0) {
			if (this.t == 1) return this.data[0] - this.DV;
			else if (this.t == 0) return -1;
		} else if (this.t == 1) return this.data[0];
		else if (this.t == 0) return 0;
		return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
	}
	function bnByteValue() {
		return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
	}
	function bnShortValue() {
		return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
	}
	function bnpChunkSize(r) {
		return Math.floor(Math.LN2 * this.DB / Math.log(r));
	}
	function bnSigNum() {
		if (this.s < 0) return -1;
		else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
		else return 1;
	}
	function bnpToRadix(b) {
		if (b == null) b = 10;
		if (this.signum() == 0 || b < 2 || b > 36) return "0";
		var cs = this.chunkSize(b);
		var a = Math.pow(b, cs);
		var d = nbv(a), y = nbi(), z = nbi(), r = "";
		this.divRemTo(d, y, z);
		while (y.signum() > 0) {
			r = (a + z.intValue()).toString(b).substr(1) + r;
			y.divRemTo(d, y, z);
		}
		return z.intValue().toString(b) + r;
	}
	function bnpFromRadix(s, b) {
		this.fromInt(0);
		if (b == null) b = 10;
		var cs = this.chunkSize(b);
		var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
		for (var i = 0; i < s.length; ++i) {
			var x = intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
				continue;
			}
			w = b * w + x;
			if (++j >= cs) {
				this.dMultiply(d);
				this.dAddOffset(w, 0);
				j = 0;
				w = 0;
			}
		}
		if (j > 0) {
			this.dMultiply(Math.pow(b, j));
			this.dAddOffset(w, 0);
		}
		if (mi) BigInteger.ZERO.subTo(this, this);
	}
	function bnpFromNumber(a, b, c) {
		if ("number" == typeof b) if (a < 2) this.fromInt(1);
		else {
			this.fromNumber(a, c);
			if (!this.testBit(a - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
			if (this.isEven()) this.dAddOffset(1, 0);
			while (!this.isProbablePrime(b)) {
				this.dAddOffset(2, 0);
				if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
			}
		}
		else {
			var x = new Array(), t = a & 7;
			x.length = (a >> 3) + 1;
			b.nextBytes(x);
			if (t > 0) x[0] &= (1 << t) - 1;
			else x[0] = 0;
			this.fromString(x, 256);
		}
	}
	function bnToByteArray() {
		var i = this.t, r = new Array();
		r[0] = this.s;
		var p = this.DB - i * this.DB % 8, d, k = 0;
		if (i-- > 0) {
			if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;
			while (i >= 0) {
				if (p < 8) {
					d = (this.data[i] & (1 << p) - 1) << 8 - p;
					d |= this.data[--i] >> (p += this.DB - 8);
				} else {
					d = this.data[i] >> (p -= 8) & 255;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if ((d & 128) != 0) d |= -256;
				if (k == 0 && (this.s & 128) != (d & 128)) ++k;
				if (k > 0 || d != this.s) r[k++] = d;
			}
		}
		return r;
	}
	function bnEquals(a) {
		return this.compareTo(a) == 0;
	}
	function bnMin(a) {
		return this.compareTo(a) < 0 ? this : a;
	}
	function bnMax(a) {
		return this.compareTo(a) > 0 ? this : a;
	}
	function bnpBitwiseTo(a, op, r) {
		var i, f, m = Math.min(a.t, this.t);
		for (i = 0; i < m; ++i) r.data[i] = op(this.data[i], a.data[i]);
		if (a.t < this.t) {
			f = a.s & this.DM;
			for (i = m; i < this.t; ++i) r.data[i] = op(this.data[i], f);
			r.t = this.t;
		} else {
			f = this.s & this.DM;
			for (i = m; i < a.t; ++i) r.data[i] = op(f, a.data[i]);
			r.t = a.t;
		}
		r.s = op(this.s, a.s);
		r.clamp();
	}
	function op_and(x, y) {
		return x & y;
	}
	function bnAnd(a) {
		var r = nbi();
		this.bitwiseTo(a, op_and, r);
		return r;
	}
	function op_or(x, y) {
		return x | y;
	}
	function bnOr(a) {
		var r = nbi();
		this.bitwiseTo(a, op_or, r);
		return r;
	}
	function op_xor(x, y) {
		return x ^ y;
	}
	function bnXor(a) {
		var r = nbi();
		this.bitwiseTo(a, op_xor, r);
		return r;
	}
	function op_andnot(x, y) {
		return x & ~y;
	}
	function bnAndNot(a) {
		var r = nbi();
		this.bitwiseTo(a, op_andnot, r);
		return r;
	}
	function bnNot() {
		var r = nbi();
		for (var i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
		r.t = this.t;
		r.s = ~this.s;
		return r;
	}
	function bnShiftLeft(n) {
		var r = nbi();
		if (n < 0) this.rShiftTo(-n, r);
		else this.lShiftTo(n, r);
		return r;
	}
	function bnShiftRight(n) {
		var r = nbi();
		if (n < 0) this.lShiftTo(-n, r);
		else this.rShiftTo(n, r);
		return r;
	}
	function lbit(x) {
		if (x == 0) return -1;
		var r = 0;
		if ((x & 65535) == 0) {
			x >>= 16;
			r += 16;
		}
		if ((x & 255) == 0) {
			x >>= 8;
			r += 8;
		}
		if ((x & 15) == 0) {
			x >>= 4;
			r += 4;
		}
		if ((x & 3) == 0) {
			x >>= 2;
			r += 2;
		}
		if ((x & 1) == 0) ++r;
		return r;
	}
	function bnGetLowestSetBit() {
		for (var i = 0; i < this.t; ++i) if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
		if (this.s < 0) return this.t * this.DB;
		return -1;
	}
	function cbit(x) {
		var r = 0;
		while (x != 0) {
			x &= x - 1;
			++r;
		}
		return r;
	}
	function bnBitCount() {
		var r = 0, x = this.s & this.DM;
		for (var i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
		return r;
	}
	function bnTestBit(n) {
		var j = Math.floor(n / this.DB);
		if (j >= this.t) return this.s != 0;
		return (this.data[j] & 1 << n % this.DB) != 0;
	}
	function bnpChangeBit(n, op) {
		var r = BigInteger.ONE.shiftLeft(n);
		this.bitwiseTo(r, op, r);
		return r;
	}
	function bnSetBit(n) {
		return this.changeBit(n, op_or);
	}
	function bnClearBit(n) {
		return this.changeBit(n, op_andnot);
	}
	function bnFlipBit(n) {
		return this.changeBit(n, op_xor);
	}
	function bnpAddTo(a, r) {
		var i = 0, c = 0, m = Math.min(a.t, this.t);
		while (i < m) {
			c += this.data[i] + a.data[i];
			r.data[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c += a.s;
			while (i < this.t) {
				c += this.data[i];
				r.data[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c += a.data[i];
				r.data[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += a.s;
		}
		r.s = c < 0 ? -1 : 0;
		if (c > 0) r.data[i++] = c;
		else if (c < -1) r.data[i++] = this.DV + c;
		r.t = i;
		r.clamp();
	}
	function bnAdd(a) {
		var r = nbi();
		this.addTo(a, r);
		return r;
	}
	function bnSubtract(a) {
		var r = nbi();
		this.subTo(a, r);
		return r;
	}
	function bnMultiply(a) {
		var r = nbi();
		this.multiplyTo(a, r);
		return r;
	}
	function bnDivide(a) {
		var r = nbi();
		this.divRemTo(a, r, null);
		return r;
	}
	function bnRemainder(a) {
		var r = nbi();
		this.divRemTo(a, null, r);
		return r;
	}
	function bnDivideAndRemainder(a) {
		var q = nbi(), r = nbi();
		this.divRemTo(a, q, r);
		return new Array(q, r);
	}
	function bnpDMultiply(n) {
		this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
		++this.t;
		this.clamp();
	}
	function bnpDAddOffset(n, w) {
		if (n == 0) return;
		while (this.t <= w) this.data[this.t++] = 0;
		this.data[w] += n;
		while (this.data[w] >= this.DV) {
			this.data[w] -= this.DV;
			if (++w >= this.t) this.data[this.t++] = 0;
			++this.data[w];
		}
	}
	function NullExp() {}
	function nNop(x) {
		return x;
	}
	function nMulTo(x, y, r) {
		x.multiplyTo(y, r);
	}
	function nSqrTo(x, r) {
		x.squareTo(r);
	}
	NullExp.prototype.convert = nNop;
	NullExp.prototype.revert = nNop;
	NullExp.prototype.mulTo = nMulTo;
	NullExp.prototype.sqrTo = nSqrTo;
	function bnPow(e) {
		return this.exp(e, new NullExp());
	}
	function bnpMultiplyLowerTo(a, n, r) {
		var i = Math.min(this.t + a.t, n);
		r.s = 0;
		r.t = i;
		while (i > 0) r.data[--i] = 0;
		var j;
		for (j = r.t - this.t; i < j; ++i) r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
		for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a.data[i], r, i, 0, n - i);
		r.clamp();
	}
	function bnpMultiplyUpperTo(a, n, r) {
		--n;
		var i = r.t = this.t + a.t - n;
		r.s = 0;
		while (--i >= 0) r.data[i] = 0;
		for (i = Math.max(n - this.t, 0); i < a.t; ++i) r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
		r.clamp();
		r.drShiftTo(1, r);
	}
	function Barrett(m) {
		this.r2 = nbi();
		this.q3 = nbi();
		BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
		this.mu = this.r2.divide(m);
		this.m = m;
	}
	function barrettConvert(x) {
		if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
		else if (x.compareTo(this.m) < 0) return x;
		else {
			var r = nbi();
			x.copyTo(r);
			this.reduce(r);
			return r;
		}
	}
	function barrettRevert(x) {
		return x;
	}
	function barrettReduce(x) {
		x.drShiftTo(this.m.t - 1, this.r2);
		if (x.t > this.m.t + 1) {
			x.t = this.m.t + 1;
			x.clamp();
		}
		this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
		this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
		while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
		x.subTo(this.r2, x);
		while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	}
	function barrettSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	}
	function barrettMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	}
	Barrett.prototype.convert = barrettConvert;
	Barrett.prototype.revert = barrettRevert;
	Barrett.prototype.reduce = barrettReduce;
	Barrett.prototype.mulTo = barrettMulTo;
	Barrett.prototype.sqrTo = barrettSqrTo;
	function bnModPow(e, m) {
		var i = e.bitLength(), k, r = nbv(1), z;
		if (i <= 0) return r;
		else if (i < 18) k = 1;
		else if (i < 48) k = 3;
		else if (i < 144) k = 4;
		else if (i < 768) k = 5;
		else k = 6;
		if (i < 8) z = new Classic(m);
		else if (m.isEven()) z = new Barrett(m);
		else z = new Montgomery(m);
		var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
		g[1] = z.convert(this);
		if (k > 1) {
			var g2 = nbi();
			z.sqrTo(g[1], g2);
			while (n <= km) {
				g[n] = nbi();
				z.mulTo(g2, g[n - 2], g[n]);
				n += 2;
			}
		}
		var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
		i = nbits(e.data[j]) - 1;
		while (j >= 0) {
			if (i >= k1) w = e.data[j] >> i - k1 & km;
			else {
				w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
				if (j > 0) w |= e.data[j - 1] >> this.DB + i - k1;
			}
			n = k;
			while ((w & 1) == 0) {
				w >>= 1;
				--n;
			}
			if ((i -= n) < 0) {
				i += this.DB;
				--j;
			}
			if (is1) {
				g[w].copyTo(r);
				is1 = false;
			} else {
				while (n > 1) {
					z.sqrTo(r, r2);
					z.sqrTo(r2, r);
					n -= 2;
				}
				if (n > 0) z.sqrTo(r, r2);
				else {
					t = r;
					r = r2;
					r2 = t;
				}
				z.mulTo(r2, g[w], r);
			}
			while (j >= 0 && (e.data[j] & 1 << i) == 0) {
				z.sqrTo(r, r2);
				t = r;
				r = r2;
				r2 = t;
				if (--i < 0) {
					i = this.DB - 1;
					--j;
				}
			}
		}
		return z.revert(r);
	}
	function bnGCD(a) {
		var x = this.s < 0 ? this.negate() : this.clone();
		var y = a.s < 0 ? a.negate() : a.clone();
		if (x.compareTo(y) < 0) {
			var t = x;
			x = y;
			y = t;
		}
		var i = x.getLowestSetBit(), g = y.getLowestSetBit();
		if (g < 0) return x;
		if (i < g) g = i;
		if (g > 0) {
			x.rShiftTo(g, x);
			y.rShiftTo(g, y);
		}
		while (x.signum() > 0) {
			if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
			if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
			if (x.compareTo(y) >= 0) {
				x.subTo(y, x);
				x.rShiftTo(1, x);
			} else {
				y.subTo(x, y);
				y.rShiftTo(1, y);
			}
		}
		if (g > 0) y.lShiftTo(g, y);
		return y;
	}
	function bnpModInt(n) {
		if (n <= 0) return 0;
		var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
		if (this.t > 0) if (d == 0) r = this.data[0] % n;
		else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this.data[i]) % n;
		return r;
	}
	function bnModInverse(m) {
		var ac = m.isEven();
		if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
		var u = m.clone(), v = this.clone();
		var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
		while (u.signum() != 0) {
			while (u.isEven()) {
				u.rShiftTo(1, u);
				if (ac) {
					if (!a.isEven() || !b.isEven()) {
						a.addTo(this, a);
						b.subTo(m, b);
					}
					a.rShiftTo(1, a);
				} else if (!b.isEven()) b.subTo(m, b);
				b.rShiftTo(1, b);
			}
			while (v.isEven()) {
				v.rShiftTo(1, v);
				if (ac) {
					if (!c.isEven() || !d.isEven()) {
						c.addTo(this, c);
						d.subTo(m, d);
					}
					c.rShiftTo(1, c);
				} else if (!d.isEven()) d.subTo(m, d);
				d.rShiftTo(1, d);
			}
			if (u.compareTo(v) >= 0) {
				u.subTo(v, u);
				if (ac) a.subTo(c, a);
				b.subTo(d, b);
			} else {
				v.subTo(u, v);
				if (ac) c.subTo(a, c);
				d.subTo(b, d);
			}
		}
		if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
		if (d.compareTo(m) >= 0) return d.subtract(m);
		if (d.signum() < 0) d.addTo(m, d);
		else return d;
		if (d.signum() < 0) return d.add(m);
		else return d;
	}
	var lowprimes = [
		2,
		3,
		5,
		7,
		11,
		13,
		17,
		19,
		23,
		29,
		31,
		37,
		41,
		43,
		47,
		53,
		59,
		61,
		67,
		71,
		73,
		79,
		83,
		89,
		97,
		101,
		103,
		107,
		109,
		113,
		127,
		131,
		137,
		139,
		149,
		151,
		157,
		163,
		167,
		173,
		179,
		181,
		191,
		193,
		197,
		199,
		211,
		223,
		227,
		229,
		233,
		239,
		241,
		251,
		257,
		263,
		269,
		271,
		277,
		281,
		283,
		293,
		307,
		311,
		313,
		317,
		331,
		337,
		347,
		349,
		353,
		359,
		367,
		373,
		379,
		383,
		389,
		397,
		401,
		409,
		419,
		421,
		431,
		433,
		439,
		443,
		449,
		457,
		461,
		463,
		467,
		479,
		487,
		491,
		499,
		503,
		509
	];
	var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
	function bnIsProbablePrime(t) {
		var i, x = this.abs();
		if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
			for (i = 0; i < lowprimes.length; ++i) if (x.data[0] == lowprimes[i]) return true;
			return false;
		}
		if (x.isEven()) return false;
		i = 1;
		while (i < lowprimes.length) {
			var m = lowprimes[i], j = i + 1;
			while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
			m = x.modInt(m);
			while (i < j) if (m % lowprimes[i++] == 0) return false;
		}
		return x.millerRabin(t);
	}
	function bnpMillerRabin(t) {
		var n1 = this.subtract(BigInteger.ONE);
		var k = n1.getLowestSetBit();
		if (k <= 0) return false;
		var r = n1.shiftRight(k);
		var prng = bnGetPrng();
		var a;
		for (var i = 0; i < t; ++i) {
			do
				a = new BigInteger(this.bitLength(), prng);
			while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
			var y = a.modPow(r, this);
			if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
				var j = 1;
				while (j++ < k && y.compareTo(n1) != 0) {
					y = y.modPowInt(2, this);
					if (y.compareTo(BigInteger.ONE) == 0) return false;
				}
				if (y.compareTo(n1) != 0) return false;
			}
		}
		return true;
	}
	function bnGetPrng() {
		return { nextBytes: function(x) {
			for (var i = 0; i < x.length; ++i) x[i] = Math.floor(Math.random() * 256);
		} };
	}
	BigInteger.prototype.chunkSize = bnpChunkSize;
	BigInteger.prototype.toRadix = bnpToRadix;
	BigInteger.prototype.fromRadix = bnpFromRadix;
	BigInteger.prototype.fromNumber = bnpFromNumber;
	BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
	BigInteger.prototype.changeBit = bnpChangeBit;
	BigInteger.prototype.addTo = bnpAddTo;
	BigInteger.prototype.dMultiply = bnpDMultiply;
	BigInteger.prototype.dAddOffset = bnpDAddOffset;
	BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
	BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
	BigInteger.prototype.modInt = bnpModInt;
	BigInteger.prototype.millerRabin = bnpMillerRabin;
	BigInteger.prototype.clone = bnClone;
	BigInteger.prototype.intValue = bnIntValue;
	BigInteger.prototype.byteValue = bnByteValue;
	BigInteger.prototype.shortValue = bnShortValue;
	BigInteger.prototype.signum = bnSigNum;
	BigInteger.prototype.toByteArray = bnToByteArray;
	BigInteger.prototype.equals = bnEquals;
	BigInteger.prototype.min = bnMin;
	BigInteger.prototype.max = bnMax;
	BigInteger.prototype.and = bnAnd;
	BigInteger.prototype.or = bnOr;
	BigInteger.prototype.xor = bnXor;
	BigInteger.prototype.andNot = bnAndNot;
	BigInteger.prototype.not = bnNot;
	BigInteger.prototype.shiftLeft = bnShiftLeft;
	BigInteger.prototype.shiftRight = bnShiftRight;
	BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
	BigInteger.prototype.bitCount = bnBitCount;
	BigInteger.prototype.testBit = bnTestBit;
	BigInteger.prototype.setBit = bnSetBit;
	BigInteger.prototype.clearBit = bnClearBit;
	BigInteger.prototype.flipBit = bnFlipBit;
	BigInteger.prototype.add = bnAdd;
	BigInteger.prototype.subtract = bnSubtract;
	BigInteger.prototype.multiply = bnMultiply;
	BigInteger.prototype.divide = bnDivide;
	BigInteger.prototype.remainder = bnRemainder;
	BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
	BigInteger.prototype.modPow = bnModPow;
	BigInteger.prototype.modInverse = bnModInverse;
	BigInteger.prototype.pow = bnPow;
	BigInteger.prototype.gcd = bnGCD;
	BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/sha1.js
var require_sha1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2015 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
	forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
	/**
	* Creates a SHA-1 message digest object.
	*
	* @return a message digest object.
	*/
	sha1.create = function() {
		if (!_initialized) _init();
		var _state = null;
		var _input = forge.util.createBuffer();
		var _w = new Array(80);
		var md = {
			algorithm: "sha1",
			blockLength: 64,
			digestLength: 20,
			messageLength: 0,
			fullMessageLength: null,
			messageLengthSize: 8
		};
		/**
		* Starts the digest.
		*
		* @return this digest object.
		*/
		md.start = function() {
			md.messageLength = 0;
			md.fullMessageLength = md.messageLength64 = [];
			var int32s = md.messageLengthSize / 4;
			for (var i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
			_input = forge.util.createBuffer();
			_state = {
				h0: 1732584193,
				h1: 4023233417,
				h2: 2562383102,
				h3: 271733878,
				h4: 3285377520
			};
			return md;
		};
		md.start();
		/**
		* Updates the digest with the given message input. The given input can
		* treated as raw input (no encoding will be applied) or an encoding of
		* 'utf8' maybe given to encode the input using UTF-8.
		*
		* @param msg the message input to update with.
		* @param encoding the encoding to use (default: 'raw', other: 'utf8').
		*
		* @return this digest object.
		*/
		md.update = function(msg, encoding) {
			if (encoding === "utf8") msg = forge.util.encodeUtf8(msg);
			var len = msg.length;
			md.messageLength += len;
			len = [len / 4294967296 >>> 0, len >>> 0];
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				md.fullMessageLength[i] += len[1];
				len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
				md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
				len[0] = len[1] / 4294967296 >>> 0;
			}
			_input.putBytes(msg);
			_update(_state, _w, _input);
			if (_input.read > 2048 || _input.length() === 0) _input.compact();
			return md;
		};
		/**
		* Produces the digest.
		*
		* @return a byte buffer containing the digest value.
		*/
		md.digest = function() {
			var finalBlock = forge.util.createBuffer();
			finalBlock.putBytes(_input.bytes());
			var overflow = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize & md.blockLength - 1;
			finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
			var next, carry;
			var bits = md.fullMessageLength[0] * 8;
			for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
				next = md.fullMessageLength[i + 1] * 8;
				carry = next / 4294967296 >>> 0;
				bits += carry;
				finalBlock.putInt32(bits >>> 0);
				bits = next >>> 0;
			}
			finalBlock.putInt32(bits);
			var s2 = {
				h0: _state.h0,
				h1: _state.h1,
				h2: _state.h2,
				h3: _state.h3,
				h4: _state.h4
			};
			_update(s2, _w, finalBlock);
			var rval = forge.util.createBuffer();
			rval.putInt32(s2.h0);
			rval.putInt32(s2.h1);
			rval.putInt32(s2.h2);
			rval.putInt32(s2.h3);
			rval.putInt32(s2.h4);
			return rval;
		};
		return md;
	};
	var _padding = null;
	var _initialized = false;
	/**
	* Initializes the constant tables.
	*/
	function _init() {
		_padding = String.fromCharCode(128);
		_padding += forge.util.fillString(String.fromCharCode(0), 64);
		_initialized = true;
	}
	/**
	* Updates a SHA-1 state with the given byte buffer.
	*
	* @param s the SHA-1 state to update.
	* @param w the array to use to store words.
	* @param bytes the byte buffer to update with.
	*/
	function _update(s, w, bytes) {
		var t, a, b, c, d, e, f, i;
		var len = bytes.length();
		while (len >= 64) {
			a = s.h0;
			b = s.h1;
			c = s.h2;
			d = s.h3;
			e = s.h4;
			for (i = 0; i < 16; ++i) {
				t = bytes.getInt32();
				w[i] = t;
				f = d ^ b & (c ^ d);
				t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 20; ++i) {
				t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
				t = t << 1 | t >>> 31;
				w[i] = t;
				f = d ^ b & (c ^ d);
				t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 32; ++i) {
				t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
				t = t << 1 | t >>> 31;
				w[i] = t;
				f = b ^ c ^ d;
				t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 40; ++i) {
				t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
				t = t << 2 | t >>> 30;
				w[i] = t;
				f = b ^ c ^ d;
				t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 60; ++i) {
				t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
				t = t << 2 | t >>> 30;
				w[i] = t;
				f = b & c | d & (b ^ c);
				t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			for (; i < 80; ++i) {
				t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
				t = t << 2 | t >>> 30;
				w[i] = t;
				f = b ^ c ^ d;
				t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
				e = d;
				d = c;
				c = (b << 30 | b >>> 2) >>> 0;
				b = a;
				a = t;
			}
			s.h0 = s.h0 + a | 0;
			s.h1 = s.h1 + b | 0;
			s.h2 = s.h2 + c | 0;
			s.h3 = s.h3 + d | 0;
			s.h4 = s.h4 + e | 0;
			len -= 64;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Partial implementation of PKCS#1 v2.2: RSA-OEAP
	*
	* Modified but based on the following MIT and BSD licensed code:
	*
	* https://github.com/kjur/jsjws/blob/master/rsa.js:
	*
	* The 'jsjws'(JSON Web Signature JavaScript Library) License
	*
	* Copyright (c) 2012 Kenji Urushima
	*
	* Permission is hereby granted, free of charge, to any person obtaining a copy
	* of this software and associated documentation files (the "Software"), to deal
	* in the Software without restriction, including without limitation the rights
	* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	* copies of the Software, and to permit persons to whom the Software is
	* furnished to do so, subject to the following conditions:
	*
	* The above copyright notice and this permission notice shall be included in
	* all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	* THE SOFTWARE.
	*
	* http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:
	*
	* RSAES-OAEP.js
	* $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $
	* JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)
	* Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.
	* Contact: ellis@nukinetics.com
	* Distributed under the BSD License.
	*
	* Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125
	*
	* @author Evan Jones (http://evanjones.ca/)
	* @author Dave Longley
	*
	* Copyright (c) 2013-2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	require_random();
	require_sha1();
	var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};
	/**
	* Encode the given RSAES-OAEP message (M) using key, with optional label (L)
	* and seed.
	*
	* This method does not perform RSA encryption, it only encodes the message
	* using RSAES-OAEP.
	*
	* @param key the RSA key to use.
	* @param message the message to encode.
	* @param options the options to use:
	*          label an optional label to use.
	*          seed the seed to use.
	*          md the message digest object to use, undefined for SHA-1.
	*          mgf1 optional mgf1 parameters:
	*            md the message digest object to use for MGF1.
	*
	* @return the encoded message bytes.
	*/
	pkcs1.encode_rsa_oaep = function(key, message, options) {
		var label;
		var seed;
		var md;
		var mgf1Md;
		if (typeof options === "string") {
			label = options;
			seed = arguments[3] || void 0;
			md = arguments[4] || void 0;
		} else if (options) {
			label = options.label || void 0;
			seed = options.seed || void 0;
			md = options.md || void 0;
			if (options.mgf1 && options.mgf1.md) mgf1Md = options.mgf1.md;
		}
		if (!md) md = forge.md.sha1.create();
		else md.start();
		if (!mgf1Md) mgf1Md = md;
		var keyLength = Math.ceil(key.n.bitLength() / 8);
		var maxLength = keyLength - 2 * md.digestLength - 2;
		if (message.length > maxLength) {
			var error = /* @__PURE__ */ new Error("RSAES-OAEP input message length is too long.");
			error.length = message.length;
			error.maxLength = maxLength;
			throw error;
		}
		if (!label) label = "";
		md.update(label, "raw");
		var lHash = md.digest();
		var PS = "";
		var PS_length = maxLength - message.length;
		for (var i = 0; i < PS_length; i++) PS += "\0";
		var DB = lHash.getBytes() + PS + "" + message;
		if (!seed) seed = forge.random.getBytes(md.digestLength);
		else if (seed.length !== md.digestLength) {
			var error = /* @__PURE__ */ new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
			error.seedLength = seed.length;
			error.digestLength = md.digestLength;
			throw error;
		}
		var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
		var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
		var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
		return "\0" + forge.util.xorBytes(seed, seedMask, seed.length) + maskedDB;
	};
	/**
	* Decode the given RSAES-OAEP encoded message (EM) using key, with optional
	* label (L).
	*
	* This method does not perform RSA decryption, it only decodes the message
	* using RSAES-OAEP.
	*
	* @param key the RSA key to use.
	* @param em the encoded message to decode.
	* @param options the options to use:
	*          label an optional label to use.
	*          md the message digest object to use for OAEP, undefined for SHA-1.
	*          mgf1 optional mgf1 parameters:
	*            md the message digest object to use for MGF1.
	*
	* @return the decoded message bytes.
	*/
	pkcs1.decode_rsa_oaep = function(key, em, options) {
		var label;
		var md;
		var mgf1Md;
		if (typeof options === "string") {
			label = options;
			md = arguments[3] || void 0;
		} else if (options) {
			label = options.label || void 0;
			md = options.md || void 0;
			if (options.mgf1 && options.mgf1.md) mgf1Md = options.mgf1.md;
		}
		var keyLength = Math.ceil(key.n.bitLength() / 8);
		if (em.length !== keyLength) {
			var error = /* @__PURE__ */ new Error("RSAES-OAEP encoded message length is invalid.");
			error.length = em.length;
			error.expectedLength = keyLength;
			throw error;
		}
		if (md === void 0) md = forge.md.sha1.create();
		else md.start();
		if (!mgf1Md) mgf1Md = md;
		if (keyLength < 2 * md.digestLength + 2) throw new Error("RSAES-OAEP key is too short for the hash function.");
		if (!label) label = "";
		md.update(label, "raw");
		var lHash = md.digest().getBytes();
		var y = em.charAt(0);
		var maskedSeed = em.substring(1, md.digestLength + 1);
		var maskedDB = em.substring(1 + md.digestLength);
		var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
		var dbMask = rsa_mgf1(forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length), keyLength - md.digestLength - 1, mgf1Md);
		var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
		var lHashPrime = db.substring(0, md.digestLength);
		var error = y !== "\0";
		for (var i = 0; i < md.digestLength; ++i) error |= lHash.charAt(i) !== lHashPrime.charAt(i);
		var in_ps = 1;
		var index = md.digestLength;
		for (var j = md.digestLength; j < db.length; j++) {
			var code = db.charCodeAt(j);
			var is_0 = code & 1 ^ 1;
			error |= code & (in_ps ? 65534 : 0);
			in_ps = in_ps & is_0;
			index += in_ps;
		}
		if (error || db.charCodeAt(index) !== 1) throw new Error("Invalid RSAES-OAEP padding.");
		return db.substring(index + 1);
	};
	function rsa_mgf1(seed, maskLength, hash) {
		if (!hash) hash = forge.md.sha1.create();
		var t = "";
		var count = Math.ceil(maskLength / hash.digestLength);
		for (var i = 0; i < count; ++i) {
			var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
			hash.start();
			hash.update(seed + c);
			t += hash.digest().getBytes();
		}
		return t.substring(0, maskLength);
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/prime.js
var require_prime = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Prime number generation API.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	require_jsbn();
	require_random();
	(function() {
		if (forge.prime) {
			module.exports = forge.prime;
			return;
		}
		var prime = module.exports = forge.prime = forge.prime || {};
		var BigInteger = forge.jsbn.BigInteger;
		var GCD_30_DELTA = [
			6,
			4,
			2,
			4,
			2,
			4,
			6,
			2
		];
		var THIRTY = new BigInteger(null);
		THIRTY.fromInt(30);
		var op_or = function(x, y) {
			return x | y;
		};
		/**
		* Generates a random probable prime with the given number of bits.
		*
		* Alternative algorithms can be specified by name as a string or as an
		* object with custom options like so:
		*
		* {
		*   name: 'PRIMEINC',
		*   options: {
		*     maxBlockTime: <the maximum amount of time to block the main
		*       thread before allowing I/O other JS to run>,
		*     millerRabinTests: <the number of miller-rabin tests to run>,
		*     workerScript: <the worker script URL>,
		*     workers: <the number of web workers (if supported) to use,
		*       -1 to use estimated cores minus one>.
		*     workLoad: the size of the work load, ie: number of possible prime
		*       numbers for each web worker to check per work assignment,
		*       (default: 100).
		*   }
		* }
		*
		* @param bits the number of bits for the prime number.
		* @param options the options to use.
		*          [algorithm] the algorithm to use (default: 'PRIMEINC').
		*          [prng] a custom crypto-secure pseudo-random number generator to use,
		*            that must define "getBytesSync".
		*
		* @return callback(err, num) called once the operation completes.
		*/
		prime.generateProbablePrime = function(bits, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = {};
			}
			options = options || {};
			var algorithm = options.algorithm || "PRIMEINC";
			if (typeof algorithm === "string") algorithm = { name: algorithm };
			algorithm.options = algorithm.options || {};
			var prng = options.prng || forge.random;
			var rng = { nextBytes: function(x) {
				var b = prng.getBytesSync(x.length);
				for (var i = 0; i < x.length; ++i) x[i] = b.charCodeAt(i);
			} };
			if (algorithm.name === "PRIMEINC") return primeincFindPrime(bits, rng, algorithm.options, callback);
			throw new Error("Invalid prime generation algorithm: " + algorithm.name);
		};
		function primeincFindPrime(bits, rng, options, callback) {
			if ("workers" in options) return primeincFindPrimeWithWorkers(bits, rng, options, callback);
			return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
		}
		function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
			var num = generateRandom(bits, rng);
			var deltaIdx = 0;
			var mrTests = getMillerRabinTests(num.bitLength());
			if ("millerRabinTests" in options) mrTests = options.millerRabinTests;
			var maxBlockTime = 10;
			if ("maxBlockTime" in options) maxBlockTime = options.maxBlockTime;
			_primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
		}
		function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
			var start = +/* @__PURE__ */ new Date();
			do {
				if (num.bitLength() > bits) num = generateRandom(bits, rng);
				if (num.isProbablePrime(mrTests)) return callback(null, num);
				num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
			} while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
			forge.util.setImmediate(function() {
				_primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
			});
		}
		function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
			if (typeof Worker === "undefined") return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
			var num = generateRandom(bits, rng);
			var numWorkers = options.workers;
			var workLoad = options.workLoad || 100;
			var range = workLoad * 30 / 8;
			var workerScript = options.workerScript || "forge/prime.worker.js";
			if (numWorkers === -1) return forge.util.estimateCores(function(err, cores) {
				if (err) cores = 2;
				numWorkers = cores - 1;
				generate();
			});
			generate();
			function generate() {
				numWorkers = Math.max(1, numWorkers);
				var workers = [];
				for (var i = 0; i < numWorkers; ++i) workers[i] = new Worker(workerScript);
				var running = numWorkers;
				for (var i = 0; i < numWorkers; ++i) workers[i].addEventListener("message", workerMessage);
				var found = false;
				function workerMessage(e) {
					if (found) return;
					--running;
					var data = e.data;
					if (data.found) {
						for (var i = 0; i < workers.length; ++i) workers[i].terminate();
						found = true;
						return callback(null, new BigInteger(data.prime, 16));
					}
					if (num.bitLength() > bits) num = generateRandom(bits, rng);
					var hex = num.toString(16);
					e.target.postMessage({
						hex,
						workLoad
					});
					num.dAddOffset(range, 0);
				}
			}
		}
		/**
		* Generates a random number using the given number of bits and RNG.
		*
		* @param bits the number of bits for the number.
		* @param rng the random number generator to use.
		*
		* @return the random number.
		*/
		function generateRandom(bits, rng) {
			var num = new BigInteger(bits, rng);
			var bits1 = bits - 1;
			if (!num.testBit(bits1)) num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
			num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
			return num;
		}
		/**
		* Returns the required number of Miller-Rabin tests to generate a
		* prime with an error probability of (1/2)^80.
		*
		* See Handbook of Applied Cryptography Chapter 4, Table 4.4.
		*
		* @param bits the bit size.
		*
		* @return the required number of iterations.
		*/
		function getMillerRabinTests(bits) {
			if (bits <= 100) return 27;
			if (bits <= 150) return 18;
			if (bits <= 200) return 15;
			if (bits <= 250) return 12;
			if (bits <= 300) return 9;
			if (bits <= 350) return 8;
			if (bits <= 400) return 7;
			if (bits <= 500) return 6;
			if (bits <= 600) return 5;
			if (bits <= 800) return 4;
			if (bits <= 1250) return 3;
			return 2;
		}
	})();
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/rsa.js
var require_rsa = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of basic RSA algorithms.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*
	* The only algorithm currently supported for PKI is RSA.
	*
	* An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo
	* ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier
	* and a subjectPublicKey of type bit string.
	*
	* The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
	* for the algorithm, if any. In the case of RSA, there aren't any.
	*
	* SubjectPublicKeyInfo ::= SEQUENCE {
	*   algorithm AlgorithmIdentifier,
	*   subjectPublicKey BIT STRING
	* }
	*
	* AlgorithmIdentifer ::= SEQUENCE {
	*   algorithm OBJECT IDENTIFIER,
	*   parameters ANY DEFINED BY algorithm OPTIONAL
	* }
	*
	* For an RSA public key, the subjectPublicKey is:
	*
	* RSAPublicKey ::= SEQUENCE {
	*   modulus            INTEGER,    -- n
	*   publicExponent     INTEGER     -- e
	* }
	*
	* PrivateKeyInfo ::= SEQUENCE {
	*   version                   Version,
	*   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
	*   privateKey                PrivateKey,
	*   attributes           [0]  IMPLICIT Attributes OPTIONAL
	* }
	*
	* Version ::= INTEGER
	* PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
	* PrivateKey ::= OCTET STRING
	* Attributes ::= SET OF Attribute
	*
	* An RSA private key as the following structure:
	*
	* RSAPrivateKey ::= SEQUENCE {
	*   version Version,
	*   modulus INTEGER, -- n
	*   publicExponent INTEGER, -- e
	*   privateExponent INTEGER, -- d
	*   prime1 INTEGER, -- p
	*   prime2 INTEGER, -- q
	*   exponent1 INTEGER, -- d mod (p-1)
	*   exponent2 INTEGER, -- d mod (q-1)
	*   coefficient INTEGER -- (inverse of q) mod p
	* }
	*
	* Version ::= INTEGER
	*
	* The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1
	*/
	var forge = require_forge();
	require_asn1();
	require_jsbn();
	require_oids();
	require_pkcs1();
	require_prime();
	require_random();
	require_util();
	if (typeof BigInteger === "undefined") var BigInteger = forge.jsbn.BigInteger;
	var _crypto = forge.util.isNodejs ? __require("crypto") : null;
	var asn1 = forge.asn1;
	var util = forge.util;
	forge.pki = forge.pki || {};
	module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
	var pki = forge.pki;
	var GCD_30_DELTA = [
		6,
		4,
		2,
		4,
		2,
		4,
		6,
		2
	];
	var privateKeyValidator = {
		name: "PrivateKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "PrivateKeyInfo.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyVersion"
			},
			{
				name: "PrivateKeyInfo.privateKeyAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "AlgorithmIdentifier.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "privateKeyOid"
				}]
			},
			{
				name: "PrivateKeyInfo",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "privateKey"
			}
		]
	};
	var rsaPrivateKeyValidator = {
		name: "RSAPrivateKey",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "RSAPrivateKey.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyVersion"
			},
			{
				name: "RSAPrivateKey.modulus",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyModulus"
			},
			{
				name: "RSAPrivateKey.publicExponent",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyPublicExponent"
			},
			{
				name: "RSAPrivateKey.privateExponent",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyPrivateExponent"
			},
			{
				name: "RSAPrivateKey.prime1",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyPrime1"
			},
			{
				name: "RSAPrivateKey.prime2",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyPrime2"
			},
			{
				name: "RSAPrivateKey.exponent1",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyExponent1"
			},
			{
				name: "RSAPrivateKey.exponent2",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyExponent2"
			},
			{
				name: "RSAPrivateKey.coefficient",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyCoefficient"
			}
		]
	};
	var rsaPublicKeyValidator = {
		name: "RSAPublicKey",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "RSAPublicKey.modulus",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "publicKeyModulus"
		}, {
			name: "RSAPublicKey.exponent",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "publicKeyExponent"
		}]
	};
	var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
		name: "SubjectPublicKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		captureAsn1: "subjectPublicKeyInfo",
		value: [{
			name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "AlgorithmIdentifier.algorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "publicKeyOid"
			}]
		}, {
			name: "SubjectPublicKeyInfo.subjectPublicKey",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.BITSTRING,
			constructed: false,
			value: [{
				name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				optional: true,
				captureAsn1: "rsaPublicKey"
			}]
		}]
	};
	var digestInfoValidator = {
		name: "DigestInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "DigestInfo.DigestAlgorithm",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "algorithmIdentifier"
			}, {
				name: "DigestInfo.DigestAlgorithm.parameters",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.NULL,
				capture: "parameters",
				optional: true,
				constructed: false
			}]
		}, {
			name: "DigestInfo.digest",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OCTETSTRING,
			constructed: false,
			capture: "digest"
		}]
	};
	/**
	* Wrap digest in DigestInfo object.
	*
	* This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.
	*
	* DigestInfo ::= SEQUENCE {
	*   digestAlgorithm DigestAlgorithmIdentifier,
	*   digest Digest
	* }
	*
	* DigestAlgorithmIdentifier ::= AlgorithmIdentifier
	* Digest ::= OCTET STRING
	*
	* @param md the message digest object with the hash to sign.
	*
	* @return the encoded message (ready for RSA encryption)
	*/
	var emsaPkcs1v15encode = function(md) {
		var oid;
		if (md.algorithm in pki.oids) oid = pki.oids[md.algorithm];
		else {
			var error = /* @__PURE__ */ new Error("Unknown message digest algorithm.");
			error.algorithm = md.algorithm;
			throw error;
		}
		var oidBytes = asn1.oidToDer(oid).getBytes();
		var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
		digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ""));
		var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
		digestInfo.value.push(digestAlgorithm);
		digestInfo.value.push(digest);
		return asn1.toDer(digestInfo).getBytes();
	};
	/**
	* Performs x^c mod n (RSA encryption or decryption operation).
	*
	* @param x the number to raise and mod.
	* @param key the key to use.
	* @param pub true if the key is public, false if private.
	*
	* @return the result of x^c mod n.
	*/
	var _modPow = function(x, key, pub) {
		if (pub) return x.modPow(key.e, key.n);
		if (!key.p || !key.q) return x.modPow(key.d, key.n);
		if (!key.dP) key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
		if (!key.dQ) key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
		if (!key.qInv) key.qInv = key.q.modInverse(key.p);
		var r;
		do
			r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
		while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
		x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
		var xp = x.mod(key.p).modPow(key.dP, key.p);
		var xq = x.mod(key.q).modPow(key.dQ, key.q);
		while (xp.compareTo(xq) < 0) xp = xp.add(key.p);
		var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
		y = y.multiply(r.modInverse(key.n)).mod(key.n);
		return y;
	};
	/**
	* NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or
	* 'encrypt' on a public key object instead.
	*
	* Performs RSA encryption.
	*
	* The parameter bt controls whether to put padding bytes before the
	* message passed in. Set bt to either true or false to disable padding
	* completely (in order to handle e.g. EMSA-PSS encoding separately before),
	* signaling whether the encryption operation is a public key operation
	* (i.e. encrypting data) or not, i.e. private key operation (data signing).
	*
	* For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01
	* (for signing) or 0x02 (for encryption). The key operation mode (private
	* or public) is derived from this flag in that case).
	*
	* @param m the message to encrypt as a byte string.
	* @param key the RSA key to use.
	* @param bt for PKCS#1 v1.5 padding, the block type to use
	*   (0x01 for private key, 0x02 for public),
	*   to disable padding: true = public key, false = private key.
	*
	* @return the encrypted bytes as a string.
	*/
	pki.rsa.encrypt = function(m, key, bt) {
		var pub = bt;
		var eb;
		var k = Math.ceil(key.n.bitLength() / 8);
		if (bt !== false && bt !== true) {
			pub = bt === 2;
			eb = _encodePkcs1_v1_5(m, key, bt);
		} else {
			eb = forge.util.createBuffer();
			eb.putBytes(m);
		}
		var yhex = _modPow(new BigInteger(eb.toHex(), 16), key, pub).toString(16);
		var ed = forge.util.createBuffer();
		var zeros = k - Math.ceil(yhex.length / 2);
		while (zeros > 0) {
			ed.putByte(0);
			--zeros;
		}
		ed.putBytes(forge.util.hexToBytes(yhex));
		return ed.getBytes();
	};
	/**
	* NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or
	* 'verify' on a public key object instead.
	*
	* Performs RSA decryption.
	*
	* The parameter ml controls whether to apply PKCS#1 v1.5 padding
	* or not.  Set ml = false to disable padding removal completely
	* (in order to handle e.g. EMSA-PSS later on) and simply pass back
	* the RSA encryption block.
	*
	* @param ed the encrypted data to decrypt in as a byte string.
	* @param key the RSA key to use.
	* @param pub true for a public key operation, false for private.
	* @param ml the message length, if known, false to disable padding.
	*
	* @return the decrypted message as a byte string.
	*/
	pki.rsa.decrypt = function(ed, key, pub, ml) {
		var k = Math.ceil(key.n.bitLength() / 8);
		if (ed.length !== k) {
			var error = /* @__PURE__ */ new Error("Encrypted message length is invalid.");
			error.length = ed.length;
			error.expected = k;
			throw error;
		}
		var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
		if (y.compareTo(key.n) >= 0) throw new Error("Encrypted message is invalid.");
		var xhex = _modPow(y, key, pub).toString(16);
		var eb = forge.util.createBuffer();
		var zeros = k - Math.ceil(xhex.length / 2);
		while (zeros > 0) {
			eb.putByte(0);
			--zeros;
		}
		eb.putBytes(forge.util.hexToBytes(xhex));
		if (ml !== false) return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
		return eb.getBytes();
	};
	/**
	* Creates an RSA key-pair generation state object. It is used to allow
	* key-generation to be performed in steps. It also allows for a UI to
	* display progress updates.
	*
	* @param bits the size for the private key in bits, defaults to 2048.
	* @param e the public exponent to use, defaults to 65537 (0x10001).
	* @param [options] the options to use.
	*          prng a custom crypto-secure pseudo-random number generator to use,
	*            that must define "getBytesSync".
	*          algorithm the algorithm to use (default: 'PRIMEINC').
	*
	* @return the state object to use to generate the key-pair.
	*/
	pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
		if (typeof bits === "string") bits = parseInt(bits, 10);
		bits = bits || 2048;
		options = options || {};
		var prng = options.prng || forge.random;
		var rng = { nextBytes: function(x) {
			var b = prng.getBytesSync(x.length);
			for (var i = 0; i < x.length; ++i) x[i] = b.charCodeAt(i);
		} };
		var algorithm = options.algorithm || "PRIMEINC";
		var rval;
		if (algorithm === "PRIMEINC") {
			rval = {
				algorithm,
				state: 0,
				bits,
				rng,
				eInt: e || 65537,
				e: new BigInteger(null),
				p: null,
				q: null,
				qBits: bits >> 1,
				pBits: bits - (bits >> 1),
				pqState: 0,
				num: null,
				keys: null
			};
			rval.e.fromInt(rval.eInt);
		} else throw new Error("Invalid key generation algorithm: " + algorithm);
		return rval;
	};
	/**
	* Attempts to runs the key-generation algorithm for at most n seconds
	* (approximately) using the given state. When key-generation has completed,
	* the keys will be stored in state.keys.
	*
	* To use this function to update a UI while generating a key or to prevent
	* causing browser lockups/warnings, set "n" to a value other than 0. A
	* simple pattern for generating a key and showing a progress indicator is:
	*
	* var state = pki.rsa.createKeyPairGenerationState(2048);
	* var step = function() {
	*   // step key-generation, run algorithm for 100 ms, repeat
	*   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {
	*     setTimeout(step, 1);
	*   } else {
	*     // key-generation complete
	*     // TODO: turn off progress indicator here
	*     // TODO: use the generated key-pair in "state.keys"
	*   }
	* };
	* // TODO: turn on progress indicator here
	* setTimeout(step, 0);
	*
	* @param state the state to use.
	* @param n the maximum number of milliseconds to run the algorithm for, 0
	*          to run the algorithm to completion.
	*
	* @return true if the key-generation completed, false if not.
	*/
	pki.rsa.stepKeyPairGenerationState = function(state, n) {
		if (!("algorithm" in state)) state.algorithm = "PRIMEINC";
		var THIRTY = new BigInteger(null);
		THIRTY.fromInt(30);
		var deltaIdx = 0;
		var op_or = function(x, y) {
			return x | y;
		};
		var t1 = +/* @__PURE__ */ new Date();
		var t2;
		var total = 0;
		while (state.keys === null && (n <= 0 || total < n)) {
			if (state.state === 0) {
				var bits = state.p === null ? state.pBits : state.qBits;
				var bits1 = bits - 1;
				if (state.pqState === 0) {
					state.num = new BigInteger(bits, state.rng);
					if (!state.num.testBit(bits1)) state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
					state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
					deltaIdx = 0;
					++state.pqState;
				} else if (state.pqState === 1) if (state.num.bitLength() > bits) state.pqState = 0;
				else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) ++state.pqState;
				else state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
				else if (state.pqState === 2) state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
				else if (state.pqState === 3) {
					state.pqState = 0;
					if (state.p === null) state.p = state.num;
					else state.q = state.num;
					if (state.p !== null && state.q !== null) ++state.state;
					state.num = null;
				}
			} else if (state.state === 1) {
				if (state.p.compareTo(state.q) < 0) {
					state.num = state.p;
					state.p = state.q;
					state.q = state.num;
				}
				++state.state;
			} else if (state.state === 2) {
				state.p1 = state.p.subtract(BigInteger.ONE);
				state.q1 = state.q.subtract(BigInteger.ONE);
				state.phi = state.p1.multiply(state.q1);
				++state.state;
			} else if (state.state === 3) if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) ++state.state;
			else {
				state.p = null;
				state.q = null;
				state.state = 0;
			}
			else if (state.state === 4) {
				state.n = state.p.multiply(state.q);
				if (state.n.bitLength() === state.bits) ++state.state;
				else {
					state.q = null;
					state.state = 0;
				}
			} else if (state.state === 5) {
				var d = state.e.modInverse(state.phi);
				state.keys = {
					privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
					publicKey: pki.rsa.setPublicKey(state.n, state.e)
				};
			}
			t2 = +/* @__PURE__ */ new Date();
			total += t2 - t1;
			t1 = t2;
		}
		return state.keys !== null;
	};
	/**
	* Generates an RSA public-private key pair in a single call.
	*
	* To generate a key-pair in steps (to allow for progress updates and to
	* prevent blocking or warnings in slow browsers) then use the key-pair
	* generation state functions.
	*
	* To generate a key-pair asynchronously (either through web-workers, if
	* available, or by breaking up the work on the main thread), pass a
	* callback function.
	*
	* @param [bits] the size for the private key in bits, defaults to 2048.
	* @param [e] the public exponent to use, defaults to 65537.
	* @param [options] options for key-pair generation, if given then 'bits'
	*            and 'e' must *not* be given:
	*          bits the size for the private key in bits, (default: 2048).
	*          e the public exponent to use, (default: 65537 (0x10001)).
	*          workerScript the worker script URL.
	*          workers the number of web workers (if supported) to use,
	*            (default: 2).
	*          workLoad the size of the work load, ie: number of possible prime
	*            numbers for each web worker to check per work assignment,
	*            (default: 100).
	*          prng a custom crypto-secure pseudo-random number generator to use,
	*            that must define "getBytesSync". Disables use of native APIs.
	*          algorithm the algorithm to use (default: 'PRIMEINC').
	* @param [callback(err, keypair)] called once the operation completes.
	*
	* @return an object with privateKey and publicKey properties.
	*/
	pki.rsa.generateKeyPair = function(bits, e, options, callback) {
		if (arguments.length === 1) {
			if (typeof bits === "object") {
				options = bits;
				bits = void 0;
			} else if (typeof bits === "function") {
				callback = bits;
				bits = void 0;
			}
		} else if (arguments.length === 2) if (typeof bits === "number") {
			if (typeof e === "function") {
				callback = e;
				e = void 0;
			} else if (typeof e !== "number") {
				options = e;
				e = void 0;
			}
		} else {
			options = bits;
			callback = e;
			bits = void 0;
			e = void 0;
		}
		else if (arguments.length === 3) if (typeof e === "number") {
			if (typeof options === "function") {
				callback = options;
				options = void 0;
			}
		} else {
			callback = options;
			options = e;
			e = void 0;
		}
		options = options || {};
		if (bits === void 0) bits = options.bits || 2048;
		if (e === void 0) e = options.e || 65537;
		if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
			if (callback) {
				if (_detectNodeCrypto("generateKeyPair")) return _crypto.generateKeyPair("rsa", {
					modulusLength: bits,
					publicExponent: e,
					publicKeyEncoding: {
						type: "spki",
						format: "pem"
					},
					privateKeyEncoding: {
						type: "pkcs8",
						format: "pem"
					}
				}, function(err, pub, priv) {
					if (err) return callback(err);
					callback(null, {
						privateKey: pki.privateKeyFromPem(priv),
						publicKey: pki.publicKeyFromPem(pub)
					});
				});
				if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) return util.globalScope.crypto.subtle.generateKey({
					name: "RSASSA-PKCS1-v1_5",
					modulusLength: bits,
					publicExponent: _intToUint8Array(e),
					hash: { name: "SHA-256" }
				}, true, ["sign", "verify"]).then(function(pair) {
					return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
				}).then(void 0, function(err) {
					callback(err);
				}).then(function(pkcs8) {
					if (pkcs8) {
						var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
						callback(null, {
							privateKey,
							publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
						});
					}
				});
				if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
					var genOp = util.globalScope.msCrypto.subtle.generateKey({
						name: "RSASSA-PKCS1-v1_5",
						modulusLength: bits,
						publicExponent: _intToUint8Array(e),
						hash: { name: "SHA-256" }
					}, true, ["sign", "verify"]);
					genOp.oncomplete = function(e) {
						var pair = e.target.result;
						var exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
						exportOp.oncomplete = function(e) {
							var pkcs8 = e.target.result;
							var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
							callback(null, {
								privateKey,
								publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
							});
						};
						exportOp.onerror = function(err) {
							callback(err);
						};
					};
					genOp.onerror = function(err) {
						callback(err);
					};
					return;
				}
			} else if (_detectNodeCrypto("generateKeyPairSync")) {
				var keypair = _crypto.generateKeyPairSync("rsa", {
					modulusLength: bits,
					publicExponent: e,
					publicKeyEncoding: {
						type: "spki",
						format: "pem"
					},
					privateKeyEncoding: {
						type: "pkcs8",
						format: "pem"
					}
				});
				return {
					privateKey: pki.privateKeyFromPem(keypair.privateKey),
					publicKey: pki.publicKeyFromPem(keypair.publicKey)
				};
			}
		}
		var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
		if (!callback) {
			pki.rsa.stepKeyPairGenerationState(state, 0);
			return state.keys;
		}
		_generateKeyPair(state, options, callback);
	};
	/**
	* Sets an RSA public key from BigIntegers modulus and exponent.
	*
	* @param n the modulus.
	* @param e the exponent.
	*
	* @return the public key.
	*/
	pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
		var key = {
			n,
			e
		};
		/**
		* Encrypts the given data with this public key. Newer applications
		* should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
		* legacy applications.
		*
		* @param data the byte string to encrypt.
		* @param scheme the encryption scheme to use:
		*          'RSAES-PKCS1-V1_5' (default),
		*          'RSA-OAEP',
		*          'RAW', 'NONE', or null to perform raw RSA encryption,
		*          an object with an 'encode' property set to a function
		*          with the signature 'function(data, key)' that returns
		*          a binary-encoded string representing the encoded data.
		* @param schemeOptions any scheme-specific options.
		*
		* @return the encrypted byte string.
		*/
		key.encrypt = function(data, scheme, schemeOptions) {
			if (typeof scheme === "string") scheme = scheme.toUpperCase();
			else if (scheme === void 0) scheme = "RSAES-PKCS1-V1_5";
			if (scheme === "RSAES-PKCS1-V1_5") scheme = { encode: function(m, key, pub) {
				return _encodePkcs1_v1_5(m, key, 2).getBytes();
			} };
			else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") scheme = { encode: function(m, key) {
				return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
			} };
			else if ([
				"RAW",
				"NONE",
				"NULL",
				null
			].indexOf(scheme) !== -1) scheme = { encode: function(e) {
				return e;
			} };
			else if (typeof scheme === "string") throw new Error("Unsupported encryption scheme: \"" + scheme + "\".");
			var e = scheme.encode(data, key, true);
			return pki.rsa.encrypt(e, key, true);
		};
		/**
		* Verifies the given signature against the given digest.
		*
		* PKCS#1 supports multiple (currently two) signature schemes:
		* RSASSA-PKCS1-V1_5 and RSASSA-PSS.
		*
		* By default this implementation uses the "old scheme", i.e.
		* RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
		* signature is an OCTET STRING that holds a DigestInfo.
		*
		* DigestInfo ::= SEQUENCE {
		*   digestAlgorithm DigestAlgorithmIdentifier,
		*   digest Digest
		* }
		* DigestAlgorithmIdentifier ::= AlgorithmIdentifier
		* Digest ::= OCTET STRING
		*
		* To perform PSS signature verification, provide an instance
		* of Forge PSS object as the scheme parameter.
		*
		* @param digest the message digest hash to compare against the signature,
		*          as a binary-encoded string.
		* @param signature the signature to verify, as a binary-encoded string.
		* @param scheme signature verification scheme to use:
		*          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
		*          a Forge PSS object for RSASSA-PSS,
		*          'NONE' or null for none, DigestInfo will not be expected, but
		*            PKCS#1 v1.5 padding will still be used.
		* @param options optional verify options
		*          _parseAllDigestBytes testing flag to control parsing of all
		*            digest bytes. Unsupported and not for general usage.
		*            (default: true)
		*
		* @return true if the signature was verified, false if not.
		*/
		key.verify = function(digest, signature, scheme, options) {
			if (typeof scheme === "string") scheme = scheme.toUpperCase();
			else if (scheme === void 0) scheme = "RSASSA-PKCS1-V1_5";
			if (options === void 0) options = { _parseAllDigestBytes: true };
			if (!("_parseAllDigestBytes" in options)) options._parseAllDigestBytes = true;
			if (scheme === "RSASSA-PKCS1-V1_5") scheme = { verify: function(digest, d) {
				d = _decodePkcs1_v1_5(d, key, true);
				var obj = asn1.fromDer(d, { parseAllBytes: options._parseAllDigestBytes });
				var capture = {};
				var errors = [];
				if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
					var error = /* @__PURE__ */ new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
					error.errors = errors;
					throw error;
				}
				var oid = asn1.derToOid(capture.algorithmIdentifier);
				if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids["sha512-224"] || oid === forge.oids["sha512-256"])) {
					var error = /* @__PURE__ */ new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
					error.oid = oid;
					throw error;
				}
				if (oid === forge.oids.md2 || oid === forge.oids.md5) {
					if (!("parameters" in capture)) throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifier NULL parameters.");
				}
				return digest === capture.digest;
			} };
			else if (scheme === "NONE" || scheme === "NULL" || scheme === null) scheme = { verify: function(digest, d) {
				d = _decodePkcs1_v1_5(d, key, true);
				return digest === d;
			} };
			var d = pki.rsa.decrypt(signature, key, true, false);
			return scheme.verify(digest, d, key.n.bitLength());
		};
		return key;
	};
	/**
	* Sets an RSA private key from BigIntegers modulus, exponent, primes,
	* prime exponents, and modular multiplicative inverse.
	*
	* @param n the modulus.
	* @param e the public exponent.
	* @param d the private exponent ((inverse of e) mod n).
	* @param p the first prime.
	* @param q the second prime.
	* @param dP exponent1 (d mod (p-1)).
	* @param dQ exponent2 (d mod (q-1)).
	* @param qInv ((inverse of q) mod p)
	*
	* @return the private key.
	*/
	pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
		var key = {
			n,
			e,
			d,
			p,
			q,
			dP,
			dQ,
			qInv
		};
		/**
		* Decrypts the given data with this private key. The decryption scheme
		* must match the one used to encrypt the data.
		*
		* @param data the byte string to decrypt.
		* @param scheme the decryption scheme to use:
		*          'RSAES-PKCS1-V1_5' (default),
		*          'RSA-OAEP',
		*          'RAW', 'NONE', or null to perform raw RSA decryption.
		* @param schemeOptions any scheme-specific options.
		*
		* @return the decrypted byte string.
		*/
		key.decrypt = function(data, scheme, schemeOptions) {
			if (typeof scheme === "string") scheme = scheme.toUpperCase();
			else if (scheme === void 0) scheme = "RSAES-PKCS1-V1_5";
			var d = pki.rsa.decrypt(data, key, false, false);
			if (scheme === "RSAES-PKCS1-V1_5") scheme = { decode: _decodePkcs1_v1_5 };
			else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") scheme = { decode: function(d, key) {
				return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
			} };
			else if ([
				"RAW",
				"NONE",
				"NULL",
				null
			].indexOf(scheme) !== -1) scheme = { decode: function(d) {
				return d;
			} };
			else throw new Error("Unsupported encryption scheme: \"" + scheme + "\".");
			return scheme.decode(d, key, false);
		};
		/**
		* Signs the given digest, producing a signature.
		*
		* PKCS#1 supports multiple (currently two) signature schemes:
		* RSASSA-PKCS1-V1_5 and RSASSA-PSS.
		*
		* By default this implementation uses the "old scheme", i.e.
		* RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
		* an instance of Forge PSS object as the scheme parameter.
		*
		* @param md the message digest object with the hash to sign.
		* @param scheme the signature scheme to use:
		*          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
		*          a Forge PSS object for RSASSA-PSS,
		*          'NONE' or null for none, DigestInfo will not be used but
		*            PKCS#1 v1.5 padding will still be used.
		*
		* @return the signature as a byte string.
		*/
		key.sign = function(md, scheme) {
			var bt = false;
			if (typeof scheme === "string") scheme = scheme.toUpperCase();
			if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
				scheme = { encode: emsaPkcs1v15encode };
				bt = 1;
			} else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
				scheme = { encode: function() {
					return md;
				} };
				bt = 1;
			}
			var d = scheme.encode(md, key.n.bitLength());
			return pki.rsa.encrypt(d, key, bt);
		};
		return key;
	};
	/**
	* Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.
	*
	* @param rsaKey the ASN.1 RSAPrivateKey.
	*
	* @return the ASN.1 PrivateKeyInfo.
	*/
	pki.wrapRsaPrivateKey = function(rsaKey) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())
		]);
	};
	/**
	* Converts a private key from an ASN.1 object.
	*
	* @param obj the ASN.1 representation of a PrivateKeyInfo containing an
	*          RSAPrivateKey or an RSAPrivateKey.
	*
	* @return the private key.
	*/
	pki.privateKeyFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (asn1.validate(obj, privateKeyValidator, capture, errors)) obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
		capture = {};
		errors = [];
		if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
			error.errors = errors;
			throw error;
		}
		var n = forge.util.createBuffer(capture.privateKeyModulus).toHex(), e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex(), d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex(), p = forge.util.createBuffer(capture.privateKeyPrime1).toHex(), q = forge.util.createBuffer(capture.privateKeyPrime2).toHex(), dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex(), dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex(), qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
		return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
	};
	/**
	* Converts a private key to an ASN.1 RSAPrivateKey.
	*
	* @param key the private key.
	*
	* @return the ASN.1 representation of an RSAPrivateKey.
	*/
	pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))
		]);
	};
	/**
	* Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.
	*
	* @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.
	*
	* @return the public key.
	*/
	pki.publicKeyFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
			var oid = asn1.derToOid(capture.publicKeyOid);
			if (oid !== pki.oids.rsaEncryption) {
				var error = /* @__PURE__ */ new Error("Cannot read public key. Unknown OID.");
				error.oid = oid;
				throw error;
			}
			obj = capture.rsaPublicKey;
		}
		errors = [];
		if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
			error.errors = errors;
			throw error;
		}
		var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
		var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
		return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
	};
	/**
	* Converts a public key to an ASN.1 SubjectPublicKeyInfo.
	*
	* @param key the public key.
	*
	* @return the asn1 representation of a SubjectPublicKeyInfo.
	*/
	pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [pki.publicKeyToRSAPublicKey(key)])]);
	};
	/**
	* Converts a public key to an ASN.1 RSAPublicKey.
	*
	* @param key the public key.
	*
	* @return the asn1 representation of a RSAPublicKey.
	*/
	pki.publicKeyToRSAPublicKey = function(key) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))]);
	};
	/**
	* Encodes a message using PKCS#1 v1.5 padding.
	*
	* @param m the message to encode.
	* @param key the RSA key to use.
	* @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02
	*          (for encryption).
	*
	* @return the padded byte buffer.
	*/
	function _encodePkcs1_v1_5(m, key, bt) {
		var eb = forge.util.createBuffer();
		var k = Math.ceil(key.n.bitLength() / 8);
		if (m.length > k - 11) {
			var error = /* @__PURE__ */ new Error("Message is too long for PKCS#1 v1.5 padding.");
			error.length = m.length;
			error.max = k - 11;
			throw error;
		}
		eb.putByte(0);
		eb.putByte(bt);
		var padNum = k - 3 - m.length;
		var padByte;
		if (bt === 0 || bt === 1) {
			padByte = bt === 0 ? 0 : 255;
			for (var i = 0; i < padNum; ++i) eb.putByte(padByte);
		} else while (padNum > 0) {
			var numZeros = 0;
			var padBytes = forge.random.getBytes(padNum);
			for (var i = 0; i < padNum; ++i) {
				padByte = padBytes.charCodeAt(i);
				if (padByte === 0) ++numZeros;
				else eb.putByte(padByte);
			}
			padNum = numZeros;
		}
		eb.putByte(0);
		eb.putBytes(m);
		return eb;
	}
	/**
	* Decodes a message using PKCS#1 v1.5 padding.
	*
	* @param em the message to decode.
	* @param key the RSA key to use.
	* @param pub true if the key is a public key, false if it is private.
	* @param ml the message length, if specified.
	*
	* @return the decoded bytes.
	*/
	function _decodePkcs1_v1_5(em, key, pub, ml) {
		var k = Math.ceil(key.n.bitLength() / 8);
		var eb = forge.util.createBuffer(em);
		var first = eb.getByte();
		var bt = eb.getByte();
		if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") throw new Error("Encryption block is invalid.");
		var padNum = 0;
		if (bt === 0) {
			padNum = k - 3 - ml;
			for (var i = 0; i < padNum; ++i) if (eb.getByte() !== 0) throw new Error("Encryption block is invalid.");
		} else if (bt === 1) {
			padNum = 0;
			while (eb.length() > 1) {
				if (eb.getByte() !== 255) {
					--eb.read;
					break;
				}
				++padNum;
			}
		} else if (bt === 2) {
			padNum = 0;
			while (eb.length() > 1) {
				if (eb.getByte() === 0) {
					--eb.read;
					break;
				}
				++padNum;
			}
		}
		if (eb.getByte() !== 0 || padNum !== k - 3 - eb.length()) throw new Error("Encryption block is invalid.");
		return eb.getBytes();
	}
	/**
	* Runs the key-generation algorithm asynchronously, either in the background
	* via Web Workers, or using the main thread and setImmediate.
	*
	* @param state the key-pair generation state.
	* @param [options] options for key-pair generation:
	*          workerScript the worker script URL.
	*          workers the number of web workers (if supported) to use,
	*            (default: 2, -1 to use estimated cores minus one).
	*          workLoad the size of the work load, ie: number of possible prime
	*            numbers for each web worker to check per work assignment,
	*            (default: 100).
	* @param callback(err, keypair) called once the operation completes.
	*/
	function _generateKeyPair(state, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}
		options = options || {};
		var opts = { algorithm: {
			name: options.algorithm || "PRIMEINC",
			options: {
				workers: options.workers || 2,
				workLoad: options.workLoad || 100,
				workerScript: options.workerScript
			}
		} };
		if ("prng" in options) opts.prng = options.prng;
		generate();
		function generate() {
			getPrime(state.pBits, function(err, num) {
				if (err) return callback(err);
				state.p = num;
				if (state.q !== null) return finish(err, state.q);
				getPrime(state.qBits, finish);
			});
		}
		function getPrime(bits, callback) {
			forge.prime.generateProbablePrime(bits, opts, callback);
		}
		function finish(err, num) {
			if (err) return callback(err);
			state.q = num;
			if (state.p.compareTo(state.q) < 0) {
				var tmp = state.p;
				state.p = state.q;
				state.q = tmp;
			}
			if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
				state.p = null;
				generate();
				return;
			}
			if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
				state.q = null;
				getPrime(state.qBits, finish);
				return;
			}
			state.p1 = state.p.subtract(BigInteger.ONE);
			state.q1 = state.q.subtract(BigInteger.ONE);
			state.phi = state.p1.multiply(state.q1);
			if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
				state.p = state.q = null;
				generate();
				return;
			}
			state.n = state.p.multiply(state.q);
			if (state.n.bitLength() !== state.bits) {
				state.q = null;
				getPrime(state.qBits, finish);
				return;
			}
			var d = state.e.modInverse(state.phi);
			state.keys = {
				privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
				publicKey: pki.rsa.setPublicKey(state.n, state.e)
			};
			callback(null, state.keys);
		}
	}
	/**
	* Converts a positive BigInteger into 2's-complement big-endian bytes.
	*
	* @param b the big integer to convert.
	*
	* @return the bytes.
	*/
	function _bnToBytes(b) {
		var hex = b.toString(16);
		if (hex[0] >= "8") hex = "00" + hex;
		var bytes = forge.util.hexToBytes(hex);
		if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) return bytes.substr(1);
		return bytes;
	}
	/**
	* Returns the required number of Miller-Rabin tests to generate a
	* prime with an error probability of (1/2)^80.
	*
	* See Handbook of Applied Cryptography Chapter 4, Table 4.4.
	*
	* @param bits the bit size.
	*
	* @return the required number of iterations.
	*/
	function _getMillerRabinTests(bits) {
		if (bits <= 100) return 27;
		if (bits <= 150) return 18;
		if (bits <= 200) return 15;
		if (bits <= 250) return 12;
		if (bits <= 300) return 9;
		if (bits <= 350) return 8;
		if (bits <= 400) return 7;
		if (bits <= 500) return 6;
		if (bits <= 600) return 5;
		if (bits <= 800) return 4;
		if (bits <= 1250) return 3;
		return 2;
	}
	/**
	* Performs feature detection on the Node crypto interface.
	*
	* @param fn the feature (function) to detect.
	*
	* @return true if detected, false if not.
	*/
	function _detectNodeCrypto(fn) {
		return forge.util.isNodejs && typeof _crypto[fn] === "function";
	}
	/**
	* Performs feature detection on the SubtleCrypto interface.
	*
	* @param fn the feature (function) to detect.
	*
	* @return true if detected, false if not.
	*/
	function _detectSubtleCrypto(fn) {
		return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
	}
	/**
	* Performs feature detection on the deprecated Microsoft Internet Explorer
	* outdated SubtleCrypto interface. This function should only be used after
	* checking for the modern, standard SubtleCrypto interface.
	*
	* @param fn the feature (function) to detect.
	*
	* @return true if detected, false if not.
	*/
	function _detectSubtleMsCrypto(fn) {
		return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
	}
	function _intToUint8Array(x) {
		var bytes = forge.util.hexToBytes(x.toString(16));
		var buffer = new Uint8Array(bytes.length);
		for (var i = 0; i < bytes.length; ++i) buffer[i] = bytes.charCodeAt(i);
		return buffer;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/pbe.js
var require_pbe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Password-based encryption functions.
	*
	* @author Dave Longley
	* @author Stefan Siegl <stesie@brokenpipe.de>
	*
	* Copyright (c) 2010-2013 Digital Bazaar, Inc.
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*
	* An EncryptedPrivateKeyInfo:
	*
	* EncryptedPrivateKeyInfo ::= SEQUENCE {
	*   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
	*   encryptedData        EncryptedData }
	*
	* EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
	*
	* EncryptedData ::= OCTET STRING
	*/
	var forge = require_forge();
	require_aes();
	require_asn1();
	require_des();
	require_md();
	require_oids();
	require_pbkdf2();
	require_pem();
	require_random();
	require_rc2();
	require_rsa();
	require_util();
	if (typeof BigInteger === "undefined") var BigInteger = forge.jsbn.BigInteger;
	var asn1 = forge.asn1;
	var pki = forge.pki = forge.pki || {};
	module.exports = pki.pbe = forge.pbe = forge.pbe || {};
	var oids = pki.oids;
	var encryptedPrivateKeyValidator = {
		name: "EncryptedPrivateKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "AlgorithmIdentifier.algorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "encryptionOid"
			}, {
				name: "AlgorithmIdentifier.parameters",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				captureAsn1: "encryptionParams"
			}]
		}, {
			name: "EncryptedPrivateKeyInfo.encryptedData",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OCTETSTRING,
			constructed: false,
			capture: "encryptedData"
		}]
	};
	var PBES2AlgorithmsValidator = {
		name: "PBES2Algorithms",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "PBES2Algorithms.keyDerivationFunc",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "PBES2Algorithms.keyDerivationFunc.oid",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "kdfOid"
			}, {
				name: "PBES2Algorithms.params",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [
					{
						name: "PBES2Algorithms.params.salt",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OCTETSTRING,
						constructed: false,
						capture: "kdfSalt"
					},
					{
						name: "PBES2Algorithms.params.iterationCount",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.INTEGER,
						constructed: false,
						capture: "kdfIterationCount"
					},
					{
						name: "PBES2Algorithms.params.keyLength",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.INTEGER,
						constructed: false,
						optional: true,
						capture: "keyLength"
					},
					{
						name: "PBES2Algorithms.params.prf",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						optional: true,
						value: [{
							name: "PBES2Algorithms.params.prf.algorithm",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.OID,
							constructed: false,
							capture: "prfOid"
						}]
					}
				]
			}]
		}, {
			name: "PBES2Algorithms.encryptionScheme",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "PBES2Algorithms.encryptionScheme.oid",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "encOid"
			}, {
				name: "PBES2Algorithms.encryptionScheme.iv",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "encIv"
			}]
		}]
	};
	var pkcs12PbeParamsValidator = {
		name: "pkcs-12PbeParams",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "pkcs-12PbeParams.salt",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OCTETSTRING,
			constructed: false,
			capture: "salt"
		}, {
			name: "pkcs-12PbeParams.iterations",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "iterations"
		}]
	};
	/**
	* Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.
	*
	* PBES2Algorithms ALGORITHM-IDENTIFIER ::=
	*   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}
	*
	* id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}
	*
	* PBES2-params ::= SEQUENCE {
	*   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
	*   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
	* }
	*
	* PBES2-KDFs ALGORITHM-IDENTIFIER ::=
	*   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }
	*
	* PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }
	*
	* PBKDF2-params ::= SEQUENCE {
	*   salt CHOICE {
	*     specified OCTET STRING,
	*     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
	*   },
	*   iterationCount INTEGER (1..MAX),
	*   keyLength INTEGER (1..MAX) OPTIONAL,
	*   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
	* }
	*
	* @param obj the ASN.1 PrivateKeyInfo object.
	* @param password the password to encrypt with.
	* @param options:
	*          algorithm the encryption algorithm to use
	*            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
	*          count the iteration count to use.
	*          saltSize the salt size to use.
	*          prfAlgorithm the PRF message digest algorithm to use
	*            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')
	*
	* @return the ASN.1 EncryptedPrivateKeyInfo.
	*/
	pki.encryptPrivateKeyInfo = function(obj, password, options) {
		options = options || {};
		options.saltSize = options.saltSize || 8;
		options.count = options.count || 2048;
		options.algorithm = options.algorithm || "aes128";
		options.prfAlgorithm = options.prfAlgorithm || "sha1";
		var salt = forge.random.getBytesSync(options.saltSize);
		var count = options.count;
		var countBytes = asn1.integerToDer(count);
		var dkLen;
		var encryptionAlgorithm;
		var encryptedData;
		if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
			var ivLen, encOid, cipherFn;
			switch (options.algorithm) {
				case "aes128":
					dkLen = 16;
					ivLen = 16;
					encOid = oids["aes128-CBC"];
					cipherFn = forge.aes.createEncryptionCipher;
					break;
				case "aes192":
					dkLen = 24;
					ivLen = 16;
					encOid = oids["aes192-CBC"];
					cipherFn = forge.aes.createEncryptionCipher;
					break;
				case "aes256":
					dkLen = 32;
					ivLen = 16;
					encOid = oids["aes256-CBC"];
					cipherFn = forge.aes.createEncryptionCipher;
					break;
				case "des":
					dkLen = 8;
					ivLen = 8;
					encOid = oids["desCBC"];
					cipherFn = forge.des.createEncryptionCipher;
					break;
				default:
					var error = /* @__PURE__ */ new Error("Cannot encrypt private key. Unknown encryption algorithm.");
					error.algorithm = options.algorithm;
					throw error;
			}
			var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
			var md = prfAlgorithmToMessageDigest(prfAlgorithm);
			var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
			var iv = forge.random.getBytesSync(ivLen);
			var cipher = cipherFn(dk);
			cipher.start(iv);
			cipher.update(asn1.toDer(obj));
			cipher.finish();
			encryptedData = cipher.output.getBytes();
			var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
			encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()), params]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)])])]);
		} else if (options.algorithm === "3des") {
			dkLen = 24;
			var saltBytes = new forge.util.ByteBuffer(salt);
			var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
			var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
			var cipher = forge.des.createEncryptionCipher(dk);
			cipher.start(iv);
			cipher.update(asn1.toDer(obj));
			cipher.finish();
			encryptedData = cipher.output.getBytes();
			encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())])]);
		} else {
			var error = /* @__PURE__ */ new Error("Cannot encrypt private key. Unknown encryption algorithm.");
			error.algorithm = options.algorithm;
			throw error;
		}
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [encryptionAlgorithm, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)]);
	};
	/**
	* Decrypts a ASN.1 PrivateKeyInfo object.
	*
	* @param obj the ASN.1 EncryptedPrivateKeyInfo object.
	* @param password the password to decrypt with.
	*
	* @return the ASN.1 PrivateKeyInfo on success, null on failure.
	*/
	pki.decryptPrivateKeyInfo = function(obj, password) {
		var rval = null;
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
			error.errors = errors;
			throw error;
		}
		var oid = asn1.derToOid(capture.encryptionOid);
		var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
		var encrypted = forge.util.createBuffer(capture.encryptedData);
		cipher.update(encrypted);
		if (cipher.finish()) rval = asn1.fromDer(cipher.output);
		return rval;
	};
	/**
	* Converts a EncryptedPrivateKeyInfo to PEM format.
	*
	* @param epki the EncryptedPrivateKeyInfo.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted encrypted private key.
	*/
	pki.encryptedPrivateKeyToPem = function(epki, maxline) {
		var msg = {
			type: "ENCRYPTED PRIVATE KEY",
			body: asn1.toDer(epki).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
	* is not performed.
	*
	* @param pem the EncryptedPrivateKeyInfo in PEM-format.
	*
	* @return the ASN.1 EncryptedPrivateKeyInfo.
	*/
	pki.encryptedPrivateKeyFromPem = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "ENCRYPTED PRIVATE KEY") {
			var error = /* @__PURE__ */ new Error("Could not convert encrypted private key from PEM; PEM header type is \"ENCRYPTED PRIVATE KEY\".");
			error.headerType = msg.type;
			throw error;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
		return asn1.fromDer(msg.body);
	};
	/**
	* Encrypts an RSA private key. By default, the key will be wrapped in
	* a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.
	* This is the standard, preferred way to encrypt a private key.
	*
	* To produce a non-standard PEM-encrypted private key that uses encapsulated
	* headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL
	* private key encryption), set the 'legacy' option to true. Note: Using this
	* option will cause the iteration count to be forced to 1.
	*
	* Note: The 'des' algorithm is supported, but it is not considered to be
	* secure because it only uses a single 56-bit key. If possible, it is highly
	* recommended that a different algorithm be used.
	*
	* @param rsaKey the RSA key to encrypt.
	* @param password the password to use.
	* @param options:
	*          algorithm: the encryption algorithm to use
	*            ('aes128', 'aes192', 'aes256', '3des', 'des').
	*          count: the iteration count to use.
	*          saltSize: the salt size to use.
	*          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated
	*            headers (DEK-Info) private key.
	*
	* @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.
	*/
	pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
		options = options || {};
		if (!options.legacy) {
			var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
			rval = pki.encryptPrivateKeyInfo(rval, password, options);
			return pki.encryptedPrivateKeyToPem(rval);
		}
		var algorithm;
		var iv;
		var dkLen;
		var cipherFn;
		switch (options.algorithm) {
			case "aes128":
				algorithm = "AES-128-CBC";
				dkLen = 16;
				iv = forge.random.getBytesSync(16);
				cipherFn = forge.aes.createEncryptionCipher;
				break;
			case "aes192":
				algorithm = "AES-192-CBC";
				dkLen = 24;
				iv = forge.random.getBytesSync(16);
				cipherFn = forge.aes.createEncryptionCipher;
				break;
			case "aes256":
				algorithm = "AES-256-CBC";
				dkLen = 32;
				iv = forge.random.getBytesSync(16);
				cipherFn = forge.aes.createEncryptionCipher;
				break;
			case "3des":
				algorithm = "DES-EDE3-CBC";
				dkLen = 24;
				iv = forge.random.getBytesSync(8);
				cipherFn = forge.des.createEncryptionCipher;
				break;
			case "des":
				algorithm = "DES-CBC";
				dkLen = 8;
				iv = forge.random.getBytesSync(8);
				cipherFn = forge.des.createEncryptionCipher;
				break;
			default:
				var error = /* @__PURE__ */ new Error("Could not encrypt RSA private key; unsupported encryption algorithm \"" + options.algorithm + "\".");
				error.algorithm = options.algorithm;
				throw error;
		}
		var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
		var cipher = cipherFn(dk);
		cipher.start(iv);
		cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
		cipher.finish();
		var msg = {
			type: "RSA PRIVATE KEY",
			procType: {
				version: "4",
				type: "ENCRYPTED"
			},
			dekInfo: {
				algorithm,
				parameters: forge.util.bytesToHex(iv).toUpperCase()
			},
			body: cipher.output.getBytes()
		};
		return forge.pem.encode(msg);
	};
	/**
	* Decrypts an RSA private key.
	*
	* @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.
	* @param password the password to use.
	*
	* @return the RSA key on success, null on failure.
	*/
	pki.decryptRsaPrivateKey = function(pem, password) {
		var rval = null;
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
			var error = /* @__PURE__ */ new Error("Could not convert private key from PEM; PEM header type is not \"ENCRYPTED PRIVATE KEY\", \"PRIVATE KEY\", or \"RSA PRIVATE KEY\".");
			error.headerType = error;
			throw error;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") {
			var dkLen;
			var cipherFn;
			switch (msg.dekInfo.algorithm) {
				case "DES-CBC":
					dkLen = 8;
					cipherFn = forge.des.createDecryptionCipher;
					break;
				case "DES-EDE3-CBC":
					dkLen = 24;
					cipherFn = forge.des.createDecryptionCipher;
					break;
				case "AES-128-CBC":
					dkLen = 16;
					cipherFn = forge.aes.createDecryptionCipher;
					break;
				case "AES-192-CBC":
					dkLen = 24;
					cipherFn = forge.aes.createDecryptionCipher;
					break;
				case "AES-256-CBC":
					dkLen = 32;
					cipherFn = forge.aes.createDecryptionCipher;
					break;
				case "RC2-40-CBC":
					dkLen = 5;
					cipherFn = function(key) {
						return forge.rc2.createDecryptionCipher(key, 40);
					};
					break;
				case "RC2-64-CBC":
					dkLen = 8;
					cipherFn = function(key) {
						return forge.rc2.createDecryptionCipher(key, 64);
					};
					break;
				case "RC2-128-CBC":
					dkLen = 16;
					cipherFn = function(key) {
						return forge.rc2.createDecryptionCipher(key, 128);
					};
					break;
				default:
					var error = /* @__PURE__ */ new Error("Could not decrypt private key; unsupported encryption algorithm \"" + msg.dekInfo.algorithm + "\".");
					error.algorithm = msg.dekInfo.algorithm;
					throw error;
			}
			var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
			var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
			var cipher = cipherFn(dk);
			cipher.start(iv);
			cipher.update(forge.util.createBuffer(msg.body));
			if (cipher.finish()) rval = cipher.output.getBytes();
			else return rval;
		} else rval = msg.body;
		if (msg.type === "ENCRYPTED PRIVATE KEY") rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
		else rval = asn1.fromDer(rval);
		if (rval !== null) rval = pki.privateKeyFromAsn1(rval);
		return rval;
	};
	/**
	* Derives a PKCS#12 key.
	*
	* @param password the password to derive the key material from, null or
	*          undefined for none.
	* @param salt the salt, as a ByteBuffer, to use.
	* @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
	* @param iter the iteration count.
	* @param n the number of bytes to derive from the password.
	* @param md the message digest to use, defaults to SHA-1.
	*
	* @return a ByteBuffer with the bytes derived from the password.
	*/
	pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
		var j, l;
		if (typeof md === "undefined" || md === null) {
			if (!("sha1" in forge.md)) throw new Error("\"sha1\" hash algorithm unavailable.");
			md = forge.md.sha1.create();
		}
		var u = md.digestLength;
		var v = md.blockLength;
		var result = new forge.util.ByteBuffer();
		var passBuf = new forge.util.ByteBuffer();
		if (password !== null && password !== void 0) {
			for (l = 0; l < password.length; l++) passBuf.putInt16(password.charCodeAt(l));
			passBuf.putInt16(0);
		}
		var p = passBuf.length();
		var s = salt.length();
		var D = new forge.util.ByteBuffer();
		D.fillWithByte(id, v);
		var Slen = v * Math.ceil(s / v);
		var S = new forge.util.ByteBuffer();
		for (l = 0; l < Slen; l++) S.putByte(salt.at(l % s));
		var Plen = v * Math.ceil(p / v);
		var P = new forge.util.ByteBuffer();
		for (l = 0; l < Plen; l++) P.putByte(passBuf.at(l % p));
		var I = S;
		I.putBuffer(P);
		var c = Math.ceil(n / u);
		for (var i = 1; i <= c; i++) {
			var buf = new forge.util.ByteBuffer();
			buf.putBytes(D.bytes());
			buf.putBytes(I.bytes());
			for (var round = 0; round < iter; round++) {
				md.start();
				md.update(buf.getBytes());
				buf = md.digest();
			}
			var B = new forge.util.ByteBuffer();
			for (l = 0; l < v; l++) B.putByte(buf.at(l % u));
			var k = Math.ceil(s / v) + Math.ceil(p / v);
			var Inew = new forge.util.ByteBuffer();
			for (j = 0; j < k; j++) {
				var chunk = new forge.util.ByteBuffer(I.getBytes(v));
				var x = 511;
				for (l = B.length() - 1; l >= 0; l--) {
					x = x >> 8;
					x += B.at(l) + chunk.at(l);
					chunk.setAt(l, x & 255);
				}
				Inew.putBuffer(chunk);
			}
			I = Inew;
			result.putBuffer(buf);
		}
		result.truncate(result.length() - n);
		return result;
	};
	/**
	* Get new Forge cipher object instance.
	*
	* @param oid the OID (in string notation).
	* @param params the ASN.1 params object.
	* @param password the password to decrypt with.
	*
	* @return new cipher object instance.
	*/
	pki.pbe.getCipher = function(oid, params, password) {
		switch (oid) {
			case pki.oids["pkcs5PBES2"]: return pki.pbe.getCipherForPBES2(oid, params, password);
			case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
			case pki.oids["pbewithSHAAnd40BitRC2-CBC"]: return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
			default:
				var error = /* @__PURE__ */ new Error("Cannot read encrypted PBE data block. Unsupported OID.");
				error.oid = oid;
				error.supportedOids = [
					"pkcs5PBES2",
					"pbeWithSHAAnd3-KeyTripleDES-CBC",
					"pbewithSHAAnd40BitRC2-CBC"
				];
				throw error;
		}
	};
	/**
	* Get new Forge cipher object instance according to PBES2 params block.
	*
	* The returned cipher instance is already started using the IV
	* from PBES2 parameter block.
	*
	* @param oid the PKCS#5 PBKDF2 OID (in string notation).
	* @param params the ASN.1 PBES2-params object.
	* @param password the password to decrypt with.
	*
	* @return new cipher object instance.
	*/
	pki.pbe.getCipherForPBES2 = function(oid, params, password) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
			error.errors = errors;
			throw error;
		}
		oid = asn1.derToOid(capture.kdfOid);
		if (oid !== pki.oids["pkcs5PBKDF2"]) {
			var error = /* @__PURE__ */ new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
			error.oid = oid;
			error.supportedOids = ["pkcs5PBKDF2"];
			throw error;
		}
		oid = asn1.derToOid(capture.encOid);
		if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
			var error = /* @__PURE__ */ new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
			error.oid = oid;
			error.supportedOids = [
				"aes128-CBC",
				"aes192-CBC",
				"aes256-CBC",
				"des-EDE3-CBC",
				"desCBC"
			];
			throw error;
		}
		var salt = capture.kdfSalt;
		var count = forge.util.createBuffer(capture.kdfIterationCount);
		count = count.getInt(count.length() << 3);
		var dkLen;
		var cipherFn;
		switch (pki.oids[oid]) {
			case "aes128-CBC":
				dkLen = 16;
				cipherFn = forge.aes.createDecryptionCipher;
				break;
			case "aes192-CBC":
				dkLen = 24;
				cipherFn = forge.aes.createDecryptionCipher;
				break;
			case "aes256-CBC":
				dkLen = 32;
				cipherFn = forge.aes.createDecryptionCipher;
				break;
			case "des-EDE3-CBC":
				dkLen = 24;
				cipherFn = forge.des.createDecryptionCipher;
				break;
			case "desCBC":
				dkLen = 8;
				cipherFn = forge.des.createDecryptionCipher;
				break;
		}
		var md = prfOidToMessageDigest(capture.prfOid);
		var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
		var iv = capture.encIv;
		var cipher = cipherFn(dk);
		cipher.start(iv);
		return cipher;
	};
	/**
	* Get new Forge cipher object instance for PKCS#12 PBE.
	*
	* The returned cipher instance is already started using the key & IV
	* derived from the provided password and PKCS#12 PBE salt.
	*
	* @param oid The PKCS#12 PBE OID (in string notation).
	* @param params The ASN.1 PKCS#12 PBE-params object.
	* @param password The password to decrypt with.
	*
	* @return the new cipher object instance.
	*/
	pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
			error.errors = errors;
			throw error;
		}
		var salt = forge.util.createBuffer(capture.salt);
		var count = forge.util.createBuffer(capture.iterations);
		count = count.getInt(count.length() << 3);
		var dkLen, dIvLen, cipherFn;
		switch (oid) {
			case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
				dkLen = 24;
				dIvLen = 8;
				cipherFn = forge.des.startDecrypting;
				break;
			case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
				dkLen = 5;
				dIvLen = 8;
				cipherFn = function(key, iv) {
					var cipher = forge.rc2.createDecryptionCipher(key, 40);
					cipher.start(iv, null);
					return cipher;
				};
				break;
			default:
				var error = /* @__PURE__ */ new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
				error.oid = oid;
				throw error;
		}
		var md = prfOidToMessageDigest(capture.prfOid);
		var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
		md.start();
		var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
		return cipherFn(key, iv);
	};
	/**
	* OpenSSL's legacy key derivation function.
	*
	* See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
	*
	* @param password the password to derive the key from.
	* @param salt the salt to use, null for none.
	* @param dkLen the number of bytes needed for the derived key.
	* @param [options] the options to use:
	*          [md] an optional message digest object to use.
	*/
	pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
		if (typeof md === "undefined" || md === null) {
			if (!("md5" in forge.md)) throw new Error("\"md5\" hash algorithm unavailable.");
			md = forge.md.md5.create();
		}
		if (salt === null) salt = "";
		var digests = [hash(md, password + salt)];
		for (var length = 16, i = 1; length < dkLen; ++i, length += 16) digests.push(hash(md, digests[i - 1] + password + salt));
		return digests.join("").substr(0, dkLen);
	};
	function hash(md, bytes) {
		return md.start().update(bytes).digest().getBytes();
	}
	function prfOidToMessageDigest(prfOid) {
		var prfAlgorithm;
		if (!prfOid) prfAlgorithm = "hmacWithSHA1";
		else {
			prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
			if (!prfAlgorithm) {
				var error = /* @__PURE__ */ new Error("Unsupported PRF OID.");
				error.oid = prfOid;
				error.supported = [
					"hmacWithSHA1",
					"hmacWithSHA224",
					"hmacWithSHA256",
					"hmacWithSHA384",
					"hmacWithSHA512"
				];
				throw error;
			}
		}
		return prfAlgorithmToMessageDigest(prfAlgorithm);
	}
	function prfAlgorithmToMessageDigest(prfAlgorithm) {
		var factory = forge.md;
		switch (prfAlgorithm) {
			case "hmacWithSHA224": factory = forge.md.sha512;
			case "hmacWithSHA1":
			case "hmacWithSHA256":
			case "hmacWithSHA384":
			case "hmacWithSHA512":
				prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
				break;
			default:
				var error = /* @__PURE__ */ new Error("Unsupported PRF algorithm.");
				error.algorithm = prfAlgorithm;
				error.supported = [
					"hmacWithSHA1",
					"hmacWithSHA224",
					"hmacWithSHA256",
					"hmacWithSHA384",
					"hmacWithSHA512"
				];
				throw error;
		}
		if (!factory || !(prfAlgorithm in factory)) throw new Error("Unknown hash algorithm: " + prfAlgorithm);
		return factory[prfAlgorithm].create();
	}
	function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
		var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())]);
		if (prfAlgorithm !== "hmacWithSHA1") params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]));
		return params;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
	*
	* @author Dave Longley
	* @author Stefan Siegl
	*
	* Copyright (c) 2012-2015 Digital Bazaar, Inc.
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*
	* The ASN.1 representation of PKCS#7 is as follows
	* (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
	*
	* A PKCS#7 message consists of a ContentInfo on root level, which may
	* contain any number of further ContentInfo nested into it.
	*
	* ContentInfo ::= SEQUENCE {
	*   contentType                ContentType,
	*   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
	* }
	*
	* ContentType ::= OBJECT IDENTIFIER
	*
	* EnvelopedData ::= SEQUENCE {
	*   version                    Version,
	*   recipientInfos             RecipientInfos,
	*   encryptedContentInfo       EncryptedContentInfo
	* }
	*
	* EncryptedData ::= SEQUENCE {
	*   version                    Version,
	*   encryptedContentInfo       EncryptedContentInfo
	* }
	*
	* id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
	*   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
	*
	* SignedData ::= SEQUENCE {
	*   version           INTEGER,
	*   digestAlgorithms  DigestAlgorithmIdentifiers,
	*   contentInfo       ContentInfo,
	*   certificates      [0] IMPLICIT Certificates OPTIONAL,
	*   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
	*   signerInfos       SignerInfos
	* }
	*
	* SignerInfos ::= SET OF SignerInfo
	*
	* SignerInfo ::= SEQUENCE {
	*   version                    Version,
	*   issuerAndSerialNumber      IssuerAndSerialNumber,
	*   digestAlgorithm            DigestAlgorithmIdentifier,
	*   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
	*   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
	*   encryptedDigest            EncryptedDigest,
	*   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
	* }
	*
	* EncryptedDigest ::= OCTET STRING
	*
	* Attributes ::= SET OF Attribute
	*
	* Attribute ::= SEQUENCE {
	*   attrType    OBJECT IDENTIFIER,
	*   attrValues  SET OF AttributeValue
	* }
	*
	* AttributeValue ::= ANY
	*
	* Version ::= INTEGER
	*
	* RecipientInfos ::= SET OF RecipientInfo
	*
	* EncryptedContentInfo ::= SEQUENCE {
	*   contentType                 ContentType,
	*   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
	*   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
	* }
	*
	* ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
	*
	* The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
	* for the algorithm, if any. In the case of AES and DES3, there is only one,
	* the IV.
	*
	* AlgorithmIdentifer ::= SEQUENCE {
	*    algorithm OBJECT IDENTIFIER,
	*    parameters ANY DEFINED BY algorithm OPTIONAL
	* }
	*
	* EncryptedContent ::= OCTET STRING
	*
	* RecipientInfo ::= SEQUENCE {
	*   version                     Version,
	*   issuerAndSerialNumber       IssuerAndSerialNumber,
	*   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
	*   encryptedKey                EncryptedKey
	* }
	*
	* IssuerAndSerialNumber ::= SEQUENCE {
	*   issuer                      Name,
	*   serialNumber                CertificateSerialNumber
	* }
	*
	* CertificateSerialNumber ::= INTEGER
	*
	* KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
	*
	* EncryptedKey ::= OCTET STRING
	*/
	var forge = require_forge();
	require_asn1();
	require_util();
	var asn1 = forge.asn1;
	var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
	forge.pkcs7 = forge.pkcs7 || {};
	forge.pkcs7.asn1 = p7v;
	var contentInfoValidator = {
		name: "ContentInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "ContentInfo.ContentType",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OID,
			constructed: false,
			capture: "contentType"
		}, {
			name: "ContentInfo.content",
			tagClass: asn1.Class.CONTEXT_SPECIFIC,
			type: 0,
			constructed: true,
			optional: true,
			captureAsn1: "content"
		}]
	};
	p7v.contentInfoValidator = contentInfoValidator;
	var encryptedContentInfoValidator = {
		name: "EncryptedContentInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "EncryptedContentInfo.contentType",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "contentType"
			},
			{
				name: "EncryptedContentInfo.contentEncryptionAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "encAlgorithm"
				}, {
					name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
					tagClass: asn1.Class.UNIVERSAL,
					captureAsn1: "encParameter"
				}]
			},
			{
				name: "EncryptedContentInfo.encryptedContent",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				capture: "encryptedContent",
				captureAsn1: "encryptedContentAsn1"
			}
		]
	};
	p7v.envelopedDataValidator = {
		name: "EnvelopedData",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "EnvelopedData.Version",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "version"
		}, {
			name: "EnvelopedData.RecipientInfos",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SET,
			constructed: true,
			captureAsn1: "recipientInfos"
		}].concat(encryptedContentInfoValidator)
	};
	p7v.encryptedDataValidator = {
		name: "EncryptedData",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "EncryptedData.Version",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.INTEGER,
			constructed: false,
			capture: "version"
		}].concat(encryptedContentInfoValidator)
	};
	var signerValidator = {
		name: "SignerInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "SignerInfo.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false
			},
			{
				name: "SignerInfo.issuerAndSerialNumber",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "SignerInfo.issuerAndSerialNumber.issuer",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.SEQUENCE,
					constructed: true,
					captureAsn1: "issuer"
				}, {
					name: "SignerInfo.issuerAndSerialNumber.serialNumber",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.INTEGER,
					constructed: false,
					capture: "serial"
				}]
			},
			{
				name: "SignerInfo.digestAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "SignerInfo.digestAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "digestAlgorithm"
				}, {
					name: "SignerInfo.digestAlgorithm.parameter",
					tagClass: asn1.Class.UNIVERSAL,
					constructed: false,
					captureAsn1: "digestParameter",
					optional: true
				}]
			},
			{
				name: "SignerInfo.authenticatedAttributes",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				constructed: true,
				optional: true,
				capture: "authenticatedAttributes"
			},
			{
				name: "SignerInfo.digestEncryptionAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				capture: "signatureAlgorithm"
			},
			{
				name: "SignerInfo.encryptedDigest",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "signature"
			},
			{
				name: "SignerInfo.unauthenticatedAttributes",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 1,
				constructed: true,
				optional: true,
				capture: "unauthenticatedAttributes"
			}
		]
	};
	p7v.signedDataValidator = {
		name: "SignedData",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "SignedData.Version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "version"
			},
			{
				name: "SignedData.DigestAlgorithms",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SET,
				constructed: true,
				captureAsn1: "digestAlgorithms"
			},
			contentInfoValidator,
			{
				name: "SignedData.Certificates",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				optional: true,
				captureAsn1: "certificates"
			},
			{
				name: "SignedData.CertificateRevocationLists",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 1,
				optional: true,
				captureAsn1: "crls"
			},
			{
				name: "SignedData.SignerInfos",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SET,
				capture: "signerInfos",
				optional: true,
				value: [signerValidator]
			}
		]
	};
	p7v.recipientInfoValidator = {
		name: "RecipientInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "RecipientInfo.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "version"
			},
			{
				name: "RecipientInfo.issuerAndSerial",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "RecipientInfo.issuerAndSerial.issuer",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.SEQUENCE,
					constructed: true,
					captureAsn1: "issuer"
				}, {
					name: "RecipientInfo.issuerAndSerial.serialNumber",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.INTEGER,
					constructed: false,
					capture: "serial"
				}]
			},
			{
				name: "RecipientInfo.keyEncryptionAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "encAlgorithm"
				}, {
					name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
					tagClass: asn1.Class.UNIVERSAL,
					constructed: false,
					captureAsn1: "encParameter",
					optional: true
				}]
			},
			{
				name: "RecipientInfo.encryptedKey",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "encKey"
			}
		]
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/mgf1.js
var require_mgf1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of mask generation function MGF1.
	*
	* @author Stefan Siegl
	* @author Dave Longley
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	* Copyright (c) 2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	forge.mgf = forge.mgf || {};
	var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
	/**
	* Creates a MGF1 mask generation function object.
	*
	* @param md the message digest API to use (eg: forge.md.sha1.create()).
	*
	* @return a mask generation function object.
	*/
	mgf1.create = function(md) {
		return { generate: function(seed, maskLen) {
			var t = new forge.util.ByteBuffer();
			var len = Math.ceil(maskLen / md.digestLength);
			for (var i = 0; i < len; i++) {
				var c = new forge.util.ByteBuffer();
				c.putInt32(i);
				md.start();
				md.update(seed + c.getBytes());
				t.putBuffer(md.digest());
			}
			t.truncate(t.length() - maskLen);
			return t.getBytes();
		} };
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/mgf.js
var require_mgf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for Forge mask generation functions.
	*
	* @author Stefan Siegl
	*
	* Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
	*/
	var forge = require_forge();
	require_mgf1();
	module.exports = forge.mgf = forge.mgf || {};
	forge.mgf.mgf1 = forge.mgf1;
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/pss.js
var require_pss = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of PKCS#1 PSS signature padding.
	*
	* @author Stefan Siegl
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*/
	var forge = require_forge();
	require_random();
	require_util();
	var pss = module.exports = forge.pss = forge.pss || {};
	/**
	* Creates a PSS signature scheme object.
	*
	* There are several ways to provide a salt for encoding:
	*
	* 1. Specify the saltLength only and the built-in PRNG will generate it.
	* 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
	*   will be used.
	* 3. Specify the salt itself as a forge.util.ByteBuffer.
	*
	* @param options the options to use:
	*          md the message digest object to use, a forge md instance.
	*          mgf the mask generation function to use, a forge mgf instance.
	*          [saltLength] the length of the salt in octets.
	*          [prng] the pseudo-random number generator to use to produce a salt.
	*          [salt] the salt to use when encoding.
	*
	* @return a signature scheme object.
	*/
	pss.create = function(options) {
		if (arguments.length === 3) options = {
			md: arguments[0],
			mgf: arguments[1],
			saltLength: arguments[2]
		};
		var hash = options.md;
		var mgf = options.mgf;
		var hLen = hash.digestLength;
		var salt_ = options.salt || null;
		if (typeof salt_ === "string") salt_ = forge.util.createBuffer(salt_);
		var sLen;
		if ("saltLength" in options) sLen = options.saltLength;
		else if (salt_ !== null) sLen = salt_.length();
		else throw new Error("Salt length not specified or specific salt not given.");
		if (salt_ !== null && salt_.length() !== sLen) throw new Error("Given salt length does not match length of given salt.");
		var prng = options.prng || forge.random;
		var pssobj = {};
		/**
		* Encodes a PSS signature.
		*
		* This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
		*
		* @param md the message digest object with the hash to sign.
		* @param modsBits the length of the RSA modulus in bits.
		*
		* @return the encoded message as a binary-encoded string of length
		*           ceil((modBits - 1) / 8).
		*/
		pssobj.encode = function(md, modBits) {
			var i;
			var emBits = modBits - 1;
			var emLen = Math.ceil(emBits / 8);
			var mHash = md.digest().getBytes();
			if (emLen < hLen + sLen + 2) throw new Error("Message is too long to encrypt.");
			var salt;
			if (salt_ === null) salt = prng.getBytesSync(sLen);
			else salt = salt_.bytes();
			var m_ = new forge.util.ByteBuffer();
			m_.fillWithByte(0, 8);
			m_.putBytes(mHash);
			m_.putBytes(salt);
			hash.start();
			hash.update(m_.getBytes());
			var h = hash.digest().getBytes();
			var ps = new forge.util.ByteBuffer();
			ps.fillWithByte(0, emLen - sLen - hLen - 2);
			ps.putByte(1);
			ps.putBytes(salt);
			var db = ps.getBytes();
			var maskLen = emLen - hLen - 1;
			var dbMask = mgf.generate(h, maskLen);
			var maskedDB = "";
			for (i = 0; i < maskLen; i++) maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
			var mask = 65280 >> 8 * emLen - emBits & 255;
			maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
			return maskedDB + h + String.fromCharCode(188);
		};
		/**
		* Verifies a PSS signature.
		*
		* This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
		*
		* @param mHash the message digest hash, as a binary-encoded string, to
		*         compare against the signature.
		* @param em the encoded message, as a binary-encoded string
		*          (RSA decryption result).
		* @param modsBits the length of the RSA modulus in bits.
		*
		* @return true if the signature was verified, false if not.
		*/
		pssobj.verify = function(mHash, em, modBits) {
			var i;
			var emBits = modBits - 1;
			var emLen = Math.ceil(emBits / 8);
			em = em.substr(-emLen);
			if (emLen < hLen + sLen + 2) throw new Error("Inconsistent parameters to PSS signature verification.");
			if (em.charCodeAt(emLen - 1) !== 188) throw new Error("Encoded message does not end in 0xBC.");
			var maskLen = emLen - hLen - 1;
			var maskedDB = em.substr(0, maskLen);
			var h = em.substr(maskLen, hLen);
			var mask = 65280 >> 8 * emLen - emBits & 255;
			if ((maskedDB.charCodeAt(0) & mask) !== 0) throw new Error("Bits beyond keysize not zero as expected.");
			var dbMask = mgf.generate(h, maskLen);
			var db = "";
			for (i = 0; i < maskLen; i++) db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
			db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
			var checkLen = emLen - hLen - sLen - 2;
			for (i = 0; i < checkLen; i++) if (db.charCodeAt(i) !== 0) throw new Error("Leftmost octets not zero as expected");
			if (db.charCodeAt(checkLen) !== 1) throw new Error("Inconsistent PSS signature, 0x01 marker not found");
			var salt = db.substr(-sLen);
			var m_ = new forge.util.ByteBuffer();
			m_.fillWithByte(0, 8);
			m_.putBytes(mHash);
			m_.putBytes(salt);
			hash.start();
			hash.update(m_.getBytes());
			return h === hash.digest().getBytes();
		};
		return pssobj;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/x509.js
var require_x509 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of X.509 and related components (such as
	* Certification Signing Requests) of a Public Key Infrastructure.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	*
	* The ASN.1 representation of an X.509v3 certificate is as follows
	* (see RFC 2459):
	*
	* Certificate ::= SEQUENCE {
	*   tbsCertificate       TBSCertificate,
	*   signatureAlgorithm   AlgorithmIdentifier,
	*   signatureValue       BIT STRING
	* }
	*
	* TBSCertificate ::= SEQUENCE {
	*   version         [0]  EXPLICIT Version DEFAULT v1,
	*   serialNumber         CertificateSerialNumber,
	*   signature            AlgorithmIdentifier,
	*   issuer               Name,
	*   validity             Validity,
	*   subject              Name,
	*   subjectPublicKeyInfo SubjectPublicKeyInfo,
	*   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
	*                        -- If present, version shall be v2 or v3
	*   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
	*                        -- If present, version shall be v2 or v3
	*   extensions      [3]  EXPLICIT Extensions OPTIONAL
	*                        -- If present, version shall be v3
	* }
	*
	* Version ::= INTEGER  { v1(0), v2(1), v3(2) }
	*
	* CertificateSerialNumber ::= INTEGER
	*
	* Name ::= CHOICE {
	*   // only one possible choice for now
	*   RDNSequence
	* }
	*
	* RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
	*
	* RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
	*
	* AttributeTypeAndValue ::= SEQUENCE {
	*   type     AttributeType,
	*   value    AttributeValue
	* }
	* AttributeType ::= OBJECT IDENTIFIER
	* AttributeValue ::= ANY DEFINED BY AttributeType
	*
	* Validity ::= SEQUENCE {
	*   notBefore      Time,
	*   notAfter       Time
	* }
	*
	* Time ::= CHOICE {
	*   utcTime        UTCTime,
	*   generalTime    GeneralizedTime
	* }
	*
	* UniqueIdentifier ::= BIT STRING
	*
	* SubjectPublicKeyInfo ::= SEQUENCE {
	*   algorithm            AlgorithmIdentifier,
	*   subjectPublicKey     BIT STRING
	* }
	*
	* Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
	*
	* Extension ::= SEQUENCE {
	*   extnID      OBJECT IDENTIFIER,
	*   critical    BOOLEAN DEFAULT FALSE,
	*   extnValue   OCTET STRING
	* }
	*
	* The only key algorithm currently supported for PKI is RSA.
	*
	* RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
	*
	* PKCS#10 v1.7 describes certificate signing requests:
	*
	* CertificationRequestInfo:
	*
	* CertificationRequestInfo ::= SEQUENCE {
	*   version       INTEGER { v1(0) } (v1,...),
	*   subject       Name,
	*   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
	*   attributes    [0] Attributes{{ CRIAttributes }}
	* }
	*
	* Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
	*
	* CRIAttributes  ATTRIBUTE  ::= {
	*   ... -- add any locally defined attributes here -- }
	*
	* Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
	*   type   ATTRIBUTE.&id({IOSet}),
	*   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
	* }
	*
	* CertificationRequest ::= SEQUENCE {
	*   certificationRequestInfo CertificationRequestInfo,
	*   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
	*   signature          BIT STRING
	* }
	*/
	var forge = require_forge();
	require_aes();
	require_asn1();
	require_des();
	require_md();
	require_mgf();
	require_oids();
	require_pem();
	require_pss();
	require_rsa();
	require_util();
	var asn1 = forge.asn1;
	var pki = module.exports = forge.pki = forge.pki || {};
	var oids = pki.oids;
	var _shortNames = {};
	_shortNames["CN"] = oids["commonName"];
	_shortNames["commonName"] = "CN";
	_shortNames["C"] = oids["countryName"];
	_shortNames["countryName"] = "C";
	_shortNames["L"] = oids["localityName"];
	_shortNames["localityName"] = "L";
	_shortNames["ST"] = oids["stateOrProvinceName"];
	_shortNames["stateOrProvinceName"] = "ST";
	_shortNames["O"] = oids["organizationName"];
	_shortNames["organizationName"] = "O";
	_shortNames["OU"] = oids["organizationalUnitName"];
	_shortNames["organizationalUnitName"] = "OU";
	_shortNames["E"] = oids["emailAddress"];
	_shortNames["emailAddress"] = "E";
	var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
	var x509CertificateValidator = {
		name: "Certificate",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "Certificate.TBSCertificate",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				captureAsn1: "tbsCertificate",
				value: [
					{
						name: "Certificate.TBSCertificate.version",
						tagClass: asn1.Class.CONTEXT_SPECIFIC,
						type: 0,
						constructed: true,
						optional: true,
						value: [{
							name: "Certificate.TBSCertificate.version.integer",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.INTEGER,
							constructed: false,
							capture: "certVersion"
						}]
					},
					{
						name: "Certificate.TBSCertificate.serialNumber",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.INTEGER,
						constructed: false,
						capture: "certSerialNumber"
					},
					{
						name: "Certificate.TBSCertificate.signature",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						value: [{
							name: "Certificate.TBSCertificate.signature.algorithm",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.OID,
							constructed: false,
							capture: "certinfoSignatureOid"
						}, {
							name: "Certificate.TBSCertificate.signature.parameters",
							tagClass: asn1.Class.UNIVERSAL,
							optional: true,
							captureAsn1: "certinfoSignatureParams"
						}]
					},
					{
						name: "Certificate.TBSCertificate.issuer",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						captureAsn1: "certIssuer"
					},
					{
						name: "Certificate.TBSCertificate.validity",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						value: [
							{
								name: "Certificate.TBSCertificate.validity.notBefore (utc)",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.UTCTIME,
								constructed: false,
								optional: true,
								capture: "certValidity1UTCTime"
							},
							{
								name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.GENERALIZEDTIME,
								constructed: false,
								optional: true,
								capture: "certValidity2GeneralizedTime"
							},
							{
								name: "Certificate.TBSCertificate.validity.notAfter (utc)",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.UTCTIME,
								constructed: false,
								optional: true,
								capture: "certValidity3UTCTime"
							},
							{
								name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.GENERALIZEDTIME,
								constructed: false,
								optional: true,
								capture: "certValidity4GeneralizedTime"
							}
						]
					},
					{
						name: "Certificate.TBSCertificate.subject",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						captureAsn1: "certSubject"
					},
					publicKeyValidator,
					{
						name: "Certificate.TBSCertificate.issuerUniqueID",
						tagClass: asn1.Class.CONTEXT_SPECIFIC,
						type: 1,
						constructed: true,
						optional: true,
						value: [{
							name: "Certificate.TBSCertificate.issuerUniqueID.id",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.BITSTRING,
							constructed: false,
							captureBitStringValue: "certIssuerUniqueId"
						}]
					},
					{
						name: "Certificate.TBSCertificate.subjectUniqueID",
						tagClass: asn1.Class.CONTEXT_SPECIFIC,
						type: 2,
						constructed: true,
						optional: true,
						value: [{
							name: "Certificate.TBSCertificate.subjectUniqueID.id",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.BITSTRING,
							constructed: false,
							captureBitStringValue: "certSubjectUniqueId"
						}]
					},
					{
						name: "Certificate.TBSCertificate.extensions",
						tagClass: asn1.Class.CONTEXT_SPECIFIC,
						type: 3,
						constructed: true,
						captureAsn1: "certExtensions",
						optional: true
					}
				]
			},
			{
				name: "Certificate.signatureAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "Certificate.signatureAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "certSignatureOid"
				}, {
					name: "Certificate.TBSCertificate.signature.parameters",
					tagClass: asn1.Class.UNIVERSAL,
					optional: true,
					captureAsn1: "certSignatureParams"
				}]
			},
			{
				name: "Certificate.signatureValue",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.BITSTRING,
				constructed: false,
				captureBitStringValue: "certSignature"
			}
		]
	};
	var rsassaPssParameterValidator = {
		name: "rsapss",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "rsapss.hashAlgorithm",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				constructed: true,
				value: [{
					name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Class.SEQUENCE,
					constructed: true,
					optional: true,
					value: [{
						name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OID,
						constructed: false,
						capture: "hashOid"
					}]
				}]
			},
			{
				name: "rsapss.maskGenAlgorithm",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 1,
				constructed: true,
				value: [{
					name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Class.SEQUENCE,
					constructed: true,
					optional: true,
					value: [{
						name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OID,
						constructed: false,
						capture: "maskGenOid"
					}, {
						name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						value: [{
							name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.OID,
							constructed: false,
							capture: "maskGenHashOid"
						}]
					}]
				}]
			},
			{
				name: "rsapss.saltLength",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 2,
				optional: true,
				value: [{
					name: "rsapss.saltLength.saltLength",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Class.INTEGER,
					constructed: false,
					capture: "saltLength"
				}]
			},
			{
				name: "rsapss.trailerField",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 3,
				optional: true,
				value: [{
					name: "rsapss.trailer.trailer",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Class.INTEGER,
					constructed: false,
					capture: "trailer"
				}]
			}
		]
	};
	var certificationRequestInfoValidator = {
		name: "CertificationRequestInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		captureAsn1: "certificationRequestInfo",
		value: [
			{
				name: "CertificationRequestInfo.integer",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "certificationRequestInfoVersion"
			},
			{
				name: "CertificationRequestInfo.subject",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				captureAsn1: "certificationRequestInfoSubject"
			},
			publicKeyValidator,
			{
				name: "CertificationRequestInfo.attributes",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				type: 0,
				constructed: true,
				optional: true,
				capture: "certificationRequestInfoAttributes",
				value: [{
					name: "CertificationRequestInfo.attributes",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.SEQUENCE,
					constructed: true,
					value: [{
						name: "CertificationRequestInfo.attributes.type",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OID,
						constructed: false
					}, {
						name: "CertificationRequestInfo.attributes.value",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SET,
						constructed: true
					}]
				}]
			}
		]
	};
	var certificationRequestValidator = {
		name: "CertificationRequest",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		captureAsn1: "csr",
		value: [
			certificationRequestInfoValidator,
			{
				name: "CertificationRequest.signatureAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "CertificationRequest.signatureAlgorithm.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "csrSignatureOid"
				}, {
					name: "CertificationRequest.signatureAlgorithm.parameters",
					tagClass: asn1.Class.UNIVERSAL,
					optional: true,
					captureAsn1: "csrSignatureParams"
				}]
			},
			{
				name: "CertificationRequest.signature",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.BITSTRING,
				constructed: false,
				captureBitStringValue: "csrSignature"
			}
		]
	};
	/**
	* Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
	* sets into an array with objects that have type and value properties.
	*
	* @param rdn the RDNSequence to convert.
	* @param md a message digest to append type and value to if provided.
	*/
	pki.RDNAttributesAsArray = function(rdn, md) {
		var rval = [];
		var set, attr, obj;
		for (var si = 0; si < rdn.value.length; ++si) {
			set = rdn.value[si];
			for (var i = 0; i < set.value.length; ++i) {
				obj = {};
				attr = set.value[i];
				obj.type = asn1.derToOid(attr.value[0].value);
				obj.value = attr.value[1].value;
				obj.valueTagClass = attr.value[1].type;
				if (obj.type in oids) {
					obj.name = oids[obj.type];
					if (obj.name in _shortNames) obj.shortName = _shortNames[obj.name];
				}
				if (md) {
					md.update(obj.type);
					md.update(obj.value);
				}
				rval.push(obj);
			}
		}
		return rval;
	};
	/**
	* Converts ASN.1 CRIAttributes into an array with objects that have type and
	* value properties.
	*
	* @param attributes the CRIAttributes to convert.
	*/
	pki.CRIAttributesAsArray = function(attributes) {
		var rval = [];
		for (var si = 0; si < attributes.length; ++si) {
			var seq = attributes[si];
			var type = asn1.derToOid(seq.value[0].value);
			var values = seq.value[1].value;
			for (var vi = 0; vi < values.length; ++vi) {
				var obj = {};
				obj.type = type;
				obj.value = values[vi].value;
				obj.valueTagClass = values[vi].type;
				if (obj.type in oids) {
					obj.name = oids[obj.type];
					if (obj.name in _shortNames) obj.shortName = _shortNames[obj.name];
				}
				if (obj.type === oids.extensionRequest) {
					obj.extensions = [];
					for (var ei = 0; ei < obj.value.length; ++ei) obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
				}
				rval.push(obj);
			}
		}
		return rval;
	};
	/**
	* Gets an issuer or subject attribute from its name, type, or short name.
	*
	* @param obj the issuer or subject object.
	* @param options a short name string or an object with:
	*          shortName the short name for the attribute.
	*          name the name for the attribute.
	*          type the type for the attribute.
	*
	* @return the attribute.
	*/
	function _getAttribute(obj, options) {
		if (typeof options === "string") options = { shortName: options };
		var rval = null;
		var attr;
		for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
			attr = obj.attributes[i];
			if (options.type && options.type === attr.type) rval = attr;
			else if (options.name && options.name === attr.name) rval = attr;
			else if (options.shortName && options.shortName === attr.shortName) rval = attr;
		}
		return rval;
	}
	/**
	* Converts signature parameters from ASN.1 structure.
	*
	* Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
	* no parameters.
	*
	* RSASSA-PSS-params  ::=  SEQUENCE  {
	*   hashAlgorithm      [0] HashAlgorithm DEFAULT
	*                             sha1Identifier,
	*   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
	*                             mgf1SHA1Identifier,
	*   saltLength         [2] INTEGER DEFAULT 20,
	*   trailerField       [3] INTEGER DEFAULT 1
	* }
	*
	* HashAlgorithm  ::=  AlgorithmIdentifier
	*
	* MaskGenAlgorithm  ::=  AlgorithmIdentifier
	*
	* AlgorithmIdentifer ::= SEQUENCE {
	*   algorithm OBJECT IDENTIFIER,
	*   parameters ANY DEFINED BY algorithm OPTIONAL
	* }
	*
	* @param oid The OID specifying the signature algorithm
	* @param obj The ASN.1 structure holding the parameters
	* @param fillDefaults Whether to use return default values where omitted
	* @return signature parameter object
	*/
	var _readSignatureParameters = function(oid, obj, fillDefaults) {
		var params = {};
		if (oid !== oids["RSASSA-PSS"]) return params;
		if (fillDefaults) params = {
			hash: { algorithmOid: oids["sha1"] },
			mgf: {
				algorithmOid: oids["mgf1"],
				hash: { algorithmOid: oids["sha1"] }
			},
			saltLength: 20
		};
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read RSASSA-PSS parameter block.");
			error.errors = errors;
			throw error;
		}
		if (capture.hashOid !== void 0) {
			params.hash = params.hash || {};
			params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
		}
		if (capture.maskGenOid !== void 0) {
			params.mgf = params.mgf || {};
			params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
			params.mgf.hash = params.mgf.hash || {};
			params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
		}
		if (capture.saltLength !== void 0) params.saltLength = capture.saltLength.charCodeAt(0);
		return params;
	};
	/**
	* Create signature digest for OID.
	*
	* @param options
	*   signatureOid: the OID specifying the signature algorithm.
	*   type: a human readable type for error messages
	* @return a created md instance. throws if unknown oid.
	*/
	var _createSignatureDigest = function(options) {
		switch (oids[options.signatureOid]) {
			case "sha1WithRSAEncryption":
			case "sha1WithRSASignature": return forge.md.sha1.create();
			case "md5WithRSAEncryption": return forge.md.md5.create();
			case "sha256WithRSAEncryption": return forge.md.sha256.create();
			case "sha384WithRSAEncryption": return forge.md.sha384.create();
			case "sha512WithRSAEncryption": return forge.md.sha512.create();
			case "RSASSA-PSS": return forge.md.sha256.create();
			default:
				var error = /* @__PURE__ */ new Error("Could not compute " + options.type + " digest. Unknown signature OID.");
				error.signatureOid = options.signatureOid;
				throw error;
		}
	};
	/**
	* Verify signature on certificate or CSR.
	*
	* @param options:
	*   certificate the certificate or CSR to verify.
	*   md the signature digest.
	*   signature the signature
	* @return a created md instance. throws if unknown oid.
	*/
	var _verifySignature = function(options) {
		var cert = options.certificate;
		var scheme;
		switch (cert.signatureOid) {
			case oids.sha1WithRSAEncryption:
			case oids.sha1WithRSASignature: break;
			case oids["RSASSA-PSS"]:
				var hash = oids[cert.signatureParameters.mgf.hash.algorithmOid], mgf;
				if (hash === void 0 || forge.md[hash] === void 0) {
					var error = /* @__PURE__ */ new Error("Unsupported MGF hash function.");
					error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
					error.name = hash;
					throw error;
				}
				mgf = oids[cert.signatureParameters.mgf.algorithmOid];
				if (mgf === void 0 || forge.mgf[mgf] === void 0) {
					var error = /* @__PURE__ */ new Error("Unsupported MGF function.");
					error.oid = cert.signatureParameters.mgf.algorithmOid;
					error.name = mgf;
					throw error;
				}
				mgf = forge.mgf[mgf].create(forge.md[hash].create());
				hash = oids[cert.signatureParameters.hash.algorithmOid];
				if (hash === void 0 || forge.md[hash] === void 0) {
					var error = /* @__PURE__ */ new Error("Unsupported RSASSA-PSS hash function.");
					error.oid = cert.signatureParameters.hash.algorithmOid;
					error.name = hash;
					throw error;
				}
				scheme = forge.pss.create(forge.md[hash].create(), mgf, cert.signatureParameters.saltLength);
				break;
		}
		return cert.publicKey.verify(options.md.digest().getBytes(), options.signature, scheme);
	};
	/**
	* Converts an X.509 certificate from PEM format.
	*
	* Note: If the certificate is to be verified then compute hash should
	* be set to true. This will scan the TBSCertificate part of the ASN.1
	* object while it is converted so it doesn't need to be converted back
	* to ASN.1-DER-encoding later.
	*
	* @param pem the PEM-formatted certificate.
	* @param computeHash true to compute the hash for verification.
	* @param strict true to be strict when checking ASN.1 value lengths, false to
	*          allow truncated values (default: true).
	*
	* @return the certificate.
	*/
	pki.certificateFromPem = function(pem, computeHash, strict) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
			var error = /* @__PURE__ */ new Error("Could not convert certificate from PEM; PEM header type is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".");
			error.headerType = msg.type;
			throw error;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body, strict);
		return pki.certificateFromAsn1(obj, computeHash);
	};
	/**
	* Converts an X.509 certificate to PEM format.
	*
	* @param cert the certificate.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted certificate.
	*/
	pki.certificateToPem = function(cert, maxline) {
		var msg = {
			type: "CERTIFICATE",
			body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Converts an RSA public key from PEM format.
	*
	* @param pem the PEM-formatted public key.
	*
	* @return the public key.
	*/
	pki.publicKeyFromPem = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
			var error = /* @__PURE__ */ new Error("Could not convert public key from PEM; PEM header type is not \"PUBLIC KEY\" or \"RSA PUBLIC KEY\".");
			error.headerType = msg.type;
			throw error;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert public key from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body);
		return pki.publicKeyFromAsn1(obj);
	};
	/**
	* Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
	*
	* @param key the public key.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted public key.
	*/
	pki.publicKeyToPem = function(key, maxline) {
		var msg = {
			type: "PUBLIC KEY",
			body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Converts an RSA public key to PEM format (using an RSAPublicKey).
	*
	* @param key the public key.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted public key.
	*/
	pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
		var msg = {
			type: "RSA PUBLIC KEY",
			body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Gets a fingerprint for the given public key.
	*
	* @param options the options to use.
	*          [md] the message digest object to use (defaults to forge.md.sha1).
	*          [type] the type of fingerprint, such as 'RSAPublicKey',
	*            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
	*          [encoding] an alternative output encoding, such as 'hex'
	*            (defaults to none, outputs a byte buffer).
	*          [delimiter] the delimiter to use between bytes for 'hex' encoded
	*            output, eg: ':' (defaults to none).
	*
	* @return the fingerprint as a byte buffer or other encoding based on options.
	*/
	pki.getPublicKeyFingerprint = function(key, options) {
		options = options || {};
		var md = options.md || forge.md.sha1.create();
		var type = options.type || "RSAPublicKey";
		var bytes;
		switch (type) {
			case "RSAPublicKey":
				bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
				break;
			case "SubjectPublicKeyInfo":
				bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
				break;
			default: throw new Error("Unknown fingerprint type \"" + options.type + "\".");
		}
		md.start();
		md.update(bytes);
		var digest = md.digest();
		if (options.encoding === "hex") {
			var hex = digest.toHex();
			if (options.delimiter) return hex.match(/.{2}/g).join(options.delimiter);
			return hex;
		} else if (options.encoding === "binary") return digest.getBytes();
		else if (options.encoding) throw new Error("Unknown encoding \"" + options.encoding + "\".");
		return digest;
	};
	/**
	* Converts a PKCS#10 certification request (CSR) from PEM format.
	*
	* Note: If the certification request is to be verified then compute hash
	* should be set to true. This will scan the CertificationRequestInfo part of
	* the ASN.1 object while it is converted so it doesn't need to be converted
	* back to ASN.1-DER-encoding later.
	*
	* @param pem the PEM-formatted certificate.
	* @param computeHash true to compute the hash for verification.
	* @param strict true to be strict when checking ASN.1 value lengths, false to
	*          allow truncated values (default: true).
	*
	* @return the certification request (CSR).
	*/
	pki.certificationRequestFromPem = function(pem, computeHash, strict) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "CERTIFICATE REQUEST") {
			var error = /* @__PURE__ */ new Error("Could not convert certification request from PEM; PEM header type is not \"CERTIFICATE REQUEST\".");
			error.headerType = msg.type;
			throw error;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body, strict);
		return pki.certificationRequestFromAsn1(obj, computeHash);
	};
	/**
	* Converts a PKCS#10 certification request (CSR) to PEM format.
	*
	* @param csr the certification request.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted certification request.
	*/
	pki.certificationRequestToPem = function(csr, maxline) {
		var msg = {
			type: "CERTIFICATE REQUEST",
			body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Creates an empty X.509v3 RSA certificate.
	*
	* @return the certificate.
	*/
	pki.createCertificate = function() {
		var cert = {};
		cert.version = 2;
		cert.serialNumber = "00";
		cert.signatureOid = null;
		cert.signature = null;
		cert.siginfo = {};
		cert.siginfo.algorithmOid = null;
		cert.validity = {};
		cert.validity.notBefore = /* @__PURE__ */ new Date();
		cert.validity.notAfter = /* @__PURE__ */ new Date();
		cert.issuer = {};
		cert.issuer.getField = function(sn) {
			return _getAttribute(cert.issuer, sn);
		};
		cert.issuer.addField = function(attr) {
			_fillMissingFields([attr]);
			cert.issuer.attributes.push(attr);
		};
		cert.issuer.attributes = [];
		cert.issuer.hash = null;
		cert.subject = {};
		cert.subject.getField = function(sn) {
			return _getAttribute(cert.subject, sn);
		};
		cert.subject.addField = function(attr) {
			_fillMissingFields([attr]);
			cert.subject.attributes.push(attr);
		};
		cert.subject.attributes = [];
		cert.subject.hash = null;
		cert.extensions = [];
		cert.publicKey = null;
		cert.md = null;
		/**
		* Sets the subject of this certificate.
		*
		* @param attrs the array of subject attributes to use.
		* @param uniqueId an optional a unique ID to use.
		*/
		cert.setSubject = function(attrs, uniqueId) {
			_fillMissingFields(attrs);
			cert.subject.attributes = attrs;
			delete cert.subject.uniqueId;
			if (uniqueId) cert.subject.uniqueId = uniqueId;
			cert.subject.hash = null;
		};
		/**
		* Sets the issuer of this certificate.
		*
		* @param attrs the array of issuer attributes to use.
		* @param uniqueId an optional a unique ID to use.
		*/
		cert.setIssuer = function(attrs, uniqueId) {
			_fillMissingFields(attrs);
			cert.issuer.attributes = attrs;
			delete cert.issuer.uniqueId;
			if (uniqueId) cert.issuer.uniqueId = uniqueId;
			cert.issuer.hash = null;
		};
		/**
		* Sets the extensions of this certificate.
		*
		* @param exts the array of extensions to use.
		*/
		cert.setExtensions = function(exts) {
			for (var i = 0; i < exts.length; ++i) _fillMissingExtensionFields(exts[i], { cert });
			cert.extensions = exts;
		};
		/**
		* Gets an extension by its name or id.
		*
		* @param options the name to use or an object with:
		*          name the name to use.
		*          id the id to use.
		*
		* @return the extension or null if not found.
		*/
		cert.getExtension = function(options) {
			if (typeof options === "string") options = { name: options };
			var rval = null;
			var ext;
			for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
				ext = cert.extensions[i];
				if (options.id && ext.id === options.id) rval = ext;
				else if (options.name && ext.name === options.name) rval = ext;
			}
			return rval;
		};
		/**
		* Signs this certificate using the given private key.
		*
		* @param key the private key to sign with.
		* @param md the message digest object to use (defaults to forge.md.sha1).
		*/
		cert.sign = function(key, md) {
			cert.md = md || forge.md.sha1.create();
			var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
			if (!algorithmOid) {
				var error = /* @__PURE__ */ new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
				error.algorithm = cert.md.algorithm;
				throw error;
			}
			cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
			cert.tbsCertificate = pki.getTBSCertificate(cert);
			var bytes = asn1.toDer(cert.tbsCertificate);
			cert.md.update(bytes.getBytes());
			cert.signature = key.sign(cert.md);
		};
		/**
		* Attempts verify the signature on the passed certificate using this
		* certificate's public key.
		*
		* @param child the certificate to verify.
		*
		* @return true if verified, false if not.
		*/
		cert.verify = function(child) {
			var rval = false;
			if (!cert.issued(child)) {
				var issuer = child.issuer;
				var subject = cert.subject;
				var error = /* @__PURE__ */ new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
				error.expectedIssuer = subject.attributes;
				error.actualIssuer = issuer.attributes;
				throw error;
			}
			var md = child.md;
			if (md === null) {
				md = _createSignatureDigest({
					signatureOid: child.signatureOid,
					type: "certificate"
				});
				var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
				var bytes = asn1.toDer(tbsCertificate);
				md.update(bytes.getBytes());
			}
			if (md !== null) rval = _verifySignature({
				certificate: cert,
				md,
				signature: child.signature
			});
			return rval;
		};
		/**
		* Returns true if this certificate's issuer matches the passed
		* certificate's subject. Note that no signature check is performed.
		*
		* @param parent the certificate to check.
		*
		* @return true if this certificate's issuer matches the passed certificate's
		*         subject.
		*/
		cert.isIssuer = function(parent) {
			var rval = false;
			var i = cert.issuer;
			var s = parent.subject;
			if (i.hash && s.hash) rval = i.hash === s.hash;
			else if (i.attributes.length === s.attributes.length) {
				rval = true;
				var iattr, sattr;
				for (var n = 0; rval && n < i.attributes.length; ++n) {
					iattr = i.attributes[n];
					sattr = s.attributes[n];
					if (iattr.type !== sattr.type || iattr.value !== sattr.value) rval = false;
				}
			}
			return rval;
		};
		/**
		* Returns true if this certificate's subject matches the issuer of the
		* given certificate). Note that not signature check is performed.
		*
		* @param child the certificate to check.
		*
		* @return true if this certificate's subject matches the passed
		*         certificate's issuer.
		*/
		cert.issued = function(child) {
			return child.isIssuer(cert);
		};
		/**
		* Generates the subjectKeyIdentifier for this certificate as byte buffer.
		*
		* @return the subjectKeyIdentifier for this certificate as byte buffer.
		*/
		cert.generateSubjectKeyIdentifier = function() {
			return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
		};
		/**
		* Verifies the subjectKeyIdentifier extension value for this certificate
		* against its public key. If no extension is found, false will be
		* returned.
		*
		* @return true if verified, false if not.
		*/
		cert.verifySubjectKeyIdentifier = function() {
			var oid = oids["subjectKeyIdentifier"];
			for (var i = 0; i < cert.extensions.length; ++i) {
				var ext = cert.extensions[i];
				if (ext.id === oid) {
					var ski = cert.generateSubjectKeyIdentifier().getBytes();
					return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
				}
			}
			return false;
		};
		return cert;
	};
	/**
	* Converts an X.509v3 RSA certificate from an ASN.1 object.
	*
	* Note: If the certificate is to be verified then compute hash should
	* be set to true. There is currently no implementation for converting
	* a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
	* object needs to be scanned before the cert object is created.
	*
	* @param obj the asn1 representation of an X.509v3 RSA certificate.
	* @param computeHash true to compute the hash for verification.
	*
	* @return the certificate.
	*/
	pki.certificateFromAsn1 = function(obj, computeHash) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
			error.errors = errors;
			throw error;
		}
		if (asn1.derToOid(capture.publicKeyOid) !== pki.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
		var cert = pki.createCertificate();
		cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
		cert.serialNumber = forge.util.createBuffer(capture.certSerialNumber).toHex();
		cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
		cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
		cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
		cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
		cert.signature = capture.certSignature;
		var validity = [];
		if (capture.certValidity1UTCTime !== void 0) validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
		if (capture.certValidity2GeneralizedTime !== void 0) validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
		if (capture.certValidity3UTCTime !== void 0) validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
		if (capture.certValidity4GeneralizedTime !== void 0) validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
		if (validity.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
		if (validity.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
		cert.validity.notBefore = validity[0];
		cert.validity.notAfter = validity[1];
		cert.tbsCertificate = capture.tbsCertificate;
		if (computeHash) {
			cert.md = _createSignatureDigest({
				signatureOid: cert.signatureOid,
				type: "certificate"
			});
			var bytes = asn1.toDer(cert.tbsCertificate);
			cert.md.update(bytes.getBytes());
		}
		var imd = forge.md.sha1.create();
		var ibytes = asn1.toDer(capture.certIssuer);
		imd.update(ibytes.getBytes());
		cert.issuer.getField = function(sn) {
			return _getAttribute(cert.issuer, sn);
		};
		cert.issuer.addField = function(attr) {
			_fillMissingFields([attr]);
			cert.issuer.attributes.push(attr);
		};
		cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
		if (capture.certIssuerUniqueId) cert.issuer.uniqueId = capture.certIssuerUniqueId;
		cert.issuer.hash = imd.digest().toHex();
		var smd = forge.md.sha1.create();
		var sbytes = asn1.toDer(capture.certSubject);
		smd.update(sbytes.getBytes());
		cert.subject.getField = function(sn) {
			return _getAttribute(cert.subject, sn);
		};
		cert.subject.addField = function(attr) {
			_fillMissingFields([attr]);
			cert.subject.attributes.push(attr);
		};
		cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
		if (capture.certSubjectUniqueId) cert.subject.uniqueId = capture.certSubjectUniqueId;
		cert.subject.hash = smd.digest().toHex();
		if (capture.certExtensions) cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
		else cert.extensions = [];
		cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
		return cert;
	};
	/**
	* Converts an ASN.1 extensions object (with extension sequences as its
	* values) into an array of extension objects with types and values.
	*
	* Supported extensions:
	*
	* id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
	* KeyUsage ::= BIT STRING {
	*   digitalSignature        (0),
	*   nonRepudiation          (1),
	*   keyEncipherment         (2),
	*   dataEncipherment        (3),
	*   keyAgreement            (4),
	*   keyCertSign             (5),
	*   cRLSign                 (6),
	*   encipherOnly            (7),
	*   decipherOnly            (8)
	* }
	*
	* id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
	* BasicConstraints ::= SEQUENCE {
	*   cA                      BOOLEAN DEFAULT FALSE,
	*   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
	* }
	*
	* subjectAltName EXTENSION ::= {
	*   SYNTAX GeneralNames
	*   IDENTIFIED BY id-ce-subjectAltName
	* }
	*
	* GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
	*
	* GeneralName ::= CHOICE {
	*   otherName      [0] INSTANCE OF OTHER-NAME,
	*   rfc822Name     [1] IA5String,
	*   dNSName        [2] IA5String,
	*   x400Address    [3] ORAddress,
	*   directoryName  [4] Name,
	*   ediPartyName   [5] EDIPartyName,
	*   uniformResourceIdentifier [6] IA5String,
	*   IPAddress      [7] OCTET STRING,
	*   registeredID   [8] OBJECT IDENTIFIER
	* }
	*
	* OTHER-NAME ::= TYPE-IDENTIFIER
	*
	* EDIPartyName ::= SEQUENCE {
	*   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
	*   partyName    [1] DirectoryString {ub-name}
	* }
	*
	* @param exts the extensions ASN.1 with extension sequences to parse.
	*
	* @return the array.
	*/
	pki.certificateExtensionsFromAsn1 = function(exts) {
		var rval = [];
		for (var i = 0; i < exts.value.length; ++i) {
			var extseq = exts.value[i];
			for (var ei = 0; ei < extseq.value.length; ++ei) rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
		}
		return rval;
	};
	/**
	* Parses a single certificate extension from ASN.1.
	*
	* @param ext the extension in ASN.1 format.
	*
	* @return the parsed extension as an object.
	*/
	pki.certificateExtensionFromAsn1 = function(ext) {
		var e = {};
		e.id = asn1.derToOid(ext.value[0].value);
		e.critical = false;
		if (ext.value[1].type === asn1.Type.BOOLEAN) {
			e.critical = ext.value[1].value.charCodeAt(0) !== 0;
			e.value = ext.value[2].value;
		} else e.value = ext.value[1].value;
		if (e.id in oids) {
			e.name = oids[e.id];
			if (e.name === "keyUsage") {
				var ev = asn1.fromDer(e.value);
				var b2 = 0;
				var b3 = 0;
				if (ev.value.length > 1) {
					b2 = ev.value.charCodeAt(1);
					b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
				}
				e.digitalSignature = (b2 & 128) === 128;
				e.nonRepudiation = (b2 & 64) === 64;
				e.keyEncipherment = (b2 & 32) === 32;
				e.dataEncipherment = (b2 & 16) === 16;
				e.keyAgreement = (b2 & 8) === 8;
				e.keyCertSign = (b2 & 4) === 4;
				e.cRLSign = (b2 & 2) === 2;
				e.encipherOnly = (b2 & 1) === 1;
				e.decipherOnly = (b3 & 128) === 128;
			} else if (e.name === "basicConstraints") {
				var ev = asn1.fromDer(e.value);
				if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) e.cA = ev.value[0].value.charCodeAt(0) !== 0;
				else e.cA = false;
				var value = null;
				if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) value = ev.value[0].value;
				else if (ev.value.length > 1) value = ev.value[1].value;
				if (value !== null) e.pathLenConstraint = asn1.derToInteger(value);
			} else if (e.name === "extKeyUsage") {
				var ev = asn1.fromDer(e.value);
				for (var vi = 0; vi < ev.value.length; ++vi) {
					var oid = asn1.derToOid(ev.value[vi].value);
					if (oid in oids) e[oids[oid]] = true;
					else e[oid] = true;
				}
			} else if (e.name === "nsCertType") {
				var ev = asn1.fromDer(e.value);
				var b2 = 0;
				if (ev.value.length > 1) b2 = ev.value.charCodeAt(1);
				e.client = (b2 & 128) === 128;
				e.server = (b2 & 64) === 64;
				e.email = (b2 & 32) === 32;
				e.objsign = (b2 & 16) === 16;
				e.reserved = (b2 & 8) === 8;
				e.sslCA = (b2 & 4) === 4;
				e.emailCA = (b2 & 2) === 2;
				e.objCA = (b2 & 1) === 1;
			} else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
				e.altNames = [];
				var gn;
				var ev = asn1.fromDer(e.value);
				for (var n = 0; n < ev.value.length; ++n) {
					gn = ev.value[n];
					var altName = {
						type: gn.type,
						value: gn.value
					};
					e.altNames.push(altName);
					switch (gn.type) {
						case 1:
						case 2:
						case 6: break;
						case 7:
							altName.ip = forge.util.bytesToIP(gn.value);
							break;
						case 8:
							altName.oid = asn1.derToOid(gn.value);
							break;
						default:
					}
				}
			} else if (e.name === "subjectKeyIdentifier") {
				var ev = asn1.fromDer(e.value);
				e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
			}
		}
		return e;
	};
	/**
	* Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
	*
	* Note: If the certification request is to be verified then compute hash
	* should be set to true. There is currently no implementation for converting
	* a certificate back to ASN.1 so the CertificationRequestInfo part of the
	* ASN.1 object needs to be scanned before the csr object is created.
	*
	* @param obj the asn1 representation of a PKCS#10 certification request (CSR).
	* @param computeHash true to compute the hash for verification.
	*
	* @return the certification request (CSR).
	*/
	pki.certificationRequestFromAsn1 = function(obj, computeHash) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
			error.errors = errors;
			throw error;
		}
		if (asn1.derToOid(capture.publicKeyOid) !== pki.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
		var csr = pki.createCertificationRequest();
		csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
		csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
		csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
		csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
		csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
		csr.signature = capture.csrSignature;
		csr.certificationRequestInfo = capture.certificationRequestInfo;
		if (computeHash) {
			csr.md = _createSignatureDigest({
				signatureOid: csr.signatureOid,
				type: "certification request"
			});
			var bytes = asn1.toDer(csr.certificationRequestInfo);
			csr.md.update(bytes.getBytes());
		}
		var smd = forge.md.sha1.create();
		csr.subject.getField = function(sn) {
			return _getAttribute(csr.subject, sn);
		};
		csr.subject.addField = function(attr) {
			_fillMissingFields([attr]);
			csr.subject.attributes.push(attr);
		};
		csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
		csr.subject.hash = smd.digest().toHex();
		csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
		csr.getAttribute = function(sn) {
			return _getAttribute(csr, sn);
		};
		csr.addAttribute = function(attr) {
			_fillMissingFields([attr]);
			csr.attributes.push(attr);
		};
		csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
		return csr;
	};
	/**
	* Creates an empty certification request (a CSR or certificate signing
	* request). Once created, its public key and attributes can be set and then
	* it can be signed.
	*
	* @return the empty certification request.
	*/
	pki.createCertificationRequest = function() {
		var csr = {};
		csr.version = 0;
		csr.signatureOid = null;
		csr.signature = null;
		csr.siginfo = {};
		csr.siginfo.algorithmOid = null;
		csr.subject = {};
		csr.subject.getField = function(sn) {
			return _getAttribute(csr.subject, sn);
		};
		csr.subject.addField = function(attr) {
			_fillMissingFields([attr]);
			csr.subject.attributes.push(attr);
		};
		csr.subject.attributes = [];
		csr.subject.hash = null;
		csr.publicKey = null;
		csr.attributes = [];
		csr.getAttribute = function(sn) {
			return _getAttribute(csr, sn);
		};
		csr.addAttribute = function(attr) {
			_fillMissingFields([attr]);
			csr.attributes.push(attr);
		};
		csr.md = null;
		/**
		* Sets the subject of this certification request.
		*
		* @param attrs the array of subject attributes to use.
		*/
		csr.setSubject = function(attrs) {
			_fillMissingFields(attrs);
			csr.subject.attributes = attrs;
			csr.subject.hash = null;
		};
		/**
		* Sets the attributes of this certification request.
		*
		* @param attrs the array of attributes to use.
		*/
		csr.setAttributes = function(attrs) {
			_fillMissingFields(attrs);
			csr.attributes = attrs;
		};
		/**
		* Signs this certification request using the given private key.
		*
		* @param key the private key to sign with.
		* @param md the message digest object to use (defaults to forge.md.sha1).
		*/
		csr.sign = function(key, md) {
			csr.md = md || forge.md.sha1.create();
			var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
			if (!algorithmOid) {
				var error = /* @__PURE__ */ new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
				error.algorithm = csr.md.algorithm;
				throw error;
			}
			csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
			csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
			var bytes = asn1.toDer(csr.certificationRequestInfo);
			csr.md.update(bytes.getBytes());
			csr.signature = key.sign(csr.md);
		};
		/**
		* Attempts verify the signature on the passed certification request using
		* its public key.
		*
		* A CSR that has been exported to a file in PEM format can be verified using
		* OpenSSL using this command:
		*
		* openssl req -in <the-csr-pem-file> -verify -noout -text
		*
		* @return true if verified, false if not.
		*/
		csr.verify = function() {
			var rval = false;
			var md = csr.md;
			if (md === null) {
				md = _createSignatureDigest({
					signatureOid: csr.signatureOid,
					type: "certification request"
				});
				var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
				var bytes = asn1.toDer(cri);
				md.update(bytes.getBytes());
			}
			if (md !== null) rval = _verifySignature({
				certificate: csr,
				md,
				signature: csr.signature
			});
			return rval;
		};
		return csr;
	};
	/**
	* Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
	*
	* @param obj the subject or issuer (distinguished name).
	*
	* @return the ASN.1 RDNSequence.
	*/
	function _dnToAsn1(obj) {
		var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		var attr, set;
		var attrs = obj.attributes;
		for (var i = 0; i < attrs.length; ++i) {
			attr = attrs[i];
			var value = attr.value;
			var valueTagClass = asn1.Type.PRINTABLESTRING;
			if ("valueTagClass" in attr) {
				valueTagClass = attr.valueTagClass;
				if (valueTagClass === asn1.Type.UTF8) value = forge.util.encodeUtf8(value);
			}
			set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)])]);
			rval.value.push(set);
		}
		return rval;
	}
	/**
	* Fills in missing fields in attributes.
	*
	* @param attrs the attributes to fill missing fields in.
	*/
	function _fillMissingFields(attrs) {
		var attr;
		for (var i = 0; i < attrs.length; ++i) {
			attr = attrs[i];
			if (typeof attr.name === "undefined") {
				if (attr.type && attr.type in pki.oids) attr.name = pki.oids[attr.type];
				else if (attr.shortName && attr.shortName in _shortNames) attr.name = pki.oids[_shortNames[attr.shortName]];
			}
			if (typeof attr.type === "undefined") if (attr.name && attr.name in pki.oids) attr.type = pki.oids[attr.name];
			else {
				var error = /* @__PURE__ */ new Error("Attribute type not specified.");
				error.attribute = attr;
				throw error;
			}
			if (typeof attr.shortName === "undefined") {
				if (attr.name && attr.name in _shortNames) attr.shortName = _shortNames[attr.name];
			}
			if (attr.type === oids.extensionRequest) {
				attr.valueConstructed = true;
				attr.valueTagClass = asn1.Type.SEQUENCE;
				if (!attr.value && attr.extensions) {
					attr.value = [];
					for (var ei = 0; ei < attr.extensions.length; ++ei) attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
				}
			}
			if (typeof attr.value === "undefined") {
				var error = /* @__PURE__ */ new Error("Attribute value not specified.");
				error.attribute = attr;
				throw error;
			}
		}
	}
	/**
	* Fills in missing fields in certificate extensions.
	*
	* @param e the extension.
	* @param [options] the options to use.
	*          [cert] the certificate the extensions are for.
	*
	* @return the extension.
	*/
	function _fillMissingExtensionFields(e, options) {
		options = options || {};
		if (typeof e.name === "undefined") {
			if (e.id && e.id in pki.oids) e.name = pki.oids[e.id];
		}
		if (typeof e.id === "undefined") if (e.name && e.name in pki.oids) e.id = pki.oids[e.name];
		else {
			var error = /* @__PURE__ */ new Error("Extension ID not specified.");
			error.extension = e;
			throw error;
		}
		if (typeof e.value !== "undefined") return e;
		if (e.name === "keyUsage") {
			var unused = 0;
			var b2 = 0;
			var b3 = 0;
			if (e.digitalSignature) {
				b2 |= 128;
				unused = 7;
			}
			if (e.nonRepudiation) {
				b2 |= 64;
				unused = 6;
			}
			if (e.keyEncipherment) {
				b2 |= 32;
				unused = 5;
			}
			if (e.dataEncipherment) {
				b2 |= 16;
				unused = 4;
			}
			if (e.keyAgreement) {
				b2 |= 8;
				unused = 3;
			}
			if (e.keyCertSign) {
				b2 |= 4;
				unused = 2;
			}
			if (e.cRLSign) {
				b2 |= 2;
				unused = 1;
			}
			if (e.encipherOnly) {
				b2 |= 1;
				unused = 0;
			}
			if (e.decipherOnly) {
				b3 |= 128;
				unused = 7;
			}
			var value = String.fromCharCode(unused);
			if (b3 !== 0) value += String.fromCharCode(b2) + String.fromCharCode(b3);
			else if (b2 !== 0) value += String.fromCharCode(b2);
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
		} else if (e.name === "basicConstraints") {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			if (e.cA) e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
			if ("pathLenConstraint" in e) e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
		} else if (e.name === "extKeyUsage") {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var seq = e.value.value;
			for (var key in e) {
				if (e[key] !== true) continue;
				if (key in oids) seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
				else if (key.indexOf(".") !== -1) seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
			}
		} else if (e.name === "nsCertType") {
			var unused = 0;
			var b2 = 0;
			if (e.client) {
				b2 |= 128;
				unused = 7;
			}
			if (e.server) {
				b2 |= 64;
				unused = 6;
			}
			if (e.email) {
				b2 |= 32;
				unused = 5;
			}
			if (e.objsign) {
				b2 |= 16;
				unused = 4;
			}
			if (e.reserved) {
				b2 |= 8;
				unused = 3;
			}
			if (e.sslCA) {
				b2 |= 4;
				unused = 2;
			}
			if (e.emailCA) {
				b2 |= 2;
				unused = 1;
			}
			if (e.objCA) {
				b2 |= 1;
				unused = 0;
			}
			var value = String.fromCharCode(unused);
			if (b2 !== 0) value += String.fromCharCode(b2);
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
		} else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var altName;
			for (var n = 0; n < e.altNames.length; ++n) {
				altName = e.altNames[n];
				var value = altName.value;
				if (altName.type === 7 && altName.ip) {
					value = forge.util.bytesFromIP(altName.ip);
					if (value === null) {
						var error = /* @__PURE__ */ new Error("Extension \"ip\" value is not a valid IPv4 or IPv6 address.");
						error.extension = e;
						throw error;
					}
				} else if (altName.type === 8) if (altName.oid) value = asn1.oidToDer(asn1.oidToDer(altName.oid));
				else value = asn1.oidToDer(value);
				e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
			}
		} else if (e.name === "nsComment" && options.cert) {
			if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) throw new Error("Invalid \"nsComment\" content.");
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
		} else if (e.name === "subjectKeyIdentifier" && options.cert) {
			var ski = options.cert.generateSubjectKeyIdentifier();
			e.subjectKeyIdentifier = ski.toHex();
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
		} else if (e.name === "authorityKeyIdentifier" && options.cert) {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var seq = e.value.value;
			if (e.keyIdentifier) {
				var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
				seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
			}
			if (e.authorityCertIssuer) {
				var authorityCertIssuer = [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [_dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)])];
				seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
			}
			if (e.serialNumber) {
				var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
				seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
			}
		} else if (e.name === "cRLDistributionPoints") {
			e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var seq = e.value.value;
			var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
			var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
			var altName;
			for (var n = 0; n < e.altNames.length; ++n) {
				altName = e.altNames[n];
				var value = altName.value;
				if (altName.type === 7 && altName.ip) {
					value = forge.util.bytesFromIP(altName.ip);
					if (value === null) {
						var error = /* @__PURE__ */ new Error("Extension \"ip\" value is not a valid IPv4 or IPv6 address.");
						error.extension = e;
						throw error;
					}
				} else if (altName.type === 8) if (altName.oid) value = asn1.oidToDer(asn1.oidToDer(altName.oid));
				else value = asn1.oidToDer(value);
				fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
			}
			subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
			seq.push(subSeq);
		}
		if (typeof e.value === "undefined") {
			var error = /* @__PURE__ */ new Error("Extension value not specified.");
			error.extension = e;
			throw error;
		}
		return e;
	}
	/**
	* Convert signature parameters object to ASN.1
	*
	* @param {String} oid Signature algorithm OID
	* @param params The signature parameters object
	* @return ASN.1 object representing signature parameters
	*/
	function _signatureParametersToAsn1(oid, params) {
		switch (oid) {
			case oids["RSASSA-PSS"]:
				var parts = [];
				if (params.hash.algorithmOid !== void 0) parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])]));
				if (params.mgf.algorithmOid !== void 0) parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])])]));
				if (params.saltLength !== void 0) parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())]));
				return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
			default: return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
		}
	}
	/**
	* Converts a certification request's attributes to an ASN.1 set of
	* CRIAttributes.
	*
	* @param csr certification request.
	*
	* @return the ASN.1 set of CRIAttributes.
	*/
	function _CRIAttributesToAsn1(csr) {
		var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
		if (csr.attributes.length === 0) return rval;
		var attrs = csr.attributes;
		for (var i = 0; i < attrs.length; ++i) {
			var attr = attrs[i];
			var value = attr.value;
			var valueTagClass = asn1.Type.UTF8;
			if ("valueTagClass" in attr) valueTagClass = attr.valueTagClass;
			if (valueTagClass === asn1.Type.UTF8) value = forge.util.encodeUtf8(value);
			var valueConstructed = false;
			if ("valueConstructed" in attr) valueConstructed = attr.valueConstructed;
			var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)])]);
			rval.value.push(seq);
		}
		return rval;
	}
	var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
	var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
	/**
	* Converts a Date object to ASN.1
	* Handles the different format before and after 1st January 2050
	*
	* @param date date object.
	*
	* @return the ASN.1 object representing the date.
	*/
	function _dateToAsn1(date) {
		if (date >= jan_1_1950 && date < jan_1_2050) return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
		else return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
	}
	/**
	* Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
	*
	* @param cert the certificate.
	*
	* @return the asn1 TBSCertificate.
	*/
	pki.getTBSCertificate = function(cert) {
		var notBefore = _dateToAsn1(cert.validity.notBefore);
		var notAfter = _dateToAsn1(cert.validity.notAfter);
		var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()), _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)]),
			_dnToAsn1(cert.issuer),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [notBefore, notAfter]),
			_dnToAsn1(cert.subject),
			pki.publicKeyToAsn1(cert.publicKey)
		]);
		if (cert.issuer.uniqueId) tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)]));
		if (cert.subject.uniqueId) tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)]));
		if (cert.extensions.length > 0) tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
		return tbs;
	};
	/**
	* Gets the ASN.1 CertificationRequestInfo part of a
	* PKCS#10 CertificationRequest.
	*
	* @param csr the certification request.
	*
	* @return the asn1 CertificationRequestInfo.
	*/
	pki.getCertificationRequestInfo = function(csr) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()),
			_dnToAsn1(csr.subject),
			pki.publicKeyToAsn1(csr.publicKey),
			_CRIAttributesToAsn1(csr)
		]);
	};
	/**
	* Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
	*
	* @param dn the DistinguishedName.
	*
	* @return the asn1 representation of a DistinguishedName.
	*/
	pki.distinguishedNameToAsn1 = function(dn) {
		return _dnToAsn1(dn);
	};
	/**
	* Converts an X.509v3 RSA certificate to an ASN.1 object.
	*
	* @param cert the certificate.
	*
	* @return the asn1 representation of an X.509v3 RSA certificate.
	*/
	pki.certificateToAsn1 = function(cert) {
		var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			tbsCertificate,
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()), _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
		]);
	};
	/**
	* Converts X.509v3 certificate extensions to ASN.1.
	*
	* @param exts the extensions to convert.
	*
	* @return the extensions in ASN.1 format.
	*/
	pki.certificateExtensionsToAsn1 = function(exts) {
		var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
		var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		rval.value.push(seq);
		for (var i = 0; i < exts.length; ++i) seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
		return rval;
	};
	/**
	* Converts a single certificate extension to ASN.1.
	*
	* @param ext the extension to convert.
	*
	* @return the extension in ASN.1 format.
	*/
	pki.certificateExtensionToAsn1 = function(ext) {
		var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
		extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
		if (ext.critical) extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
		var value = ext.value;
		if (typeof ext.value !== "string") value = asn1.toDer(value).getBytes();
		extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
		return extseq;
	};
	/**
	* Converts a PKCS#10 certification request to an ASN.1 object.
	*
	* @param csr the certification request.
	*
	* @return the asn1 representation of a certification request.
	*/
	pki.certificationRequestToAsn1 = function(csr) {
		var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			cri,
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()), _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
		]);
	};
	/**
	* Creates a CA store.
	*
	* @param certs an optional array of certificate objects or PEM-formatted
	*          certificate strings to add to the CA store.
	*
	* @return the CA store.
	*/
	pki.createCaStore = function(certs) {
		var caStore = { certs: {} };
		/**
		* Gets the certificate that issued the passed certificate or its
		* 'parent'.
		*
		* @param cert the certificate to get the parent for.
		*
		* @return the parent certificate or null if none was found.
		*/
		caStore.getIssuer = function(cert) {
			return getBySubject(cert.issuer);
		};
		/**
		* Adds a trusted certificate to the store.
		*
		* @param cert the certificate to add as a trusted certificate (either a
		*          pki.certificate object or a PEM-formatted certificate).
		*/
		caStore.addCertificate = function(cert) {
			if (typeof cert === "string") cert = forge.pki.certificateFromPem(cert);
			ensureSubjectHasHash(cert.subject);
			if (!caStore.hasCertificate(cert)) if (cert.subject.hash in caStore.certs) {
				var tmp = caStore.certs[cert.subject.hash];
				if (!forge.util.isArray(tmp)) tmp = [tmp];
				tmp.push(cert);
				caStore.certs[cert.subject.hash] = tmp;
			} else caStore.certs[cert.subject.hash] = cert;
		};
		/**
		* Checks to see if the given certificate is in the store.
		*
		* @param cert the certificate to check (either a pki.certificate or a
		*          PEM-formatted certificate).
		*
		* @return true if the certificate is in the store, false if not.
		*/
		caStore.hasCertificate = function(cert) {
			if (typeof cert === "string") cert = forge.pki.certificateFromPem(cert);
			var match = getBySubject(cert.subject);
			if (!match) return false;
			if (!forge.util.isArray(match)) match = [match];
			var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
			for (var i = 0; i < match.length; ++i) if (der1 === asn1.toDer(pki.certificateToAsn1(match[i])).getBytes()) return true;
			return false;
		};
		/**
		* Lists all of the certificates kept in the store.
		*
		* @return an array of all of the pki.certificate objects in the store.
		*/
		caStore.listAllCertificates = function() {
			var certList = [];
			for (var hash in caStore.certs) if (caStore.certs.hasOwnProperty(hash)) {
				var value = caStore.certs[hash];
				if (!forge.util.isArray(value)) certList.push(value);
				else for (var i = 0; i < value.length; ++i) certList.push(value[i]);
			}
			return certList;
		};
		/**
		* Removes a certificate from the store.
		*
		* @param cert the certificate to remove (either a pki.certificate or a
		*          PEM-formatted certificate).
		*
		* @return the certificate that was removed or null if the certificate
		*           wasn't in store.
		*/
		caStore.removeCertificate = function(cert) {
			var result;
			if (typeof cert === "string") cert = forge.pki.certificateFromPem(cert);
			ensureSubjectHasHash(cert.subject);
			if (!caStore.hasCertificate(cert)) return null;
			var match = getBySubject(cert.subject);
			if (!forge.util.isArray(match)) {
				result = caStore.certs[cert.subject.hash];
				delete caStore.certs[cert.subject.hash];
				return result;
			}
			var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
			for (var i = 0; i < match.length; ++i) if (der1 === asn1.toDer(pki.certificateToAsn1(match[i])).getBytes()) {
				result = match[i];
				match.splice(i, 1);
			}
			if (match.length === 0) delete caStore.certs[cert.subject.hash];
			return result;
		};
		function getBySubject(subject) {
			ensureSubjectHasHash(subject);
			return caStore.certs[subject.hash] || null;
		}
		function ensureSubjectHasHash(subject) {
			if (!subject.hash) {
				var md = forge.md.sha1.create();
				subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
				subject.hash = md.digest().toHex();
			}
		}
		if (certs) for (var i = 0; i < certs.length; ++i) {
			var cert = certs[i];
			caStore.addCertificate(cert);
		}
		return caStore;
	};
	/**
	* Certificate verification errors, based on TLS.
	*/
	pki.certificateError = {
		bad_certificate: "forge.pki.BadCertificate",
		unsupported_certificate: "forge.pki.UnsupportedCertificate",
		certificate_revoked: "forge.pki.CertificateRevoked",
		certificate_expired: "forge.pki.CertificateExpired",
		certificate_unknown: "forge.pki.CertificateUnknown",
		unknown_ca: "forge.pki.UnknownCertificateAuthority"
	};
	/**
	* Verifies a certificate chain against the given Certificate Authority store
	* with an optional custom verify callback.
	*
	* @param caStore a certificate store to verify against.
	* @param chain the certificate chain to verify, with the root or highest
	*          authority at the end (an array of certificates).
	* @param options a callback to be called for every certificate in the chain or
	*                  an object with:
	*                  verify a callback to be called for every certificate in the
	*                    chain
	*                  validityCheckDate the date against which the certificate
	*                    validity period should be checked. Pass null to not check
	*                    the validity period. By default, the current date is used.
	*
	* The verify callback has the following signature:
	*
	* verified - Set to true if certificate was verified, otherwise the
	*   pki.certificateError for why the certificate failed.
	* depth - The current index in the chain, where 0 is the end point's cert.
	* certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
	*   end point.
	*
	* The function returns true on success and on failure either the appropriate
	* pki.certificateError or an object with 'error' set to the appropriate
	* pki.certificateError and 'message' set to a custom error message.
	*
	* @return true if successful, error thrown if not.
	*/
	pki.verifyCertificateChain = function(caStore, chain, options) {
		if (typeof options === "function") options = { verify: options };
		options = options || {};
		chain = chain.slice(0);
		var certs = chain.slice(0);
		var validityCheckDate = options.validityCheckDate;
		if (typeof validityCheckDate === "undefined") validityCheckDate = /* @__PURE__ */ new Date();
		var first = true;
		var error = null;
		var depth = 0;
		do {
			var cert = chain.shift();
			var parent = null;
			var selfSigned = false;
			if (validityCheckDate) {
				if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) error = {
					message: "Certificate is not valid yet or has expired.",
					error: pki.certificateError.certificate_expired,
					notBefore: cert.validity.notBefore,
					notAfter: cert.validity.notAfter,
					now: validityCheckDate
				};
			}
			if (error === null) {
				parent = chain[0] || caStore.getIssuer(cert);
				if (parent === null) {
					if (cert.isIssuer(cert)) {
						selfSigned = true;
						parent = cert;
					}
				}
				if (parent) {
					var parents = parent;
					if (!forge.util.isArray(parents)) parents = [parents];
					var verified = false;
					while (!verified && parents.length > 0) {
						parent = parents.shift();
						try {
							verified = parent.verify(cert);
						} catch (ex) {}
					}
					if (!verified) error = {
						message: "Certificate signature is invalid.",
						error: pki.certificateError.bad_certificate
					};
				}
				if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) error = {
					message: "Certificate is not trusted.",
					error: pki.certificateError.unknown_ca
				};
			}
			if (error === null && parent && !cert.isIssuer(parent)) error = {
				message: "Certificate issuer is invalid.",
				error: pki.certificateError.bad_certificate
			};
			if (error === null) {
				var se = {
					keyUsage: true,
					basicConstraints: true
				};
				for (var i = 0; error === null && i < cert.extensions.length; ++i) {
					var ext = cert.extensions[i];
					if (ext.critical && !(ext.name in se)) error = {
						message: "Certificate has an unsupported critical extension.",
						error: pki.certificateError.unsupported_certificate
					};
				}
			}
			if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
				var bcExt = cert.getExtension("basicConstraints");
				var keyUsageExt = cert.getExtension("keyUsage");
				if (keyUsageExt !== null) {
					if (!keyUsageExt.keyCertSign || bcExt === null) error = {
						message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
						error: pki.certificateError.bad_certificate
					};
				}
				if (error === null && bcExt !== null && !bcExt.cA) error = {
					message: "Certificate basicConstraints indicates the certificate is not a CA.",
					error: pki.certificateError.bad_certificate
				};
				if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
					if (depth - 1 > bcExt.pathLenConstraint) error = {
						message: "Certificate basicConstraints pathLenConstraint violated.",
						error: pki.certificateError.bad_certificate
					};
				}
			}
			var vfd = error === null ? true : error.error;
			var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
			if (ret === true) error = null;
			else {
				if (vfd === true) error = {
					message: "The application rejected the certificate.",
					error: pki.certificateError.bad_certificate
				};
				if (ret || ret === 0) {
					if (typeof ret === "object" && !forge.util.isArray(ret)) {
						if (ret.message) error.message = ret.message;
						if (ret.error) error.error = ret.error;
					} else if (typeof ret === "string") error.error = ret;
				}
				throw error;
			}
			first = false;
			++depth;
		} while (chain.length > 0);
		return true;
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of PKCS#12.
	*
	* @author Dave Longley
	* @author Stefan Siegl <stesie@brokenpipe.de>
	*
	* Copyright (c) 2010-2014 Digital Bazaar, Inc.
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	*
	* The ASN.1 representation of PKCS#12 is as follows
	* (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)
	*
	* PFX ::= SEQUENCE {
	*   version  INTEGER {v3(3)}(v3,...),
	*   authSafe ContentInfo,
	*   macData  MacData OPTIONAL
	* }
	*
	* MacData ::= SEQUENCE {
	*   mac DigestInfo,
	*   macSalt OCTET STRING,
	*   iterations INTEGER DEFAULT 1
	* }
	* Note: The iterations default is for historical reasons and its use is
	* deprecated. A higher value, like 1024, is recommended.
	*
	* DigestInfo is defined in PKCS#7 as follows:
	*
	* DigestInfo ::= SEQUENCE {
	*   digestAlgorithm DigestAlgorithmIdentifier,
	*   digest Digest
	* }
	*
	* DigestAlgorithmIdentifier ::= AlgorithmIdentifier
	*
	* The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
	* for the algorithm, if any. In the case of SHA1 there is none.
	*
	* AlgorithmIdentifer ::= SEQUENCE {
	*    algorithm OBJECT IDENTIFIER,
	*    parameters ANY DEFINED BY algorithm OPTIONAL
	* }
	*
	* Digest ::= OCTET STRING
	*
	*
	* ContentInfo ::= SEQUENCE {
	*   contentType ContentType,
	*   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL
	* }
	*
	* ContentType ::= OBJECT IDENTIFIER
	*
	* AuthenticatedSafe ::= SEQUENCE OF ContentInfo
	* -- Data if unencrypted
	* -- EncryptedData if password-encrypted
	* -- EnvelopedData if public key-encrypted
	*
	*
	* SafeContents ::= SEQUENCE OF SafeBag
	*
	* SafeBag ::= SEQUENCE {
	*   bagId     BAG-TYPE.&id ({PKCS12BagSet})
	*   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),
	*   bagAttributes SET OF PKCS12Attribute OPTIONAL
	* }
	*
	* PKCS12Attribute ::= SEQUENCE {
	*   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),
	*   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})
	* } -- This type is compatible with the X.500 type 'Attribute'
	*
	* PKCS12AttrSet ATTRIBUTE ::= {
	*   friendlyName | -- from PKCS #9
	*   localKeyId, -- from PKCS #9
	*   ... -- Other attributes are allowed
	* }
	*
	* CertBag ::= SEQUENCE {
	*   certId    BAG-TYPE.&id   ({CertTypes}),
	*   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})
	* }
	*
	* x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}
	*   -- DER-encoded X.509 certificate stored in OCTET STRING
	*
	* sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}
	* -- Base64-encoded SDSI certificate stored in IA5String
	*
	* CertTypes BAG-TYPE ::= {
	*   x509Certificate |
	*   sdsiCertificate,
	*   ... -- For future extensions
	* }
	*/
	var forge = require_forge();
	require_asn1();
	require_hmac();
	require_oids();
	require_pkcs7asn1();
	require_pbe();
	require_random();
	require_rsa();
	require_sha1();
	require_util();
	require_x509();
	var asn1 = forge.asn1;
	var pki = forge.pki;
	var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};
	var contentInfoValidator = {
		name: "ContentInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "ContentInfo.contentType",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OID,
			constructed: false,
			capture: "contentType"
		}, {
			name: "ContentInfo.content",
			tagClass: asn1.Class.CONTEXT_SPECIFIC,
			constructed: true,
			captureAsn1: "content"
		}]
	};
	var pfxValidator = {
		name: "PFX",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "PFX.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "version"
			},
			contentInfoValidator,
			{
				name: "PFX.macData",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				optional: true,
				captureAsn1: "mac",
				value: [
					{
						name: "PFX.macData.mac",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.SEQUENCE,
						constructed: true,
						value: [{
							name: "PFX.macData.mac.digestAlgorithm",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.SEQUENCE,
							constructed: true,
							value: [{
								name: "PFX.macData.mac.digestAlgorithm.algorithm",
								tagClass: asn1.Class.UNIVERSAL,
								type: asn1.Type.OID,
								constructed: false,
								capture: "macAlgorithm"
							}, {
								name: "PFX.macData.mac.digestAlgorithm.parameters",
								optional: true,
								tagClass: asn1.Class.UNIVERSAL,
								captureAsn1: "macAlgorithmParameters"
							}]
						}, {
							name: "PFX.macData.mac.digest",
							tagClass: asn1.Class.UNIVERSAL,
							type: asn1.Type.OCTETSTRING,
							constructed: false,
							capture: "macDigest"
						}]
					},
					{
						name: "PFX.macData.macSalt",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.OCTETSTRING,
						constructed: false,
						capture: "macSalt"
					},
					{
						name: "PFX.macData.iterations",
						tagClass: asn1.Class.UNIVERSAL,
						type: asn1.Type.INTEGER,
						constructed: false,
						optional: true,
						capture: "macIterations"
					}
				]
			}
		]
	};
	var safeBagValidator = {
		name: "SafeBag",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "SafeBag.bagId",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "bagId"
			},
			{
				name: "SafeBag.bagValue",
				tagClass: asn1.Class.CONTEXT_SPECIFIC,
				constructed: true,
				captureAsn1: "bagValue"
			},
			{
				name: "SafeBag.bagAttributes",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SET,
				constructed: true,
				optional: true,
				capture: "bagAttributes"
			}
		]
	};
	var attributeValidator = {
		name: "Attribute",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "Attribute.attrId",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OID,
			constructed: false,
			capture: "oid"
		}, {
			name: "Attribute.attrValues",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SET,
			constructed: true,
			capture: "values"
		}]
	};
	var certBagValidator = {
		name: "CertBag",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [{
			name: "CertBag.certId",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.OID,
			constructed: false,
			capture: "certId"
		}, {
			name: "CertBag.certValue",
			tagClass: asn1.Class.CONTEXT_SPECIFIC,
			constructed: true,
			value: [{
				name: "CertBag.certValue[0]",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Class.OCTETSTRING,
				constructed: false,
				capture: "cert"
			}]
		}]
	};
	/**
	* Search SafeContents structure for bags with matching attributes.
	*
	* The search can optionally be narrowed by a certain bag type.
	*
	* @param safeContents the SafeContents structure to search in.
	* @param attrName the name of the attribute to compare against.
	* @param attrValue the attribute value to search for.
	* @param [bagType] bag type to narrow search by.
	*
	* @return an array of matching bags.
	*/
	function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
		var result = [];
		for (var i = 0; i < safeContents.length; i++) for (var j = 0; j < safeContents[i].safeBags.length; j++) {
			var bag = safeContents[i].safeBags[j];
			if (bagType !== void 0 && bag.type !== bagType) continue;
			if (attrName === null) {
				result.push(bag);
				continue;
			}
			if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) result.push(bag);
		}
		return result;
	}
	/**
	* Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.
	*
	* @param obj The PKCS#12 PFX in ASN.1 notation.
	* @param strict true to use strict DER decoding, false not to (default: true).
	* @param {String} password Password to decrypt with (optional).
	*
	* @return PKCS#12 PFX object.
	*/
	p12.pkcs12FromAsn1 = function(obj, strict, password) {
		if (typeof strict === "string") {
			password = strict;
			strict = true;
		} else if (strict === void 0) strict = true;
		var capture = {};
		if (!asn1.validate(obj, pfxValidator, capture, [])) {
			var error = /* @__PURE__ */ new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
			error.errors = error;
			throw error;
		}
		var pfx = {
			version: capture.version.charCodeAt(0),
			safeContents: [],
			getBags: function(filter) {
				var rval = {};
				var localKeyId;
				if ("localKeyId" in filter) localKeyId = filter.localKeyId;
				else if ("localKeyIdHex" in filter) localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);
				if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);
				if (localKeyId !== void 0) rval.localKeyId = _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, filter.bagType);
				if ("friendlyName" in filter) rval.friendlyName = _getBagsByAttribute(pfx.safeContents, "friendlyName", filter.friendlyName, filter.bagType);
				return rval;
			},
			getBagsByFriendlyName: function(friendlyName, bagType) {
				return _getBagsByAttribute(pfx.safeContents, "friendlyName", friendlyName, bagType);
			},
			getBagsByLocalKeyId: function(localKeyId, bagType) {
				return _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, bagType);
			}
		};
		if (capture.version.charCodeAt(0) !== 3) {
			var error = /* @__PURE__ */ new Error("PKCS#12 PFX of version other than 3 not supported.");
			error.version = capture.version.charCodeAt(0);
			throw error;
		}
		if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
			var error = /* @__PURE__ */ new Error("Only PKCS#12 PFX in password integrity mode supported.");
			error.oid = asn1.derToOid(capture.contentType);
			throw error;
		}
		var data = capture.content.value[0];
		if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
		data = _decodePkcs7Data(data);
		if (capture.mac) {
			var md = null;
			var macKeyBytes = 0;
			var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
			switch (macAlgorithm) {
				case pki.oids.sha1:
					md = forge.md.sha1.create();
					macKeyBytes = 20;
					break;
				case pki.oids.sha256:
					md = forge.md.sha256.create();
					macKeyBytes = 32;
					break;
				case pki.oids.sha384:
					md = forge.md.sha384.create();
					macKeyBytes = 48;
					break;
				case pki.oids.sha512:
					md = forge.md.sha512.create();
					macKeyBytes = 64;
					break;
				case pki.oids.md5:
					md = forge.md.md5.create();
					macKeyBytes = 16;
					break;
			}
			if (md === null) throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
			var macSalt = new forge.util.ByteBuffer(capture.macSalt);
			var macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;
			var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);
			var mac = forge.hmac.create();
			mac.start(md, macKey);
			mac.update(data.value);
			if (mac.getMac().getBytes() !== capture.macDigest) throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
		} else if (Array.isArray(obj.value) && obj.value.length > 2) throw new Error("Invalid PKCS#12. macData field present but MAC was not validated.");
		_decodeAuthenticatedSafe(pfx, data.value, strict, password);
		return pfx;
	};
	/**
	* Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines "Data" as an OCTET STRING,
	* but it is sometimes an OCTET STRING that is composed/constructed of chunks,
	* each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This
	* function transforms this corner-case into the usual simple,
	* non-composed/constructed OCTET STRING.
	*
	* This function may be moved to ASN.1 at some point to better deal with
	* more BER-encoding issues, should they arise.
	*
	* @param data the ASN.1 Data object to transform.
	*/
	function _decodePkcs7Data(data) {
		if (data.composed || data.constructed) {
			var value = forge.util.createBuffer();
			for (var i = 0; i < data.value.length; ++i) value.putBytes(data.value[i].value);
			data.composed = data.constructed = false;
			data.value = value.getBytes();
		}
		return data;
	}
	/**
	* Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.
	*
	* The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.
	*
	* @param pfx The PKCS#12 PFX object to fill.
	* @param {String} authSafe BER-encoded AuthenticatedSafe.
	* @param strict true to use strict DER decoding, false not to.
	* @param {String} password Password to decrypt with (optional).
	*/
	function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
		authSafe = asn1.fromDer(authSafe, strict);
		if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
		for (var i = 0; i < authSafe.value.length; i++) {
			var contentInfo = authSafe.value[i];
			var capture = {};
			var errors = [];
			if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
				var error = /* @__PURE__ */ new Error("Cannot read ContentInfo.");
				error.errors = errors;
				throw error;
			}
			var obj = { encrypted: false };
			var safeContents = null;
			var data = capture.content.value[0];
			switch (asn1.derToOid(capture.contentType)) {
				case pki.oids.data:
					if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
					safeContents = _decodePkcs7Data(data).value;
					break;
				case pki.oids.encryptedData:
					safeContents = _decryptSafeContents(data, password);
					obj.encrypted = true;
					break;
				default:
					var error = /* @__PURE__ */ new Error("Unsupported PKCS#12 contentType.");
					error.contentType = asn1.derToOid(capture.contentType);
					throw error;
			}
			obj.safeBags = _decodeSafeContents(safeContents, strict, password);
			pfx.safeContents.push(obj);
		}
	}
	/**
	* Decrypt PKCS#7 EncryptedData structure.
	*
	* @param data ASN.1 encoded EncryptedContentInfo object.
	* @param password The user-provided password.
	*
	* @return The decrypted SafeContents (ASN.1 object).
	*/
	function _decryptSafeContents(data, password) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read EncryptedContentInfo.");
			error.errors = errors;
			throw error;
		}
		var oid = asn1.derToOid(capture.contentType);
		if (oid !== pki.oids.data) {
			var error = /* @__PURE__ */ new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
			error.oid = oid;
			throw error;
		}
		oid = asn1.derToOid(capture.encAlgorithm);
		var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
		var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
		var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
		cipher.update(encrypted);
		if (!cipher.finish()) throw new Error("Failed to decrypt PKCS#12 SafeContents.");
		return cipher.output.getBytes();
	}
	/**
	* Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.
	*
	* The safeContents is a BER-encoded SEQUENCE OF SafeBag.
	*
	* @param {String} safeContents BER-encoded safeContents.
	* @param strict true to use strict DER decoding, false not to.
	* @param {String} password Password to decrypt with (optional).
	*
	* @return {Array} Array of Bag objects.
	*/
	function _decodeSafeContents(safeContents, strict, password) {
		if (!strict && safeContents.length === 0) return [];
		safeContents = asn1.fromDer(safeContents, strict);
		if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
		var res = [];
		for (var i = 0; i < safeContents.value.length; i++) {
			var safeBag = safeContents.value[i];
			var capture = {};
			var errors = [];
			if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
				var error = /* @__PURE__ */ new Error("Cannot read SafeBag.");
				error.errors = errors;
				throw error;
			}
			var bag = {
				type: asn1.derToOid(capture.bagId),
				attributes: _decodeBagAttributes(capture.bagAttributes)
			};
			res.push(bag);
			var validator, decoder;
			var bagAsn1 = capture.bagValue.value[0];
			switch (bag.type) {
				case pki.oids.pkcs8ShroudedKeyBag:
					bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
					if (bagAsn1 === null) throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
				case pki.oids.keyBag:
					try {
						bag.key = pki.privateKeyFromAsn1(bagAsn1);
					} catch (e) {
						bag.key = null;
						bag.asn1 = bagAsn1;
					}
					continue;
				case pki.oids.certBag:
					validator = certBagValidator;
					decoder = function() {
						if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
							var error = /* @__PURE__ */ new Error("Unsupported certificate type, only X.509 supported.");
							error.oid = asn1.derToOid(capture.certId);
							throw error;
						}
						var certAsn1 = asn1.fromDer(capture.cert, strict);
						try {
							bag.cert = pki.certificateFromAsn1(certAsn1, true);
						} catch (e) {
							bag.cert = null;
							bag.asn1 = certAsn1;
						}
					};
					break;
				default:
					var error = /* @__PURE__ */ new Error("Unsupported PKCS#12 SafeBag type.");
					error.oid = bag.type;
					throw error;
			}
			if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
				var error = /* @__PURE__ */ new Error("Cannot read PKCS#12 " + validator.name);
				error.errors = errors;
				throw error;
			}
			decoder();
		}
		return res;
	}
	/**
	* Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.
	*
	* @param attributes SET OF PKCS12Attribute (ASN.1 object).
	*
	* @return the decoded attributes.
	*/
	function _decodeBagAttributes(attributes) {
		var decodedAttrs = {};
		if (attributes !== void 0) for (var i = 0; i < attributes.length; ++i) {
			var capture = {};
			var errors = [];
			if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
				var error = /* @__PURE__ */ new Error("Cannot read PKCS#12 BagAttribute.");
				error.errors = errors;
				throw error;
			}
			var oid = asn1.derToOid(capture.oid);
			if (pki.oids[oid] === void 0) continue;
			decodedAttrs[pki.oids[oid]] = [];
			for (var j = 0; j < capture.values.length; ++j) decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
		}
		return decodedAttrs;
	}
	/**
	* Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a
	* password is provided then the private key will be encrypted.
	*
	* An entire certificate chain may also be included. To do this, pass
	* an array for the "cert" parameter where the first certificate is
	* the one that is paired with the private key and each subsequent one
	* verifies the previous one. The certificates may be in PEM format or
	* have been already parsed by Forge.
	*
	* @todo implement password-based-encryption for the whole package
	*
	* @param key the private key.
	* @param cert the certificate (may be an array of certificates in order
	*          to specify a certificate chain).
	* @param password the password to use, null for none.
	* @param options:
	*          algorithm the encryption algorithm to use
	*            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
	*          count the iteration count to use.
	*          saltSize the salt size to use.
	*          useMac true to include a MAC, false not to, defaults to true.
	*          localKeyId the local key ID to use, in hex.
	*          friendlyName the friendly name to use.
	*          generateLocalKeyId true to generate a random local key ID,
	*            false not to, defaults to true.
	*
	* @return the PKCS#12 PFX ASN.1 object.
	*/
	p12.toPkcs12Asn1 = function(key, cert, password, options) {
		options = options || {};
		options.saltSize = options.saltSize || 8;
		options.count = options.count || 2048;
		options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
		if (!("useMac" in options)) options.useMac = true;
		if (!("localKeyId" in options)) options.localKeyId = null;
		if (!("generateLocalKeyId" in options)) options.generateLocalKeyId = true;
		var localKeyId = options.localKeyId;
		var bagAttrs;
		if (localKeyId !== null) localKeyId = forge.util.hexToBytes(localKeyId);
		else if (options.generateLocalKeyId) if (cert) {
			var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
			if (typeof pairedCert === "string") pairedCert = pki.certificateFromPem(pairedCert);
			var sha1 = forge.md.sha1.create();
			sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
			localKeyId = sha1.digest().getBytes();
		} else localKeyId = forge.random.getBytes(20);
		var attrs = [];
		if (localKeyId !== null) attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])]));
		if ("friendlyName" in options) attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])]));
		if (attrs.length > 0) bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
		var contents = [];
		var chain = [];
		if (cert !== null) if (forge.util.isArray(cert)) chain = cert;
		else chain = [cert];
		var certSafeBags = [];
		for (var i = 0; i < chain.length; ++i) {
			cert = chain[i];
			if (typeof cert === "string") cert = pki.certificateFromPem(cert);
			var certBagAttrs = i === 0 ? bagAttrs : void 0;
			var certAsn1 = pki.certificateToAsn1(cert);
			var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()),
				asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]),
				certBagAttrs
			]);
			certSafeBags.push(certSafeBag);
		}
		if (certSafeBags.length > 0) {
			var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);
			var certCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]);
			contents.push(certCI);
		}
		var keyBag = null;
		if (key !== null) {
			var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
			if (password === null) keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()),
				asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pkAsn1]),
				bagAttrs
			]);
			else keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),
				asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pki.encryptPrivateKeyInfo(pkAsn1, password, options)]),
				bagAttrs
			]);
			var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
			var keyCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]);
			contents.push(keyCI);
		}
		var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);
		var macData;
		if (options.useMac) {
			var sha1 = forge.md.sha1.create();
			var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));
			var count = options.count;
			var key = p12.generateKey(password, macSalt, 3, count, 20);
			var mac = forge.hmac.create();
			mac.start(sha1, key);
			mac.update(asn1.toDer(safe).getBytes());
			var macValue = mac.getMac();
			macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]),
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),
				asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())
			]);
		}
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]),
			macData
		]);
	};
	/**
	* Derives a PKCS#12 key.
	*
	* @param password the password to derive the key material from, null or
	*          undefined for none.
	* @param salt the salt, as a ByteBuffer, to use.
	* @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
	* @param iter the iteration count.
	* @param n the number of bytes to derive from the password.
	* @param md the message digest to use, defaults to SHA-1.
	*
	* @return a ByteBuffer with the bytes derived from the password.
	*/
	p12.generateKey = forge.pbe.generatePkcs12Key;
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/pki.js
var require_pki = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of a basic Public Key Infrastructure, including
	* support for RSA public and private keys.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2010-2013 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_asn1();
	require_oids();
	require_pbe();
	require_pem();
	require_pbkdf2();
	require_pkcs12();
	require_pss();
	require_rsa();
	require_util();
	require_x509();
	var asn1 = forge.asn1;
	var pki = module.exports = forge.pki = forge.pki || {};
	/**
	* NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.
	*
	* Converts PEM-formatted data to DER.
	*
	* @param pem the PEM-formatted data.
	*
	* @return the DER-formatted data.
	*/
	pki.pemToDer = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert PEM to DER; PEM is encrypted.");
		return forge.util.createBuffer(msg.body);
	};
	/**
	* Converts an RSA private key from PEM format.
	*
	* @param pem the PEM-formatted private key.
	*
	* @return the private key.
	*/
	pki.privateKeyFromPem = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
			var error = /* @__PURE__ */ new Error("Could not convert private key from PEM; PEM header type is not \"PRIVATE KEY\" or \"RSA PRIVATE KEY\".");
			error.headerType = msg.type;
			throw error;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert private key from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body);
		return pki.privateKeyFromAsn1(obj);
	};
	/**
	* Converts an RSA private key to PEM format.
	*
	* @param key the private key.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted private key.
	*/
	pki.privateKeyToPem = function(key, maxline) {
		var msg = {
			type: "RSA PRIVATE KEY",
			body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
	/**
	* Converts a PrivateKeyInfo to PEM format.
	*
	* @param pki the PrivateKeyInfo.
	* @param maxline the maximum characters per line, defaults to 64.
	*
	* @return the PEM-formatted private key.
	*/
	pki.privateKeyInfoToPem = function(pki, maxline) {
		var msg = {
			type: "PRIVATE KEY",
			body: asn1.toDer(pki).getBytes()
		};
		return forge.pem.encode(msg, { maxline });
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/tls.js
var require_tls = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* A Javascript implementation of Transport Layer Security (TLS).
	*
	* @author Dave Longley
	*
	* Copyright (c) 2009-2014 Digital Bazaar, Inc.
	*
	* The TLS Handshake Protocol involves the following steps:
	*
	* - Exchange hello messages to agree on algorithms, exchange random values,
	* and check for session resumption.
	*
	* - Exchange the necessary cryptographic parameters to allow the client and
	* server to agree on a premaster secret.
	*
	* - Exchange certificates and cryptographic information to allow the client
	* and server to authenticate themselves.
	*
	* - Generate a master secret from the premaster secret and exchanged random
	* values.
	*
	* - Provide security parameters to the record layer.
	*
	* - Allow the client and server to verify that their peer has calculated the
	* same security parameters and that the handshake occurred without tampering
	* by an attacker.
	*
	* Up to 4 different messages may be sent during a key exchange. The server
	* certificate, the server key exchange, the client certificate, and the
	* client key exchange.
	*
	* A typical handshake (from the client's perspective).
	*
	* 1. Client sends ClientHello.
	* 2. Client receives ServerHello.
	* 3. Client receives optional Certificate.
	* 4. Client receives optional ServerKeyExchange.
	* 5. Client receives ServerHelloDone.
	* 6. Client sends optional Certificate.
	* 7. Client sends ClientKeyExchange.
	* 8. Client sends optional CertificateVerify.
	* 9. Client sends ChangeCipherSpec.
	* 10. Client sends Finished.
	* 11. Client receives ChangeCipherSpec.
	* 12. Client receives Finished.
	* 13. Client sends/receives application data.
	*
	* To reuse an existing session:
	*
	* 1. Client sends ClientHello with session ID for reuse.
	* 2. Client receives ServerHello with same session ID if reusing.
	* 3. Client receives ChangeCipherSpec message if reusing.
	* 4. Client receives Finished.
	* 5. Client sends ChangeCipherSpec.
	* 6. Client sends Finished.
	*
	* Note: Client ignores HelloRequest if in the middle of a handshake.
	*
	* Record Layer:
	*
	* The record layer fragments information blocks into TLSPlaintext records
	* carrying data in chunks of 2^14 bytes or less. Client message boundaries are
	* not preserved in the record layer (i.e., multiple client messages of the
	* same ContentType MAY be coalesced into a single TLSPlaintext record, or a
	* single message MAY be fragmented across several records).
	*
	* struct {
	*   uint8 major;
	*   uint8 minor;
	* } ProtocolVersion;
	*
	* struct {
	*   ContentType type;
	*   ProtocolVersion version;
	*   uint16 length;
	*   opaque fragment[TLSPlaintext.length];
	* } TLSPlaintext;
	*
	* type:
	*   The higher-level protocol used to process the enclosed fragment.
	*
	* version:
	*   The version of the protocol being employed. TLS Version 1.2 uses version
	*   {3, 3}. TLS Version 1.0 uses version {3, 1}. Note that a client that
	*   supports multiple versions of TLS may not know what version will be
	*   employed before it receives the ServerHello.
	*
	* length:
	*   The length (in bytes) of the following TLSPlaintext.fragment. The length
	*   MUST NOT exceed 2^14 = 16384 bytes.
	*
	* fragment:
	*   The application data. This data is transparent and treated as an
	*   independent block to be dealt with by the higher-level protocol specified
	*   by the type field.
	*
	* Implementations MUST NOT send zero-length fragments of Handshake, Alert, or
	* ChangeCipherSpec content types. Zero-length fragments of Application data
	* MAY be sent as they are potentially useful as a traffic analysis
	* countermeasure.
	*
	* Note: Data of different TLS record layer content types MAY be interleaved.
	* Application data is generally of lower precedence for transmission than
	* other content types. However, records MUST be delivered to the network in
	* the same order as they are protected by the record layer. Recipients MUST
	* receive and process interleaved application layer traffic during handshakes
	* subsequent to the first one on a connection.
	*
	* struct {
	*   ContentType type;       // same as TLSPlaintext.type
	*   ProtocolVersion version;// same as TLSPlaintext.version
	*   uint16 length;
	*   opaque fragment[TLSCompressed.length];
	* } TLSCompressed;
	*
	* length:
	*   The length (in bytes) of the following TLSCompressed.fragment.
	*   The length MUST NOT exceed 2^14 + 1024.
	*
	* fragment:
	*   The compressed form of TLSPlaintext.fragment.
	*
	* Note: A CompressionMethod.null operation is an identity operation; no fields
	* are altered. In this implementation, since no compression is supported,
	* uncompressed records are always the same as compressed records.
	*
	* Encryption Information:
	*
	* The encryption and MAC functions translate a TLSCompressed structure into a
	* TLSCiphertext. The decryption functions reverse the process. The MAC of the
	* record also includes a sequence number so that missing, extra, or repeated
	* messages are detectable.
	*
	* struct {
	*   ContentType type;
	*   ProtocolVersion version;
	*   uint16 length;
	*   select (SecurityParameters.cipher_type) {
	*     case stream: GenericStreamCipher;
	*     case block:  GenericBlockCipher;
	*     case aead:   GenericAEADCipher;
	*   } fragment;
	* } TLSCiphertext;
	*
	* type:
	*   The type field is identical to TLSCompressed.type.
	*
	* version:
	*   The version field is identical to TLSCompressed.version.
	*
	* length:
	*   The length (in bytes) of the following TLSCiphertext.fragment.
	*   The length MUST NOT exceed 2^14 + 2048.
	*
	* fragment:
	*   The encrypted form of TLSCompressed.fragment, with the MAC.
	*
	* Note: Only CBC Block Ciphers are supported by this implementation.
	*
	* The TLSCompressed.fragment structures are converted to/from block
	* TLSCiphertext.fragment structures.
	*
	* struct {
	*   opaque IV[SecurityParameters.record_iv_length];
	*   block-ciphered struct {
	*     opaque content[TLSCompressed.length];
	*     opaque MAC[SecurityParameters.mac_length];
	*     uint8 padding[GenericBlockCipher.padding_length];
	*     uint8 padding_length;
	*   };
	* } GenericBlockCipher;
	*
	* The MAC is generated as described in Section 6.2.3.1.
	*
	* IV:
	*   The Initialization Vector (IV) SHOULD be chosen at random, and MUST be
	*   unpredictable. Note that in versions of TLS prior to 1.1, there was no
	*   IV field, and the last ciphertext block of the previous record (the "CBC
	*   residue") was used as the IV. This was changed to prevent the attacks
	*   described in [CBCATT]. For block ciphers, the IV length is of length
	*   SecurityParameters.record_iv_length, which is equal to the
	*   SecurityParameters.block_size.
	*
	* padding:
	*   Padding that is added to force the length of the plaintext to be an
	*   integral multiple of the block cipher's block length. The padding MAY be
	*   any length up to 255 bytes, as long as it results in the
	*   TLSCiphertext.length being an integral multiple of the block length.
	*   Lengths longer than necessary might be desirable to frustrate attacks on
	*   a protocol that are based on analysis of the lengths of exchanged
	*   messages. Each uint8 in the padding data vector MUST be filled with the
	*   padding length value. The receiver MUST check this padding and MUST use
	*   the bad_record_mac alert to indicate padding errors.
	*
	* padding_length:
	*   The padding length MUST be such that the total size of the
	*   GenericBlockCipher structure is a multiple of the cipher's block length.
	*   Legal values range from zero to 255, inclusive. This length specifies the
	*   length of the padding field exclusive of the padding_length field itself.
	*
	* The encrypted data length (TLSCiphertext.length) is one more than the sum of
	* SecurityParameters.block_length, TLSCompressed.length,
	* SecurityParameters.mac_length, and padding_length.
	*
	* Example: If the block length is 8 bytes, the content length
	* (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, then the
	* length before padding is 82 bytes (this does not include the IV. Thus, the
	* padding length modulo 8 must be equal to 6 in order to make the total length
	* an even multiple of 8 bytes (the block length). The padding length can be
	* 6, 14, 22, and so on, through 254. If the padding length were the minimum
	* necessary, 6, the padding would be 6 bytes, each containing the value 6.
	* Thus, the last 8 octets of the GenericBlockCipher before block encryption
	* would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.
	*
	* Note: With block ciphers in CBC mode (Cipher Block Chaining), it is critical
	* that the entire plaintext of the record be known before any ciphertext is
	* transmitted. Otherwise, it is possible for the attacker to mount the attack
	* described in [CBCATT].
	*
	* Implementation note: Canvel et al. [CBCTIME] have demonstrated a timing
	* attack on CBC padding based on the time required to compute the MAC. In
	* order to defend against this attack, implementations MUST ensure that
	* record processing time is essentially the same whether or not the padding
	* is correct. In general, the best way to do this is to compute the MAC even
	* if the padding is incorrect, and only then reject the packet. For instance,
	* if the pad appears to be incorrect, the implementation might assume a
	* zero-length pad and then compute the MAC. This leaves a small timing
	* channel, since MAC performance depends, to some extent, on the size of the
	* data fragment, but it is not believed to be large enough to be exploitable,
	* due to the large block size of existing MACs and the small size of the
	* timing signal.
	*/
	var forge = require_forge();
	require_asn1();
	require_hmac();
	require_md5();
	require_pem();
	require_pki();
	require_random();
	require_sha1();
	require_util();
	/**
	* Generates pseudo random bytes by mixing the result of two hash functions,
	* MD5 and SHA-1.
	*
	* prf_TLS1(secret, label, seed) =
	*   P_MD5(S1, label + seed) XOR P_SHA-1(S2, label + seed);
	*
	* Each P_hash function functions as follows:
	*
	* P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
	*                        HMAC_hash(secret, A(2) + seed) +
	*                        HMAC_hash(secret, A(3) + seed) + ...
	* A() is defined as:
	*   A(0) = seed
	*   A(i) = HMAC_hash(secret, A(i-1))
	*
	* The '+' operator denotes concatenation.
	*
	* As many iterations A(N) as are needed are performed to generate enough
	* pseudo random byte output. If an iteration creates more data than is
	* necessary, then it is truncated.
	*
	* Therefore:
	* A(1) = HMAC_hash(secret, A(0))
	*      = HMAC_hash(secret, seed)
	* A(2) = HMAC_hash(secret, A(1))
	*      = HMAC_hash(secret, HMAC_hash(secret, seed))
	*
	* Therefore:
	* P_hash(secret, seed) =
	*   HMAC_hash(secret, HMAC_hash(secret, A(0)) + seed) +
	*   HMAC_hash(secret, HMAC_hash(secret, A(1)) + seed) +
	*   ...
	*
	* Therefore:
	* P_hash(secret, seed) =
	*   HMAC_hash(secret, HMAC_hash(secret, seed) + seed) +
	*   HMAC_hash(secret, HMAC_hash(secret, HMAC_hash(secret, seed)) + seed) +
	*   ...
	*
	* @param secret the secret to use.
	* @param label the label to use.
	* @param seed the seed value to use.
	* @param length the number of bytes to generate.
	*
	* @return the pseudo random bytes in a byte buffer.
	*/
	var prf_TLS1 = function(secret, label, seed, length) {
		var rval = forge.util.createBuffer();
		var idx = secret.length >> 1;
		var slen = idx + (secret.length & 1);
		var s1 = secret.substr(0, slen);
		var s2 = secret.substr(idx, slen);
		var ai = forge.util.createBuffer();
		var hmac = forge.hmac.create();
		seed = label + seed;
		var md5itr = Math.ceil(length / 16);
		var sha1itr = Math.ceil(length / 20);
		hmac.start("MD5", s1);
		var md5bytes = forge.util.createBuffer();
		ai.putBytes(seed);
		for (var i = 0; i < md5itr; ++i) {
			hmac.start(null, null);
			hmac.update(ai.getBytes());
			ai.putBuffer(hmac.digest());
			hmac.start(null, null);
			hmac.update(ai.bytes() + seed);
			md5bytes.putBuffer(hmac.digest());
		}
		hmac.start("SHA1", s2);
		var sha1bytes = forge.util.createBuffer();
		ai.clear();
		ai.putBytes(seed);
		for (var i = 0; i < sha1itr; ++i) {
			hmac.start(null, null);
			hmac.update(ai.getBytes());
			ai.putBuffer(hmac.digest());
			hmac.start(null, null);
			hmac.update(ai.bytes() + seed);
			sha1bytes.putBuffer(hmac.digest());
		}
		rval.putBytes(forge.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length));
		return rval;
	};
	/**
	* Gets a MAC for a record using the SHA-1 hash algorithm.
	*
	* @param key the mac key.
	* @param state the sequence number (array of two 32-bit integers).
	* @param record the record.
	*
	* @return the sha-1 hash (20 bytes) for the given record.
	*/
	var hmac_sha1 = function(key, seqNum, record) {
		var hmac = forge.hmac.create();
		hmac.start("SHA1", key);
		var b = forge.util.createBuffer();
		b.putInt32(seqNum[0]);
		b.putInt32(seqNum[1]);
		b.putByte(record.type);
		b.putByte(record.version.major);
		b.putByte(record.version.minor);
		b.putInt16(record.length);
		b.putBytes(record.fragment.bytes());
		hmac.update(b.getBytes());
		return hmac.digest().getBytes();
	};
	/**
	* Compresses the TLSPlaintext record into a TLSCompressed record using the
	* deflate algorithm.
	*
	* @param c the TLS connection.
	* @param record the TLSPlaintext record to compress.
	* @param s the ConnectionState to use.
	*
	* @return true on success, false on failure.
	*/
	var deflate = function(c, record, s) {
		var rval = false;
		try {
			var bytes = c.deflate(record.fragment.getBytes());
			record.fragment = forge.util.createBuffer(bytes);
			record.length = bytes.length;
			rval = true;
		} catch (ex) {}
		return rval;
	};
	/**
	* Decompresses the TLSCompressed record into a TLSPlaintext record using the
	* deflate algorithm.
	*
	* @param c the TLS connection.
	* @param record the TLSCompressed record to decompress.
	* @param s the ConnectionState to use.
	*
	* @return true on success, false on failure.
	*/
	var inflate = function(c, record, s) {
		var rval = false;
		try {
			var bytes = c.inflate(record.fragment.getBytes());
			record.fragment = forge.util.createBuffer(bytes);
			record.length = bytes.length;
			rval = true;
		} catch (ex) {}
		return rval;
	};
	/**
	* Reads a TLS variable-length vector from a byte buffer.
	*
	* Variable-length vectors are defined by specifying a subrange of legal
	* lengths, inclusively, using the notation <floor..ceiling>. When these are
	* encoded, the actual length precedes the vector's contents in the byte
	* stream. The length will be in the form of a number consuming as many bytes
	* as required to hold the vector's specified maximum (ceiling) length. A
	* variable-length vector with an actual length field of zero is referred to
	* as an empty vector.
	*
	* @param b the byte buffer.
	* @param lenBytes the number of bytes required to store the length.
	*
	* @return the resulting byte buffer.
	*/
	var readVector = function(b, lenBytes) {
		var len = 0;
		switch (lenBytes) {
			case 1:
				len = b.getByte();
				break;
			case 2:
				len = b.getInt16();
				break;
			case 3:
				len = b.getInt24();
				break;
			case 4:
				len = b.getInt32();
				break;
		}
		return forge.util.createBuffer(b.getBytes(len));
	};
	/**
	* Writes a TLS variable-length vector to a byte buffer.
	*
	* @param b the byte buffer.
	* @param lenBytes the number of bytes required to store the length.
	* @param v the byte buffer vector.
	*/
	var writeVector = function(b, lenBytes, v) {
		b.putInt(v.length(), lenBytes << 3);
		b.putBuffer(v);
	};
	/**
	* The tls implementation.
	*/
	var tls = {};
	/**
	* Version: TLS 1.2 = 3.3, TLS 1.1 = 3.2, TLS 1.0 = 3.1. Both TLS 1.1 and
	* TLS 1.2 were still too new (ie: openSSL didn't implement them) at the time
	* of this implementation so TLS 1.0 was implemented instead.
	*/
	tls.Versions = {
		TLS_1_0: {
			major: 3,
			minor: 1
		},
		TLS_1_1: {
			major: 3,
			minor: 2
		},
		TLS_1_2: {
			major: 3,
			minor: 3
		}
	};
	tls.SupportedVersions = [tls.Versions.TLS_1_1, tls.Versions.TLS_1_0];
	tls.Version = tls.SupportedVersions[0];
	/**
	* Maximum fragment size. True maximum is 16384, but we fragment before that
	* to allow for unusual small increases during compression.
	*/
	tls.MaxFragment = 15360;
	/**
	* Whether this entity is considered the "client" or "server".
	* enum { server, client } ConnectionEnd;
	*/
	tls.ConnectionEnd = {
		server: 0,
		client: 1
	};
	/**
	* Pseudo-random function algorithm used to generate keys from the master
	* secret.
	* enum { tls_prf_sha256 } PRFAlgorithm;
	*/
	tls.PRFAlgorithm = { tls_prf_sha256: 0 };
	/**
	* Bulk encryption algorithms.
	* enum { null, rc4, des3, aes } BulkCipherAlgorithm;
	*/
	tls.BulkCipherAlgorithm = {
		none: null,
		rc4: 0,
		des3: 1,
		aes: 2
	};
	/**
	* Cipher types.
	* enum { stream, block, aead } CipherType;
	*/
	tls.CipherType = {
		stream: 0,
		block: 1,
		aead: 2
	};
	/**
	* MAC (Message Authentication Code) algorithms.
	* enum { null, hmac_md5, hmac_sha1, hmac_sha256,
	*   hmac_sha384, hmac_sha512} MACAlgorithm;
	*/
	tls.MACAlgorithm = {
		none: null,
		hmac_md5: 0,
		hmac_sha1: 1,
		hmac_sha256: 2,
		hmac_sha384: 3,
		hmac_sha512: 4
	};
	/**
	* Compression algorithms.
	* enum { null(0), deflate(1), (255) } CompressionMethod;
	*/
	tls.CompressionMethod = {
		none: 0,
		deflate: 1
	};
	/**
	* TLS record content types.
	* enum {
	*   change_cipher_spec(20), alert(21), handshake(22),
	*   application_data(23), (255)
	* } ContentType;
	*/
	tls.ContentType = {
		change_cipher_spec: 20,
		alert: 21,
		handshake: 22,
		application_data: 23,
		heartbeat: 24
	};
	/**
	* TLS handshake types.
	* enum {
	*   hello_request(0), client_hello(1), server_hello(2),
	*   certificate(11), server_key_exchange (12),
	*   certificate_request(13), server_hello_done(14),
	*   certificate_verify(15), client_key_exchange(16),
	*   finished(20), (255)
	* } HandshakeType;
	*/
	tls.HandshakeType = {
		hello_request: 0,
		client_hello: 1,
		server_hello: 2,
		certificate: 11,
		server_key_exchange: 12,
		certificate_request: 13,
		server_hello_done: 14,
		certificate_verify: 15,
		client_key_exchange: 16,
		finished: 20
	};
	/**
	* TLS Alert Protocol.
	*
	* enum { warning(1), fatal(2), (255) } AlertLevel;
	*
	* enum {
	*   close_notify(0),
	*   unexpected_message(10),
	*   bad_record_mac(20),
	*   decryption_failed(21),
	*   record_overflow(22),
	*   decompression_failure(30),
	*   handshake_failure(40),
	*   bad_certificate(42),
	*   unsupported_certificate(43),
	*   certificate_revoked(44),
	*   certificate_expired(45),
	*   certificate_unknown(46),
	*   illegal_parameter(47),
	*   unknown_ca(48),
	*   access_denied(49),
	*   decode_error(50),
	*   decrypt_error(51),
	*   export_restriction(60),
	*   protocol_version(70),
	*   insufficient_security(71),
	*   internal_error(80),
	*   user_canceled(90),
	*   no_renegotiation(100),
	*   (255)
	* } AlertDescription;
	*
	* struct {
	*   AlertLevel level;
	*   AlertDescription description;
	* } Alert;
	*/
	tls.Alert = {};
	tls.Alert.Level = {
		warning: 1,
		fatal: 2
	};
	tls.Alert.Description = {
		close_notify: 0,
		unexpected_message: 10,
		bad_record_mac: 20,
		decryption_failed: 21,
		record_overflow: 22,
		decompression_failure: 30,
		handshake_failure: 40,
		bad_certificate: 42,
		unsupported_certificate: 43,
		certificate_revoked: 44,
		certificate_expired: 45,
		certificate_unknown: 46,
		illegal_parameter: 47,
		unknown_ca: 48,
		access_denied: 49,
		decode_error: 50,
		decrypt_error: 51,
		export_restriction: 60,
		protocol_version: 70,
		insufficient_security: 71,
		internal_error: 80,
		user_canceled: 90,
		no_renegotiation: 100
	};
	/**
	* TLS Heartbeat Message types.
	* enum {
	*   heartbeat_request(1),
	*   heartbeat_response(2),
	*   (255)
	* } HeartbeatMessageType;
	*/
	tls.HeartbeatMessageType = {
		heartbeat_request: 1,
		heartbeat_response: 2
	};
	/**
	* Supported cipher suites.
	*/
	tls.CipherSuites = {};
	/**
	* Gets a supported cipher suite from its 2 byte ID.
	*
	* @param twoBytes two bytes in a string.
	*
	* @return the matching supported cipher suite or null.
	*/
	tls.getCipherSuite = function(twoBytes) {
		var rval = null;
		for (var key in tls.CipherSuites) {
			var cs = tls.CipherSuites[key];
			if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
				rval = cs;
				break;
			}
		}
		return rval;
	};
	/**
	* Called when an unexpected record is encountered.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleUnexpected = function(c, record) {
		if (!(!c.open && c.entity === tls.ConnectionEnd.client)) c.error(c, {
			message: "Unexpected message. Received TLS record out of order.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.unexpected_message
			}
		});
	};
	/**
	* Called when a client receives a HelloRequest record.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleHelloRequest = function(c, record, length) {
		if (!c.handshaking && c.handshakes > 0) {
			tls.queue(c, tls.createAlert(c, {
				level: tls.Alert.Level.warning,
				description: tls.Alert.Description.no_renegotiation
			}));
			tls.flush(c);
		}
		c.process();
	};
	/**
	* Parses a hello message from a ClientHello or ServerHello record.
	*
	* @param record the record to parse.
	*
	* @return the parsed message.
	*/
	tls.parseHelloMessage = function(c, record, length) {
		var msg = null;
		var client = c.entity === tls.ConnectionEnd.client;
		if (length < 38) c.error(c, {
			message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		else {
			var b = record.fragment;
			var remaining = b.length();
			msg = {
				version: {
					major: b.getByte(),
					minor: b.getByte()
				},
				random: forge.util.createBuffer(b.getBytes(32)),
				session_id: readVector(b, 1),
				extensions: []
			};
			if (client) {
				msg.cipher_suite = b.getBytes(2);
				msg.compression_method = b.getByte();
			} else {
				msg.cipher_suites = readVector(b, 2);
				msg.compression_methods = readVector(b, 1);
			}
			remaining = length - (remaining - b.length());
			if (remaining > 0) {
				var exts = readVector(b, 2);
				while (exts.length() > 0) msg.extensions.push({
					type: [exts.getByte(), exts.getByte()],
					data: readVector(exts, 2)
				});
				if (!client) for (var i = 0; i < msg.extensions.length; ++i) {
					var ext = msg.extensions[i];
					if (ext.type[0] === 0 && ext.type[1] === 0) {
						var snl = readVector(ext.data, 2);
						while (snl.length() > 0) {
							if (snl.getByte() !== 0) break;
							c.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes());
						}
					}
				}
			}
			if (c.session.version) {
				if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) return c.error(c, {
					message: "TLS version change is disallowed during renegotiation.",
					send: true,
					alert: {
						level: tls.Alert.Level.fatal,
						description: tls.Alert.Description.protocol_version
					}
				});
			}
			if (client) c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
			else {
				var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
				while (tmp.length() > 0) {
					c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
					if (c.session.cipherSuite !== null) break;
				}
			}
			if (c.session.cipherSuite === null) return c.error(c, {
				message: "No cipher suites in common.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.handshake_failure
				},
				cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
			});
			if (client) c.session.compressionMethod = msg.compression_method;
			else c.session.compressionMethod = tls.CompressionMethod.none;
		}
		return msg;
	};
	/**
	* Creates security parameters for the given connection based on the given
	* hello message.
	*
	* @param c the TLS connection.
	* @param msg the hello message.
	*/
	tls.createSecurityParameters = function(c, msg) {
		var client = c.entity === tls.ConnectionEnd.client;
		var msgRandom = msg.random.bytes();
		var cRandom = client ? c.session.sp.client_random : msgRandom;
		var sRandom = client ? msgRandom : tls.createRandom().getBytes();
		c.session.sp = {
			entity: c.entity,
			prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
			bulk_cipher_algorithm: null,
			cipher_type: null,
			enc_key_length: null,
			block_length: null,
			fixed_iv_length: null,
			record_iv_length: null,
			mac_algorithm: null,
			mac_length: null,
			mac_key_length: null,
			compression_algorithm: c.session.compressionMethod,
			pre_master_secret: null,
			master_secret: null,
			client_random: cRandom,
			server_random: sRandom
		};
	};
	/**
	* Called when a client receives a ServerHello record.
	*
	* When a ServerHello message will be sent:
	*   The server will send this message in response to a client hello message
	*   when it was able to find an acceptable set of algorithms. If it cannot
	*   find such a match, it will respond with a handshake failure alert.
	*
	* uint24 length;
	* struct {
	*   ProtocolVersion server_version;
	*   Random random;
	*   SessionID session_id;
	*   CipherSuite cipher_suite;
	*   CompressionMethod compression_method;
	*   select(extensions_present) {
	*     case false:
	*       struct {};
	*     case true:
	*       Extension extensions<0..2^16-1>;
	*   };
	* } ServerHello;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleServerHello = function(c, record, length) {
		var msg = tls.parseHelloMessage(c, record, length);
		if (c.fail) return;
		if (msg.version.minor <= c.version.minor) c.version.minor = msg.version.minor;
		else return c.error(c, {
			message: "Incompatible TLS version.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.protocol_version
			}
		});
		c.session.version = c.version;
		var sessionId = msg.session_id.bytes();
		if (sessionId.length > 0 && sessionId === c.session.id) {
			c.expect = SCC;
			c.session.resuming = true;
			c.session.sp.server_random = msg.random.bytes();
		} else {
			c.expect = SCE;
			c.session.resuming = false;
			tls.createSecurityParameters(c, msg);
		}
		c.session.id = sessionId;
		c.process();
	};
	/**
	* Called when a server receives a ClientHello record.
	*
	* When a ClientHello message will be sent:
	*   When a client first connects to a server it is required to send the
	*   client hello as its first message. The client can also send a client
	*   hello in response to a hello request or on its own initiative in order
	*   to renegotiate the security parameters in an existing connection.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleClientHello = function(c, record, length) {
		var msg = tls.parseHelloMessage(c, record, length);
		if (c.fail) return;
		var sessionId = msg.session_id.bytes();
		var session = null;
		if (c.sessionCache) {
			session = c.sessionCache.getSession(sessionId);
			if (session === null) sessionId = "";
			else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
				session = null;
				sessionId = "";
			}
		}
		if (sessionId.length === 0) sessionId = forge.random.getBytes(32);
		c.session.id = sessionId;
		c.session.clientHelloVersion = msg.version;
		c.session.sp = {};
		if (session) {
			c.version = c.session.version = session.version;
			c.session.sp = session.sp;
		} else {
			var version;
			for (var i = 1; i < tls.SupportedVersions.length; ++i) {
				version = tls.SupportedVersions[i];
				if (version.minor <= msg.version.minor) break;
			}
			c.version = {
				major: version.major,
				minor: version.minor
			};
			c.session.version = c.version;
		}
		if (session !== null) {
			c.expect = CCC;
			c.session.resuming = true;
			c.session.sp.client_random = msg.random.bytes();
		} else {
			c.expect = c.verifyClient !== false ? CCE : CKE;
			c.session.resuming = false;
			tls.createSecurityParameters(c, msg);
		}
		c.open = true;
		tls.queue(c, tls.createRecord(c, {
			type: tls.ContentType.handshake,
			data: tls.createServerHello(c)
		}));
		if (c.session.resuming) {
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.change_cipher_spec,
				data: tls.createChangeCipherSpec()
			}));
			c.state.pending = tls.createConnectionState(c);
			c.state.current.write = c.state.pending.write;
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createFinished(c)
			}));
		} else {
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createCertificate(c)
			}));
			if (!c.fail) {
				tls.queue(c, tls.createRecord(c, {
					type: tls.ContentType.handshake,
					data: tls.createServerKeyExchange(c)
				}));
				if (c.verifyClient !== false) tls.queue(c, tls.createRecord(c, {
					type: tls.ContentType.handshake,
					data: tls.createCertificateRequest(c)
				}));
				tls.queue(c, tls.createRecord(c, {
					type: tls.ContentType.handshake,
					data: tls.createServerHelloDone(c)
				}));
			}
		}
		tls.flush(c);
		c.process();
	};
	/**
	* Called when a client receives a Certificate record.
	*
	* When this message will be sent:
	*   The server must send a certificate whenever the agreed-upon key exchange
	*   method is not an anonymous one. This message will always immediately
	*   follow the server hello message.
	*
	* Meaning of this message:
	*   The certificate type must be appropriate for the selected cipher suite's
	*   key exchange algorithm, and is generally an X.509v3 certificate. It must
	*   contain a key which matches the key exchange method, as follows. Unless
	*   otherwise specified, the signing algorithm for the certificate must be
	*   the same as the algorithm for the certificate key. Unless otherwise
	*   specified, the public key may be of any length.
	*
	* opaque ASN.1Cert<1..2^24-1>;
	* struct {
	*   ASN.1Cert certificate_list<1..2^24-1>;
	* } Certificate;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleCertificate = function(c, record, length) {
		if (length < 3) return c.error(c, {
			message: "Invalid Certificate message. Message too short.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		var b = record.fragment;
		var msg = { certificate_list: readVector(b, 3) };
		var cert, asn1;
		var certs = [];
		try {
			while (msg.certificate_list.length() > 0) {
				cert = readVector(msg.certificate_list, 3);
				asn1 = forge.asn1.fromDer(cert);
				cert = forge.pki.certificateFromAsn1(asn1, true);
				certs.push(cert);
			}
		} catch (ex) {
			return c.error(c, {
				message: "Could not parse certificate list.",
				cause: ex,
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.bad_certificate
				}
			});
		}
		var client = c.entity === tls.ConnectionEnd.client;
		if ((client || c.verifyClient === true) && certs.length === 0) c.error(c, {
			message: client ? "No server certificate provided." : "No client certificate provided.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		else if (certs.length === 0) c.expect = client ? SKE : CKE;
		else {
			if (client) c.session.serverCertificate = certs[0];
			else c.session.clientCertificate = certs[0];
			if (tls.verifyCertificateChain(c, certs)) c.expect = client ? SKE : CKE;
		}
		c.process();
	};
	/**
	* Called when a client receives a ServerKeyExchange record.
	*
	* When this message will be sent:
	*   This message will be sent immediately after the server certificate
	*   message (or the server hello message, if this is an anonymous
	*   negotiation).
	*
	*   The server key exchange message is sent by the server only when the
	*   server certificate message (if sent) does not contain enough data to
	*   allow the client to exchange a premaster secret.
	*
	* Meaning of this message:
	*   This message conveys cryptographic information to allow the client to
	*   communicate the premaster secret: either an RSA public key to encrypt
	*   the premaster secret with, or a Diffie-Hellman public key with which the
	*   client can complete a key exchange (with the result being the premaster
	*   secret.)
	*
	* enum {
	*   dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
	* } KeyExchangeAlgorithm;
	*
	* struct {
	*   opaque dh_p<1..2^16-1>;
	*   opaque dh_g<1..2^16-1>;
	*   opaque dh_Ys<1..2^16-1>;
	* } ServerDHParams;
	*
	* struct {
	*   select(KeyExchangeAlgorithm) {
	*     case dh_anon:
	*       ServerDHParams params;
	*     case dhe_dss:
	*     case dhe_rsa:
	*       ServerDHParams params;
	*       digitally-signed struct {
	*         opaque client_random[32];
	*         opaque server_random[32];
	*         ServerDHParams params;
	*       } signed_params;
	*     case rsa:
	*     case dh_dss:
	*     case dh_rsa:
	*       struct {};
	*   };
	* } ServerKeyExchange;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleServerKeyExchange = function(c, record, length) {
		if (length > 0) return c.error(c, {
			message: "Invalid key parameters. Only RSA is supported.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.unsupported_certificate
			}
		});
		c.expect = SCR;
		c.process();
	};
	/**
	* Called when a client receives a ClientKeyExchange record.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleClientKeyExchange = function(c, record, length) {
		if (length < 48) return c.error(c, {
			message: "Invalid key parameters. Only RSA is supported.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.unsupported_certificate
			}
		});
		var b = record.fragment;
		var msg = { enc_pre_master_secret: readVector(b, 2).getBytes() };
		var privateKey = null;
		if (c.getPrivateKey) try {
			privateKey = c.getPrivateKey(c, c.session.serverCertificate);
			privateKey = forge.pki.privateKeyFromPem(privateKey);
		} catch (ex) {
			c.error(c, {
				message: "Could not get private key.",
				cause: ex,
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.internal_error
				}
			});
		}
		if (privateKey === null) return c.error(c, {
			message: "No private key set.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.internal_error
			}
		});
		try {
			var sp = c.session.sp;
			sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
			var version = c.session.clientHelloVersion;
			if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) throw new Error("TLS version rollback attack detected.");
		} catch (ex) {
			sp.pre_master_secret = forge.random.getBytes(48);
		}
		c.expect = CCC;
		if (c.session.clientCertificate !== null) c.expect = CCV;
		c.process();
	};
	/**
	* Called when a client receives a CertificateRequest record.
	*
	* When this message will be sent:
	*   A non-anonymous server can optionally request a certificate from the
	*   client, if appropriate for the selected cipher suite. This message, if
	*   sent, will immediately follow the Server Key Exchange message (if it is
	*   sent; otherwise, the Server Certificate message).
	*
	* enum {
	*   rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
	*   rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
	*   fortezza_dms_RESERVED(20), (255)
	* } ClientCertificateType;
	*
	* opaque DistinguishedName<1..2^16-1>;
	*
	* struct {
	*   ClientCertificateType certificate_types<1..2^8-1>;
	*   SignatureAndHashAlgorithm supported_signature_algorithms<2^16-1>;
	*   DistinguishedName certificate_authorities<0..2^16-1>;
	* } CertificateRequest;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleCertificateRequest = function(c, record, length) {
		if (length < 3) return c.error(c, {
			message: "Invalid CertificateRequest. Message too short.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		var b = record.fragment;
		var msg = {
			certificate_types: readVector(b, 1),
			certificate_authorities: readVector(b, 2)
		};
		c.session.certificateRequest = msg;
		c.expect = SHD;
		c.process();
	};
	/**
	* Called when a server receives a CertificateVerify record.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleCertificateVerify = function(c, record, length) {
		if (length < 2) return c.error(c, {
			message: "Invalid CertificateVerify. Message too short.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		var b = record.fragment;
		b.read -= 4;
		var msgBytes = b.bytes();
		b.read += 4;
		var msg = { signature: readVector(b, 2).getBytes() };
		var verify = forge.util.createBuffer();
		verify.putBuffer(c.session.md5.digest());
		verify.putBuffer(c.session.sha1.digest());
		verify = verify.getBytes();
		try {
			if (!c.session.clientCertificate.publicKey.verify(verify, msg.signature, "NONE")) throw new Error("CertificateVerify signature does not match.");
			c.session.md5.update(msgBytes);
			c.session.sha1.update(msgBytes);
		} catch (ex) {
			return c.error(c, {
				message: "Bad signature in CertificateVerify.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.handshake_failure
				}
			});
		}
		c.expect = CCC;
		c.process();
	};
	/**
	* Called when a client receives a ServerHelloDone record.
	*
	* When this message will be sent:
	*   The server hello done message is sent by the server to indicate the end
	*   of the server hello and associated messages. After sending this message
	*   the server will wait for a client response.
	*
	* Meaning of this message:
	*   This message means that the server is done sending messages to support
	*   the key exchange, and the client can proceed with its phase of the key
	*   exchange.
	*
	*   Upon receipt of the server hello done message the client should verify
	*   that the server provided a valid certificate if required and check that
	*   the server hello parameters are acceptable.
	*
	* struct {} ServerHelloDone;
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleServerHelloDone = function(c, record, length) {
		if (length > 0) return c.error(c, {
			message: "Invalid ServerHelloDone message. Invalid length.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.record_overflow
			}
		});
		if (c.serverCertificate === null) {
			var error = {
				message: "No server certificate provided. Not enough security.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.insufficient_security
				}
			};
			var ret = c.verify(c, error.alert.description, 0, []);
			if (ret !== true) {
				if (ret || ret === 0) {
					if (typeof ret === "object" && !forge.util.isArray(ret)) {
						if (ret.message) error.message = ret.message;
						if (ret.alert) error.alert.description = ret.alert;
					} else if (typeof ret === "number") error.alert.description = ret;
				}
				return c.error(c, error);
			}
		}
		if (c.session.certificateRequest !== null) {
			record = tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createCertificate(c)
			});
			tls.queue(c, record);
		}
		record = tls.createRecord(c, {
			type: tls.ContentType.handshake,
			data: tls.createClientKeyExchange(c)
		});
		tls.queue(c, record);
		c.expect = SER;
		var callback = function(c, signature) {
			if (c.session.certificateRequest !== null && c.session.clientCertificate !== null) tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createCertificateVerify(c, signature)
			}));
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.change_cipher_spec,
				data: tls.createChangeCipherSpec()
			}));
			c.state.pending = tls.createConnectionState(c);
			c.state.current.write = c.state.pending.write;
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createFinished(c)
			}));
			c.expect = SCC;
			tls.flush(c);
			c.process();
		};
		if (c.session.certificateRequest === null || c.session.clientCertificate === null) return callback(c, null);
		tls.getClientSignature(c, callback);
	};
	/**
	* Called when a ChangeCipherSpec record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleChangeCipherSpec = function(c, record) {
		if (record.fragment.getByte() !== 1) return c.error(c, {
			message: "Invalid ChangeCipherSpec message received.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.illegal_parameter
			}
		});
		var client = c.entity === tls.ConnectionEnd.client;
		if (c.session.resuming && client || !c.session.resuming && !client) c.state.pending = tls.createConnectionState(c);
		c.state.current.read = c.state.pending.read;
		if (!c.session.resuming && client || c.session.resuming && !client) c.state.pending = null;
		c.expect = client ? SFI : CFI;
		c.process();
	};
	/**
	* Called when a Finished record is received.
	*
	* When this message will be sent:
	*   A finished message is always sent immediately after a change
	*   cipher spec message to verify that the key exchange and
	*   authentication processes were successful. It is essential that a
	*   change cipher spec message be received between the other
	*   handshake messages and the Finished message.
	*
	* Meaning of this message:
	*   The finished message is the first protected with the just-
	*   negotiated algorithms, keys, and secrets. Recipients of finished
	*   messages must verify that the contents are correct.  Once a side
	*   has sent its Finished message and received and validated the
	*   Finished message from its peer, it may begin to send and receive
	*   application data over the connection.
	*
	* struct {
	*   opaque verify_data[verify_data_length];
	* } Finished;
	*
	* verify_data
	*   PRF(master_secret, finished_label, Hash(handshake_messages))
	*     [0..verify_data_length-1];
	*
	* finished_label
	*   For Finished messages sent by the client, the string
	*   "client finished". For Finished messages sent by the server, the
	*   string "server finished".
	*
	* verify_data_length depends on the cipher suite. If it is not specified
	* by the cipher suite, then it is 12. Versions of TLS < 1.2 always used
	* 12 bytes.
	*
	* @param c the connection.
	* @param record the record.
	* @param length the length of the handshake message.
	*/
	tls.handleFinished = function(c, record, length) {
		var b = record.fragment;
		b.read -= 4;
		var msgBytes = b.bytes();
		b.read += 4;
		var vd = record.fragment.getBytes();
		b = forge.util.createBuffer();
		b.putBuffer(c.session.md5.digest());
		b.putBuffer(c.session.sha1.digest());
		var client = c.entity === tls.ConnectionEnd.client;
		var label = client ? "server finished" : "client finished";
		var sp = c.session.sp;
		b = prf_TLS1(sp.master_secret, label, b.getBytes(), 12);
		if (b.getBytes() !== vd) return c.error(c, {
			message: "Invalid verify_data in Finished message.",
			send: true,
			alert: {
				level: tls.Alert.Level.fatal,
				description: tls.Alert.Description.decrypt_error
			}
		});
		c.session.md5.update(msgBytes);
		c.session.sha1.update(msgBytes);
		if (c.session.resuming && client || !c.session.resuming && !client) {
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.change_cipher_spec,
				data: tls.createChangeCipherSpec()
			}));
			c.state.current.write = c.state.pending.write;
			c.state.pending = null;
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.handshake,
				data: tls.createFinished(c)
			}));
		}
		c.expect = client ? SAD : CAD;
		c.handshaking = false;
		++c.handshakes;
		c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
		tls.flush(c);
		c.isConnected = true;
		c.connected(c);
		c.process();
	};
	/**
	* Called when an Alert record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleAlert = function(c, record) {
		var b = record.fragment;
		var alert = {
			level: b.getByte(),
			description: b.getByte()
		};
		var msg;
		switch (alert.description) {
			case tls.Alert.Description.close_notify:
				msg = "Connection closed.";
				break;
			case tls.Alert.Description.unexpected_message:
				msg = "Unexpected message.";
				break;
			case tls.Alert.Description.bad_record_mac:
				msg = "Bad record MAC.";
				break;
			case tls.Alert.Description.decryption_failed:
				msg = "Decryption failed.";
				break;
			case tls.Alert.Description.record_overflow:
				msg = "Record overflow.";
				break;
			case tls.Alert.Description.decompression_failure:
				msg = "Decompression failed.";
				break;
			case tls.Alert.Description.handshake_failure:
				msg = "Handshake failure.";
				break;
			case tls.Alert.Description.bad_certificate:
				msg = "Bad certificate.";
				break;
			case tls.Alert.Description.unsupported_certificate:
				msg = "Unsupported certificate.";
				break;
			case tls.Alert.Description.certificate_revoked:
				msg = "Certificate revoked.";
				break;
			case tls.Alert.Description.certificate_expired:
				msg = "Certificate expired.";
				break;
			case tls.Alert.Description.certificate_unknown:
				msg = "Certificate unknown.";
				break;
			case tls.Alert.Description.illegal_parameter:
				msg = "Illegal parameter.";
				break;
			case tls.Alert.Description.unknown_ca:
				msg = "Unknown certificate authority.";
				break;
			case tls.Alert.Description.access_denied:
				msg = "Access denied.";
				break;
			case tls.Alert.Description.decode_error:
				msg = "Decode error.";
				break;
			case tls.Alert.Description.decrypt_error:
				msg = "Decrypt error.";
				break;
			case tls.Alert.Description.export_restriction:
				msg = "Export restriction.";
				break;
			case tls.Alert.Description.protocol_version:
				msg = "Unsupported protocol version.";
				break;
			case tls.Alert.Description.insufficient_security:
				msg = "Insufficient security.";
				break;
			case tls.Alert.Description.internal_error:
				msg = "Internal error.";
				break;
			case tls.Alert.Description.user_canceled:
				msg = "User canceled.";
				break;
			case tls.Alert.Description.no_renegotiation:
				msg = "Renegotiation not supported.";
				break;
			default:
				msg = "Unknown error.";
				break;
		}
		if (alert.description === tls.Alert.Description.close_notify) return c.close();
		c.error(c, {
			message: msg,
			send: false,
			origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
			alert
		});
		c.process();
	};
	/**
	* Called when a Handshake record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleHandshake = function(c, record) {
		var b = record.fragment;
		var type = b.getByte();
		var length = b.getInt24();
		if (length > b.length()) {
			c.fragmented = record;
			record.fragment = forge.util.createBuffer();
			b.read -= 4;
			return c.process();
		}
		c.fragmented = null;
		b.read -= 4;
		var bytes = b.bytes(length + 4);
		b.read += 4;
		if (type in hsTable[c.entity][c.expect]) {
			if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
				c.handshaking = true;
				c.session = {
					version: null,
					extensions: { server_name: { serverNameList: [] } },
					cipherSuite: null,
					compressionMethod: null,
					serverCertificate: null,
					clientCertificate: null,
					md5: forge.md.md5.create(),
					sha1: forge.md.sha1.create()
				};
			}
			if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
				c.session.md5.update(bytes);
				c.session.sha1.update(bytes);
			}
			hsTable[c.entity][c.expect][type](c, record, length);
		} else tls.handleUnexpected(c, record);
	};
	/**
	* Called when an ApplicationData record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleApplicationData = function(c, record) {
		c.data.putBuffer(record.fragment);
		c.dataReady(c);
		c.process();
	};
	/**
	* Called when a Heartbeat record is received.
	*
	* @param c the connection.
	* @param record the record.
	*/
	tls.handleHeartbeat = function(c, record) {
		var b = record.fragment;
		var type = b.getByte();
		var length = b.getInt16();
		var payload = b.getBytes(length);
		if (type === tls.HeartbeatMessageType.heartbeat_request) {
			if (c.handshaking || length > payload.length) return c.process();
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.heartbeat,
				data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_response, payload)
			}));
			tls.flush(c);
		} else if (type === tls.HeartbeatMessageType.heartbeat_response) {
			if (payload !== c.expectedHeartbeatPayload) return c.process();
			if (c.heartbeatReceived) c.heartbeatReceived(c, forge.util.createBuffer(payload));
		}
		c.process();
	};
	/**
	* The transistional state tables for receiving TLS records. It maps the
	* current TLS engine state and a received record to a function to handle the
	* record and update the state.
	*
	* For instance, if the current state is SHE, then the TLS engine is expecting
	* a ServerHello record. Once a record is received, the handler function is
	* looked up using the state SHE and the record's content type.
	*
	* The resulting function will either be an error handler or a record handler.
	* The function will take whatever action is appropriate and update the state
	* for the next record.
	*
	* The states are all based on possible server record types. Note that the
	* client will never specifically expect to receive a HelloRequest or an alert
	* from the server so there is no state that reflects this. These messages may
	* occur at any time.
	*
	* There are two tables for mapping states because there is a second tier of
	* types for handshake messages. Once a record with a content type of handshake
	* is received, the handshake record handler will look up the handshake type in
	* the secondary map to get its appropriate handler.
	*
	* Valid message orders are as follows:
	*
	* =======================FULL HANDSHAKE======================
	* Client                                               Server
	*
	* ClientHello                  -------->
	*                                                 ServerHello
	*                                                Certificate*
	*                                          ServerKeyExchange*
	*                                         CertificateRequest*
	*                              <--------      ServerHelloDone
	* Certificate*
	* ClientKeyExchange
	* CertificateVerify*
	* [ChangeCipherSpec]
	* Finished                     -------->
	*                                          [ChangeCipherSpec]
	*                              <--------             Finished
	* Application Data             <------->     Application Data
	*
	* =====================SESSION RESUMPTION=====================
	* Client                                                Server
	*
	* ClientHello                   -------->
	*                                                  ServerHello
	*                                           [ChangeCipherSpec]
	*                               <--------             Finished
	* [ChangeCipherSpec]
	* Finished                      -------->
	* Application Data              <------->     Application Data
	*/
	var SHE = 0;
	var SCE = 1;
	var SKE = 2;
	var SCR = 3;
	var SHD = 4;
	var SCC = 5;
	var SFI = 6;
	var SAD = 7;
	var SER = 8;
	var CHE = 0;
	var CCE = 1;
	var CKE = 2;
	var CCV = 3;
	var CCC = 4;
	var CFI = 5;
	var CAD = 6;
	var __ = tls.handleUnexpected;
	var R0 = tls.handleChangeCipherSpec;
	var R1 = tls.handleAlert;
	var R2 = tls.handleHandshake;
	var R3 = tls.handleApplicationData;
	var R4 = tls.handleHeartbeat;
	var ctTable = [];
	ctTable[tls.ConnectionEnd.client] = [
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			R0,
			R1,
			__,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			R3,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		]
	];
	ctTable[tls.ConnectionEnd.server] = [
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			R0,
			R1,
			__,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		],
		[
			__,
			R1,
			R2,
			R3,
			R4
		],
		[
			__,
			R1,
			R2,
			__,
			R4
		]
	];
	var H0 = tls.handleHelloRequest;
	var H1 = tls.handleServerHello;
	var H2 = tls.handleCertificate;
	var H3 = tls.handleServerKeyExchange;
	var H4 = tls.handleCertificateRequest;
	var H5 = tls.handleServerHelloDone;
	var H6 = tls.handleFinished;
	var hsTable = [];
	hsTable[tls.ConnectionEnd.client] = [
		[
			__,
			__,
			H1,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H2,
			H3,
			H4,
			H5,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H3,
			H4,
			H5,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H4,
			H5,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H5,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H6
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			H0,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		]
	];
	var H7 = tls.handleClientHello;
	var H8 = tls.handleClientKeyExchange;
	var H9 = tls.handleCertificateVerify;
	hsTable[tls.ConnectionEnd.server] = [
		[
			__,
			H7,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H2,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H8,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H9,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			H6
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		],
		[
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__,
			__
		]
	];
	/**
	* Generates the master_secret and keys using the given security parameters.
	*
	* The security parameters for a TLS connection state are defined as such:
	*
	* struct {
	*   ConnectionEnd          entity;
	*   PRFAlgorithm           prf_algorithm;
	*   BulkCipherAlgorithm    bulk_cipher_algorithm;
	*   CipherType             cipher_type;
	*   uint8                  enc_key_length;
	*   uint8                  block_length;
	*   uint8                  fixed_iv_length;
	*   uint8                  record_iv_length;
	*   MACAlgorithm           mac_algorithm;
	*   uint8                  mac_length;
	*   uint8                  mac_key_length;
	*   CompressionMethod      compression_algorithm;
	*   opaque                 master_secret[48];
	*   opaque                 client_random[32];
	*   opaque                 server_random[32];
	* } SecurityParameters;
	*
	* Note that this definition is from TLS 1.2. In TLS 1.0 some of these
	* parameters are ignored because, for instance, the PRFAlgorithm is a
	* builtin-fixed algorithm combining iterations of MD5 and SHA-1 in TLS 1.0.
	*
	* The Record Protocol requires an algorithm to generate keys required by the
	* current connection state.
	*
	* The master secret is expanded into a sequence of secure bytes, which is then
	* split to a client write MAC key, a server write MAC key, a client write
	* encryption key, and a server write encryption key. In TLS 1.0 a client write
	* IV and server write IV are also generated. Each of these is generated from
	* the byte sequence in that order. Unused values are empty. In TLS 1.2, some
	* AEAD ciphers may additionally require a client write IV and a server write
	* IV (see Section 6.2.3.3).
	*
	* When keys, MAC keys, and IVs are generated, the master secret is used as an
	* entropy source.
	*
	* To generate the key material, compute:
	*
	* master_secret = PRF(pre_master_secret, "master secret",
	*                     ClientHello.random + ServerHello.random)
	*
	* key_block = PRF(SecurityParameters.master_secret,
	*                 "key expansion",
	*                 SecurityParameters.server_random +
	*                 SecurityParameters.client_random);
	*
	* until enough output has been generated. Then, the key_block is
	* partitioned as follows:
	*
	* client_write_MAC_key[SecurityParameters.mac_key_length]
	* server_write_MAC_key[SecurityParameters.mac_key_length]
	* client_write_key[SecurityParameters.enc_key_length]
	* server_write_key[SecurityParameters.enc_key_length]
	* client_write_IV[SecurityParameters.fixed_iv_length]
	* server_write_IV[SecurityParameters.fixed_iv_length]
	*
	* In TLS 1.2, the client_write_IV and server_write_IV are only generated for
	* implicit nonce techniques as described in Section 3.2.1 of [AEAD]. This
	* implementation uses TLS 1.0 so IVs are generated.
	*
	* Implementation note: The currently defined cipher suite which requires the
	* most material is AES_256_CBC_SHA256. It requires 2 x 32 byte keys and 2 x 32
	* byte MAC keys, for a total 128 bytes of key material. In TLS 1.0 it also
	* requires 2 x 16 byte IVs, so it actually takes 160 bytes of key material.
	*
	* @param c the connection.
	* @param sp the security parameters to use.
	*
	* @return the security keys.
	*/
	tls.generateKeys = function(c, sp) {
		var prf = prf_TLS1;
		var random = sp.client_random + sp.server_random;
		if (!c.session.resuming) {
			sp.master_secret = prf(sp.pre_master_secret, "master secret", random, 48).bytes();
			sp.pre_master_secret = null;
		}
		random = sp.server_random + sp.client_random;
		var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
		var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
		if (tls10) length += 2 * sp.fixed_iv_length;
		var km = prf(sp.master_secret, "key expansion", random, length);
		var rval = {
			client_write_MAC_key: km.getBytes(sp.mac_key_length),
			server_write_MAC_key: km.getBytes(sp.mac_key_length),
			client_write_key: km.getBytes(sp.enc_key_length),
			server_write_key: km.getBytes(sp.enc_key_length)
		};
		if (tls10) {
			rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
			rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
		}
		return rval;
	};
	/**
	* Creates a new initialized TLS connection state. A connection state has
	* a read mode and a write mode.
	*
	* compression state:
	*   The current state of the compression algorithm.
	*
	* cipher state:
	*   The current state of the encryption algorithm. This will consist of the
	*   scheduled key for that connection. For stream ciphers, this will also
	*   contain whatever state information is necessary to allow the stream to
	*   continue to encrypt or decrypt data.
	*
	* MAC key:
	*   The MAC key for the connection.
	*
	* sequence number:
	*   Each connection state contains a sequence number, which is maintained
	*   separately for read and write states. The sequence number MUST be set to
	*   zero whenever a connection state is made the active state. Sequence
	*   numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do
	*   not wrap. If a TLS implementation would need to wrap a sequence number,
	*   it must renegotiate instead. A sequence number is incremented after each
	*   record: specifically, the first record transmitted under a particular
	*   connection state MUST use sequence number 0.
	*
	* @param c the connection.
	*
	* @return the new initialized TLS connection state.
	*/
	tls.createConnectionState = function(c) {
		var client = c.entity === tls.ConnectionEnd.client;
		var createMode = function() {
			var mode = {
				sequenceNumber: [0, 0],
				macKey: null,
				macLength: 0,
				macFunction: null,
				cipherState: null,
				cipherFunction: function(record) {
					return true;
				},
				compressionState: null,
				compressFunction: function(record) {
					return true;
				},
				updateSequenceNumber: function() {
					if (mode.sequenceNumber[1] === 4294967295) {
						mode.sequenceNumber[1] = 0;
						++mode.sequenceNumber[0];
					} else ++mode.sequenceNumber[1];
				}
			};
			return mode;
		};
		var state = {
			read: createMode(),
			write: createMode()
		};
		state.read.update = function(c, record) {
			if (!state.read.cipherFunction(record, state.read)) c.error(c, {
				message: "Could not decrypt record or bad MAC.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.bad_record_mac
				}
			});
			else if (!state.read.compressFunction(c, record, state.read)) c.error(c, {
				message: "Could not decompress record.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.decompression_failure
				}
			});
			return !c.fail;
		};
		state.write.update = function(c, record) {
			if (!state.write.compressFunction(c, record, state.write)) c.error(c, {
				message: "Could not compress record.",
				send: false,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.internal_error
				}
			});
			else if (!state.write.cipherFunction(record, state.write)) c.error(c, {
				message: "Could not encrypt record.",
				send: false,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.internal_error
				}
			});
			return !c.fail;
		};
		if (c.session) {
			var sp = c.session.sp;
			c.session.cipherSuite.initSecurityParameters(sp);
			sp.keys = tls.generateKeys(c, sp);
			state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
			state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
			c.session.cipherSuite.initConnectionState(state, c, sp);
			switch (sp.compression_algorithm) {
				case tls.CompressionMethod.none: break;
				case tls.CompressionMethod.deflate:
					state.read.compressFunction = inflate;
					state.write.compressFunction = deflate;
					break;
				default: throw new Error("Unsupported compression algorithm.");
			}
		}
		return state;
	};
	/**
	* Creates a Random structure.
	*
	* struct {
	*   uint32 gmt_unix_time;
	*   opaque random_bytes[28];
	* } Random;
	*
	* gmt_unix_time:
	*   The current time and date in standard UNIX 32-bit format (seconds since
	*   the midnight starting Jan 1, 1970, UTC, ignoring leap seconds) according
	*   to the sender's internal clock. Clocks are not required to be set
	*   correctly by the basic TLS protocol; higher-level or application
	*   protocols may define additional requirements. Note that, for historical
	*   reasons, the data element is named using GMT, the predecessor of the
	*   current worldwide time base, UTC.
	* random_bytes:
	*   28 bytes generated by a secure random number generator.
	*
	* @return the Random structure as a byte array.
	*/
	tls.createRandom = function() {
		var d = /* @__PURE__ */ new Date();
		var utc = +d + d.getTimezoneOffset() * 6e4;
		var rval = forge.util.createBuffer();
		rval.putInt32(utc);
		rval.putBytes(forge.random.getBytes(28));
		return rval;
	};
	/**
	* Creates a TLS record with the given type and data.
	*
	* @param c the connection.
	* @param options:
	*   type: the record type.
	*   data: the plain text data in a byte buffer.
	*
	* @return the created record.
	*/
	tls.createRecord = function(c, options) {
		if (!options.data) return null;
		return {
			type: options.type,
			version: {
				major: c.version.major,
				minor: c.version.minor
			},
			length: options.data.length(),
			fragment: options.data
		};
	};
	/**
	* Creates a TLS alert record.
	*
	* @param c the connection.
	* @param alert:
	*   level: the TLS alert level.
	*   description: the TLS alert description.
	*
	* @return the created alert record.
	*/
	tls.createAlert = function(c, alert) {
		var b = forge.util.createBuffer();
		b.putByte(alert.level);
		b.putByte(alert.description);
		return tls.createRecord(c, {
			type: tls.ContentType.alert,
			data: b
		});
	};
	/**
	* Creates a ClientHello message.
	*
	* opaque SessionID<0..32>;
	* enum { null(0), deflate(1), (255) } CompressionMethod;
	* uint8 CipherSuite[2];
	*
	* struct {
	*   ProtocolVersion client_version;
	*   Random random;
	*   SessionID session_id;
	*   CipherSuite cipher_suites<2..2^16-2>;
	*   CompressionMethod compression_methods<1..2^8-1>;
	*   select(extensions_present) {
	*     case false:
	*       struct {};
	*     case true:
	*       Extension extensions<0..2^16-1>;
	*   };
	* } ClientHello;
	*
	* The extension format for extended client hellos and server hellos is:
	*
	* struct {
	*   ExtensionType extension_type;
	*   opaque extension_data<0..2^16-1>;
	* } Extension;
	*
	* Here:
	*
	* - "extension_type" identifies the particular extension type.
	* - "extension_data" contains information specific to the particular
	* extension type.
	*
	* The extension types defined in this document are:
	*
	* enum {
	*   server_name(0), max_fragment_length(1),
	*   client_certificate_url(2), trusted_ca_keys(3),
	*   truncated_hmac(4), status_request(5), (65535)
	* } ExtensionType;
	*
	* @param c the connection.
	*
	* @return the ClientHello byte buffer.
	*/
	tls.createClientHello = function(c) {
		c.session.clientHelloVersion = {
			major: c.version.major,
			minor: c.version.minor
		};
		var cipherSuites = forge.util.createBuffer();
		for (var i = 0; i < c.cipherSuites.length; ++i) {
			var cs = c.cipherSuites[i];
			cipherSuites.putByte(cs.id[0]);
			cipherSuites.putByte(cs.id[1]);
		}
		var cSuites = cipherSuites.length();
		var compressionMethods = forge.util.createBuffer();
		compressionMethods.putByte(tls.CompressionMethod.none);
		var cMethods = compressionMethods.length();
		var extensions = forge.util.createBuffer();
		if (c.virtualHost) {
			var ext = forge.util.createBuffer();
			ext.putByte(0);
			ext.putByte(0);
			var serverName = forge.util.createBuffer();
			serverName.putByte(0);
			writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));
			var snList = forge.util.createBuffer();
			writeVector(snList, 2, serverName);
			writeVector(ext, 2, snList);
			extensions.putBuffer(ext);
		}
		var extLength = extensions.length();
		if (extLength > 0) extLength += 2;
		var sessionId = c.session.id;
		var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + cSuites + 1 + cMethods + extLength;
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.client_hello);
		rval.putInt24(length);
		rval.putByte(c.version.major);
		rval.putByte(c.version.minor);
		rval.putBytes(c.session.sp.client_random);
		writeVector(rval, 1, forge.util.createBuffer(sessionId));
		writeVector(rval, 2, cipherSuites);
		writeVector(rval, 1, compressionMethods);
		if (extLength > 0) writeVector(rval, 2, extensions);
		return rval;
	};
	/**
	* Creates a ServerHello message.
	*
	* @param c the connection.
	*
	* @return the ServerHello byte buffer.
	*/
	tls.createServerHello = function(c) {
		var sessionId = c.session.id;
		var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + 1;
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.server_hello);
		rval.putInt24(length);
		rval.putByte(c.version.major);
		rval.putByte(c.version.minor);
		rval.putBytes(c.session.sp.server_random);
		writeVector(rval, 1, forge.util.createBuffer(sessionId));
		rval.putByte(c.session.cipherSuite.id[0]);
		rval.putByte(c.session.cipherSuite.id[1]);
		rval.putByte(c.session.compressionMethod);
		return rval;
	};
	/**
	* Creates a Certificate message.
	*
	* When this message will be sent:
	*   This is the first message the client can send after receiving a server
	*   hello done message and the first message the server can send after
	*   sending a ServerHello. This client message is only sent if the server
	*   requests a certificate. If no suitable certificate is available, the
	*   client should send a certificate message containing no certificates. If
	*   client authentication is required by the server for the handshake to
	*   continue, it may respond with a fatal handshake failure alert.
	*
	* opaque ASN.1Cert<1..2^24-1>;
	*
	* struct {
	*   ASN.1Cert certificate_list<0..2^24-1>;
	* } Certificate;
	*
	* @param c the connection.
	*
	* @return the Certificate byte buffer.
	*/
	tls.createCertificate = function(c) {
		var client = c.entity === tls.ConnectionEnd.client;
		var cert = null;
		if (c.getCertificate) {
			var hint;
			if (client) hint = c.session.certificateRequest;
			else hint = c.session.extensions.server_name.serverNameList;
			cert = c.getCertificate(c, hint);
		}
		var certList = forge.util.createBuffer();
		if (cert !== null) try {
			if (!forge.util.isArray(cert)) cert = [cert];
			var asn1 = null;
			for (var i = 0; i < cert.length; ++i) {
				var msg = forge.pem.decode(cert[i])[0];
				if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
					var error = /* @__PURE__ */ new Error("Could not convert certificate from PEM; PEM header type is not \"CERTIFICATE\", \"X509 CERTIFICATE\", or \"TRUSTED CERTIFICATE\".");
					error.headerType = msg.type;
					throw error;
				}
				if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
				var der = forge.util.createBuffer(msg.body);
				if (asn1 === null) asn1 = forge.asn1.fromDer(der.bytes(), false);
				var certBuffer = forge.util.createBuffer();
				writeVector(certBuffer, 3, der);
				certList.putBuffer(certBuffer);
			}
			cert = forge.pki.certificateFromAsn1(asn1);
			if (client) c.session.clientCertificate = cert;
			else c.session.serverCertificate = cert;
		} catch (ex) {
			return c.error(c, {
				message: "Could not send certificate list.",
				cause: ex,
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.bad_certificate
				}
			});
		}
		var length = 3 + certList.length();
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.certificate);
		rval.putInt24(length);
		writeVector(rval, 3, certList);
		return rval;
	};
	/**
	* Creates a ClientKeyExchange message.
	*
	* When this message will be sent:
	*   This message is always sent by the client. It will immediately follow the
	*   client certificate message, if it is sent. Otherwise it will be the first
	*   message sent by the client after it receives the server hello done
	*   message.
	*
	* Meaning of this message:
	*   With this message, the premaster secret is set, either though direct
	*   transmission of the RSA-encrypted secret, or by the transmission of
	*   Diffie-Hellman parameters which will allow each side to agree upon the
	*   same premaster secret. When the key exchange method is DH_RSA or DH_DSS,
	*   client certification has been requested, and the client was able to
	*   respond with a certificate which contained a Diffie-Hellman public key
	*   whose parameters (group and generator) matched those specified by the
	*   server in its certificate, this message will not contain any data.
	*
	* Meaning of this message:
	*   If RSA is being used for key agreement and authentication, the client
	*   generates a 48-byte premaster secret, encrypts it using the public key
	*   from the server's certificate or the temporary RSA key provided in a
	*   server key exchange message, and sends the result in an encrypted
	*   premaster secret message. This structure is a variant of the client
	*   key exchange message, not a message in itself.
	*
	* struct {
	*   select(KeyExchangeAlgorithm) {
	*     case rsa: EncryptedPreMasterSecret;
	*     case diffie_hellman: ClientDiffieHellmanPublic;
	*   } exchange_keys;
	* } ClientKeyExchange;
	*
	* struct {
	*   ProtocolVersion client_version;
	*   opaque random[46];
	* } PreMasterSecret;
	*
	* struct {
	*   public-key-encrypted PreMasterSecret pre_master_secret;
	* } EncryptedPreMasterSecret;
	*
	* A public-key-encrypted element is encoded as a vector <0..2^16-1>.
	*
	* @param c the connection.
	*
	* @return the ClientKeyExchange byte buffer.
	*/
	tls.createClientKeyExchange = function(c) {
		var b = forge.util.createBuffer();
		b.putByte(c.session.clientHelloVersion.major);
		b.putByte(c.session.clientHelloVersion.minor);
		b.putBytes(forge.random.getBytes(46));
		var sp = c.session.sp;
		sp.pre_master_secret = b.getBytes();
		b = c.session.serverCertificate.publicKey.encrypt(sp.pre_master_secret);
		var length = b.length + 2;
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.client_key_exchange);
		rval.putInt24(length);
		rval.putInt16(b.length);
		rval.putBytes(b);
		return rval;
	};
	/**
	* Creates a ServerKeyExchange message.
	*
	* @param c the connection.
	*
	* @return the ServerKeyExchange byte buffer.
	*/
	tls.createServerKeyExchange = function(c) {
		var length = 0;
		var rval = forge.util.createBuffer();
		if (length > 0) {
			rval.putByte(tls.HandshakeType.server_key_exchange);
			rval.putInt24(length);
		}
		return rval;
	};
	/**
	* Gets the signed data used to verify a client-side certificate. See
	* tls.createCertificateVerify() for details.
	*
	* @param c the connection.
	* @param callback the callback to call once the signed data is ready.
	*/
	tls.getClientSignature = function(c, callback) {
		var b = forge.util.createBuffer();
		b.putBuffer(c.session.md5.digest());
		b.putBuffer(c.session.sha1.digest());
		b = b.getBytes();
		c.getSignature = c.getSignature || function(c, b, callback) {
			var privateKey = null;
			if (c.getPrivateKey) try {
				privateKey = c.getPrivateKey(c, c.session.clientCertificate);
				privateKey = forge.pki.privateKeyFromPem(privateKey);
			} catch (ex) {
				c.error(c, {
					message: "Could not get private key.",
					cause: ex,
					send: true,
					alert: {
						level: tls.Alert.Level.fatal,
						description: tls.Alert.Description.internal_error
					}
				});
			}
			if (privateKey === null) c.error(c, {
				message: "No private key set.",
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: tls.Alert.Description.internal_error
				}
			});
			else b = privateKey.sign(b, null);
			callback(c, b);
		};
		c.getSignature(c, b, callback);
	};
	/**
	* Creates a CertificateVerify message.
	*
	* Meaning of this message:
	*   This structure conveys the client's Diffie-Hellman public value
	*   (Yc) if it was not already included in the client's certificate.
	*   The encoding used for Yc is determined by the enumerated
	*   PublicValueEncoding. This structure is a variant of the client
	*   key exchange message, not a message in itself.
	*
	* When this message will be sent:
	*   This message is used to provide explicit verification of a client
	*   certificate. This message is only sent following a client
	*   certificate that has signing capability (i.e. all certificates
	*   except those containing fixed Diffie-Hellman parameters). When
	*   sent, it will immediately follow the client key exchange message.
	*
	* struct {
	*   Signature signature;
	* } CertificateVerify;
	*
	* CertificateVerify.signature.md5_hash
	*   MD5(handshake_messages);
	*
	* Certificate.signature.sha_hash
	*   SHA(handshake_messages);
	*
	* Here handshake_messages refers to all handshake messages sent or
	* received starting at client hello up to but not including this
	* message, including the type and length fields of the handshake
	* messages.
	*
	* select(SignatureAlgorithm) {
	*   case anonymous: struct { };
	*   case rsa:
	*     digitally-signed struct {
	*       opaque md5_hash[16];
	*       opaque sha_hash[20];
	*     };
	*   case dsa:
	*     digitally-signed struct {
	*       opaque sha_hash[20];
	*     };
	* } Signature;
	*
	* In digital signing, one-way hash functions are used as input for a
	* signing algorithm. A digitally-signed element is encoded as an opaque
	* vector <0..2^16-1>, where the length is specified by the signing
	* algorithm and key.
	*
	* In RSA signing, a 36-byte structure of two hashes (one SHA and one
	* MD5) is signed (encrypted with the private key). It is encoded with
	* PKCS #1 block type 0 or type 1 as described in [PKCS1].
	*
	* In DSS, the 20 bytes of the SHA hash are run directly through the
	* Digital Signing Algorithm with no additional hashing.
	*
	* @param c the connection.
	* @param signature the signature to include in the message.
	*
	* @return the CertificateVerify byte buffer.
	*/
	tls.createCertificateVerify = function(c, signature) {
		var length = signature.length + 2;
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.certificate_verify);
		rval.putInt24(length);
		rval.putInt16(signature.length);
		rval.putBytes(signature);
		return rval;
	};
	/**
	* Creates a CertificateRequest message.
	*
	* @param c the connection.
	*
	* @return the CertificateRequest byte buffer.
	*/
	tls.createCertificateRequest = function(c) {
		var certTypes = forge.util.createBuffer();
		certTypes.putByte(1);
		var cAs = forge.util.createBuffer();
		for (var key in c.caStore.certs) {
			var cert = c.caStore.certs[key];
			var dn = forge.pki.distinguishedNameToAsn1(cert.subject);
			var byteBuffer = forge.asn1.toDer(dn);
			cAs.putInt16(byteBuffer.length());
			cAs.putBuffer(byteBuffer);
		}
		var length = 1 + certTypes.length() + 2 + cAs.length();
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.certificate_request);
		rval.putInt24(length);
		writeVector(rval, 1, certTypes);
		writeVector(rval, 2, cAs);
		return rval;
	};
	/**
	* Creates a ServerHelloDone message.
	*
	* @param c the connection.
	*
	* @return the ServerHelloDone byte buffer.
	*/
	tls.createServerHelloDone = function(c) {
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.server_hello_done);
		rval.putInt24(0);
		return rval;
	};
	/**
	* Creates a ChangeCipherSpec message.
	*
	* The change cipher spec protocol exists to signal transitions in
	* ciphering strategies. The protocol consists of a single message,
	* which is encrypted and compressed under the current (not the pending)
	* connection state. The message consists of a single byte of value 1.
	*
	* struct {
	*   enum { change_cipher_spec(1), (255) } type;
	* } ChangeCipherSpec;
	*
	* @return the ChangeCipherSpec byte buffer.
	*/
	tls.createChangeCipherSpec = function() {
		var rval = forge.util.createBuffer();
		rval.putByte(1);
		return rval;
	};
	/**
	* Creates a Finished message.
	*
	* struct {
	*   opaque verify_data[12];
	* } Finished;
	*
	* verify_data
	*   PRF(master_secret, finished_label, MD5(handshake_messages) +
	*   SHA-1(handshake_messages)) [0..11];
	*
	* finished_label
	*   For Finished messages sent by the client, the string "client
	*   finished". For Finished messages sent by the server, the
	*   string "server finished".
	*
	* handshake_messages
	*   All of the data from all handshake messages up to but not
	*   including this message. This is only data visible at the
	*   handshake layer and does not include record layer headers.
	*   This is the concatenation of all the Handshake structures as
	*   defined in 7.4 exchanged thus far.
	*
	* @param c the connection.
	*
	* @return the Finished byte buffer.
	*/
	tls.createFinished = function(c) {
		var b = forge.util.createBuffer();
		b.putBuffer(c.session.md5.digest());
		b.putBuffer(c.session.sha1.digest());
		var client = c.entity === tls.ConnectionEnd.client;
		var sp = c.session.sp;
		var vdl = 12;
		var prf = prf_TLS1;
		var label = client ? "client finished" : "server finished";
		b = prf(sp.master_secret, label, b.getBytes(), vdl);
		var rval = forge.util.createBuffer();
		rval.putByte(tls.HandshakeType.finished);
		rval.putInt24(b.length());
		rval.putBuffer(b);
		return rval;
	};
	/**
	* Creates a HeartbeatMessage (See RFC 6520).
	*
	* struct {
	*   HeartbeatMessageType type;
	*   uint16 payload_length;
	*   opaque payload[HeartbeatMessage.payload_length];
	*   opaque padding[padding_length];
	* } HeartbeatMessage;
	*
	* The total length of a HeartbeatMessage MUST NOT exceed 2^14 or
	* max_fragment_length when negotiated as defined in [RFC6066].
	*
	* type: The message type, either heartbeat_request or heartbeat_response.
	*
	* payload_length: The length of the payload.
	*
	* payload: The payload consists of arbitrary content.
	*
	* padding: The padding is random content that MUST be ignored by the
	*   receiver. The length of a HeartbeatMessage is TLSPlaintext.length
	*   for TLS and DTLSPlaintext.length for DTLS. Furthermore, the
	*   length of the type field is 1 byte, and the length of the
	*   payload_length is 2. Therefore, the padding_length is
	*   TLSPlaintext.length - payload_length - 3 for TLS and
	*   DTLSPlaintext.length - payload_length - 3 for DTLS. The
	*   padding_length MUST be at least 16.
	*
	* The sender of a HeartbeatMessage MUST use a random padding of at
	* least 16 bytes. The padding of a received HeartbeatMessage message
	* MUST be ignored.
	*
	* If the payload_length of a received HeartbeatMessage is too large,
	* the received HeartbeatMessage MUST be discarded silently.
	*
	* @param c the connection.
	* @param type the tls.HeartbeatMessageType.
	* @param payload the heartbeat data to send as the payload.
	* @param [payloadLength] the payload length to use, defaults to the
	*          actual payload length.
	*
	* @return the HeartbeatRequest byte buffer.
	*/
	tls.createHeartbeat = function(type, payload, payloadLength) {
		if (typeof payloadLength === "undefined") payloadLength = payload.length;
		var rval = forge.util.createBuffer();
		rval.putByte(type);
		rval.putInt16(payloadLength);
		rval.putBytes(payload);
		var plaintextLength = rval.length();
		var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
		rval.putBytes(forge.random.getBytes(paddingLength));
		return rval;
	};
	/**
	* Fragments, compresses, encrypts, and queues a record for delivery.
	*
	* @param c the connection.
	* @param record the record to queue.
	*/
	tls.queue = function(c, record) {
		if (!record) return;
		if (record.fragment.length() === 0) {
			if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) return;
		}
		if (record.type === tls.ContentType.handshake) {
			var bytes = record.fragment.bytes();
			c.session.md5.update(bytes);
			c.session.sha1.update(bytes);
			bytes = null;
		}
		var records;
		if (record.fragment.length() <= tls.MaxFragment) records = [record];
		else {
			records = [];
			var data = record.fragment.bytes();
			while (data.length > tls.MaxFragment) {
				records.push(tls.createRecord(c, {
					type: record.type,
					data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
				}));
				data = data.slice(tls.MaxFragment);
			}
			if (data.length > 0) records.push(tls.createRecord(c, {
				type: record.type,
				data: forge.util.createBuffer(data)
			}));
		}
		for (var i = 0; i < records.length && !c.fail; ++i) {
			var rec = records[i];
			if (c.state.current.write.update(c, rec)) c.records.push(rec);
		}
	};
	/**
	* Flushes all queued records to the output buffer and calls the
	* tlsDataReady() handler on the given connection.
	*
	* @param c the connection.
	*
	* @return true on success, false on failure.
	*/
	tls.flush = function(c) {
		for (var i = 0; i < c.records.length; ++i) {
			var record = c.records[i];
			c.tlsData.putByte(record.type);
			c.tlsData.putByte(record.version.major);
			c.tlsData.putByte(record.version.minor);
			c.tlsData.putInt16(record.fragment.length());
			c.tlsData.putBuffer(c.records[i].fragment);
		}
		c.records = [];
		return c.tlsDataReady(c);
	};
	/**
	* Maps a pki.certificateError to a tls.Alert.Description.
	*
	* @param error the error to map.
	*
	* @return the alert description.
	*/
	var _certErrorToAlertDesc = function(error) {
		switch (error) {
			case true: return true;
			case forge.pki.certificateError.bad_certificate: return tls.Alert.Description.bad_certificate;
			case forge.pki.certificateError.unsupported_certificate: return tls.Alert.Description.unsupported_certificate;
			case forge.pki.certificateError.certificate_revoked: return tls.Alert.Description.certificate_revoked;
			case forge.pki.certificateError.certificate_expired: return tls.Alert.Description.certificate_expired;
			case forge.pki.certificateError.certificate_unknown: return tls.Alert.Description.certificate_unknown;
			case forge.pki.certificateError.unknown_ca: return tls.Alert.Description.unknown_ca;
			default: return tls.Alert.Description.bad_certificate;
		}
	};
	/**
	* Maps a tls.Alert.Description to a pki.certificateError.
	*
	* @param desc the alert description.
	*
	* @return the certificate error.
	*/
	var _alertDescToCertError = function(desc) {
		switch (desc) {
			case true: return true;
			case tls.Alert.Description.bad_certificate: return forge.pki.certificateError.bad_certificate;
			case tls.Alert.Description.unsupported_certificate: return forge.pki.certificateError.unsupported_certificate;
			case tls.Alert.Description.certificate_revoked: return forge.pki.certificateError.certificate_revoked;
			case tls.Alert.Description.certificate_expired: return forge.pki.certificateError.certificate_expired;
			case tls.Alert.Description.certificate_unknown: return forge.pki.certificateError.certificate_unknown;
			case tls.Alert.Description.unknown_ca: return forge.pki.certificateError.unknown_ca;
			default: return forge.pki.certificateError.bad_certificate;
		}
	};
	/**
	* Verifies a certificate chain against the given connection's
	* Certificate Authority store.
	*
	* @param c the TLS connection.
	* @param chain the certificate chain to verify, with the root or highest
	*          authority at the end.
	*
	* @return true if successful, false if not.
	*/
	tls.verifyCertificateChain = function(c, chain) {
		try {
			var options = {};
			for (var key in c.verifyOptions) options[key] = c.verifyOptions[key];
			options.verify = function(vfd, depth, chain) {
				_certErrorToAlertDesc(vfd);
				var ret = c.verify(c, vfd, depth, chain);
				if (ret !== true) {
					if (typeof ret === "object" && !forge.util.isArray(ret)) {
						var error = /* @__PURE__ */ new Error("The application rejected the certificate.");
						error.send = true;
						error.alert = {
							level: tls.Alert.Level.fatal,
							description: tls.Alert.Description.bad_certificate
						};
						if (ret.message) error.message = ret.message;
						if (ret.alert) error.alert.description = ret.alert;
						throw error;
					}
					if (ret !== vfd) ret = _alertDescToCertError(ret);
				}
				return ret;
			};
			forge.pki.verifyCertificateChain(c.caStore, chain, options);
		} catch (ex) {
			var err = ex;
			if (typeof err !== "object" || forge.util.isArray(err)) err = {
				send: true,
				alert: {
					level: tls.Alert.Level.fatal,
					description: _certErrorToAlertDesc(ex)
				}
			};
			if (!("send" in err)) err.send = true;
			if (!("alert" in err)) err.alert = {
				level: tls.Alert.Level.fatal,
				description: _certErrorToAlertDesc(err.error)
			};
			c.error(c, err);
		}
		return !c.fail;
	};
	/**
	* Creates a new TLS session cache.
	*
	* @param cache optional map of session ID to cached session.
	* @param capacity the maximum size for the cache (default: 100).
	*
	* @return the new TLS session cache.
	*/
	tls.createSessionCache = function(cache, capacity) {
		var rval = null;
		if (cache && cache.getSession && cache.setSession && cache.order) rval = cache;
		else {
			rval = {};
			rval.cache = cache || {};
			rval.capacity = Math.max(capacity || 100, 1);
			rval.order = [];
			for (var key in cache) if (rval.order.length <= capacity) rval.order.push(key);
			else delete cache[key];
			rval.getSession = function(sessionId) {
				var session = null;
				var key = null;
				if (sessionId) key = forge.util.bytesToHex(sessionId);
				else if (rval.order.length > 0) key = rval.order[0];
				if (key !== null && key in rval.cache) {
					session = rval.cache[key];
					delete rval.cache[key];
					for (var i in rval.order) if (rval.order[i] === key) {
						rval.order.splice(i, 1);
						break;
					}
				}
				return session;
			};
			rval.setSession = function(sessionId, session) {
				if (rval.order.length === rval.capacity) {
					var key = rval.order.shift();
					delete rval.cache[key];
				}
				var key = forge.util.bytesToHex(sessionId);
				rval.order.push(key);
				rval.cache[key] = session;
			};
		}
		return rval;
	};
	/**
	* Creates a new TLS connection.
	*
	* See public createConnection() docs for more details.
	*
	* @param options the options for this connection.
	*
	* @return the new TLS connection.
	*/
	tls.createConnection = function(options) {
		var caStore = null;
		if (options.caStore) if (forge.util.isArray(options.caStore)) caStore = forge.pki.createCaStore(options.caStore);
		else caStore = options.caStore;
		else caStore = forge.pki.createCaStore();
		var cipherSuites = options.cipherSuites || null;
		if (cipherSuites === null) {
			cipherSuites = [];
			for (var key in tls.CipherSuites) cipherSuites.push(tls.CipherSuites[key]);
		}
		var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
		var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
		var c = {
			version: {
				major: tls.Version.major,
				minor: tls.Version.minor
			},
			entity,
			sessionId: options.sessionId,
			caStore,
			sessionCache,
			cipherSuites,
			connected: options.connected,
			virtualHost: options.virtualHost || null,
			verifyClient: options.verifyClient || false,
			verify: options.verify || function(cn, vfd, dpth, cts) {
				return vfd;
			},
			verifyOptions: options.verifyOptions || {},
			getCertificate: options.getCertificate || null,
			getPrivateKey: options.getPrivateKey || null,
			getSignature: options.getSignature || null,
			input: forge.util.createBuffer(),
			tlsData: forge.util.createBuffer(),
			data: forge.util.createBuffer(),
			tlsDataReady: options.tlsDataReady,
			dataReady: options.dataReady,
			heartbeatReceived: options.heartbeatReceived,
			closed: options.closed,
			error: function(c, ex) {
				ex.origin = ex.origin || (c.entity === tls.ConnectionEnd.client ? "client" : "server");
				if (ex.send) {
					tls.queue(c, tls.createAlert(c, ex.alert));
					tls.flush(c);
				}
				var fatal = ex.fatal !== false;
				if (fatal) c.fail = true;
				options.error(c, ex);
				if (fatal) c.close(false);
			},
			deflate: options.deflate || null,
			inflate: options.inflate || null
		};
		/**
		* Resets a closed TLS connection for reuse. Called in c.close().
		*
		* @param clearFail true to clear the fail flag (default: true).
		*/
		c.reset = function(clearFail) {
			c.version = {
				major: tls.Version.major,
				minor: tls.Version.minor
			};
			c.record = null;
			c.session = null;
			c.peerCertificate = null;
			c.state = {
				pending: null,
				current: null
			};
			c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
			c.fragmented = null;
			c.records = [];
			c.open = false;
			c.handshakes = 0;
			c.handshaking = false;
			c.isConnected = false;
			c.fail = !(clearFail || typeof clearFail === "undefined");
			c.input.clear();
			c.tlsData.clear();
			c.data.clear();
			c.state.current = tls.createConnectionState(c);
		};
		c.reset();
		/**
		* Updates the current TLS engine state based on the given record.
		*
		* @param c the TLS connection.
		* @param record the TLS record to act on.
		*/
		var _update = function(c, record) {
			var aligned = record.type - tls.ContentType.change_cipher_spec;
			var handlers = ctTable[c.entity][c.expect];
			if (aligned in handlers) handlers[aligned](c, record);
			else tls.handleUnexpected(c, record);
		};
		/**
		* Reads the record header and initializes the next record on the given
		* connection.
		*
		* @param c the TLS connection with the next record.
		*
		* @return 0 if the input data could be processed, otherwise the
		*         number of bytes required for data to be processed.
		*/
		var _readRecordHeader = function(c) {
			var rval = 0;
			var b = c.input;
			var len = b.length();
			if (len < 5) rval = 5 - len;
			else {
				c.record = {
					type: b.getByte(),
					version: {
						major: b.getByte(),
						minor: b.getByte()
					},
					length: b.getInt16(),
					fragment: forge.util.createBuffer(),
					ready: false
				};
				var compatibleVersion = c.record.version.major === c.version.major;
				if (compatibleVersion && c.session && c.session.version) compatibleVersion = c.record.version.minor === c.version.minor;
				if (!compatibleVersion) c.error(c, {
					message: "Incompatible TLS version.",
					send: true,
					alert: {
						level: tls.Alert.Level.fatal,
						description: tls.Alert.Description.protocol_version
					}
				});
			}
			return rval;
		};
		/**
		* Reads the next record's contents and appends its message to any
		* previously fragmented message.
		*
		* @param c the TLS connection with the next record.
		*
		* @return 0 if the input data could be processed, otherwise the
		*         number of bytes required for data to be processed.
		*/
		var _readRecord = function(c) {
			var rval = 0;
			var b = c.input;
			var len = b.length();
			if (len < c.record.length) rval = c.record.length - len;
			else {
				c.record.fragment.putBytes(b.getBytes(c.record.length));
				b.compact();
				if (c.state.current.read.update(c, c.record)) {
					if (c.fragmented !== null) if (c.fragmented.type === c.record.type) {
						c.fragmented.fragment.putBuffer(c.record.fragment);
						c.record = c.fragmented;
					} else c.error(c, {
						message: "Invalid fragmented record.",
						send: true,
						alert: {
							level: tls.Alert.Level.fatal,
							description: tls.Alert.Description.unexpected_message
						}
					});
					c.record.ready = true;
				}
			}
			return rval;
		};
		/**
		* Performs a handshake using the TLS Handshake Protocol, as a client.
		*
		* This method should only be called if the connection is in client mode.
		*
		* @param sessionId the session ID to use, null to start a new one.
		*/
		c.handshake = function(sessionId) {
			if (c.entity !== tls.ConnectionEnd.client) c.error(c, {
				message: "Cannot initiate handshake as a server.",
				fatal: false
			});
			else if (c.handshaking) c.error(c, {
				message: "Handshake already in progress.",
				fatal: false
			});
			else {
				if (c.fail && !c.open && c.handshakes === 0) c.fail = false;
				c.handshaking = true;
				sessionId = sessionId || "";
				var session = null;
				if (sessionId.length > 0) {
					if (c.sessionCache) session = c.sessionCache.getSession(sessionId);
					if (session === null) sessionId = "";
				}
				if (sessionId.length === 0 && c.sessionCache) {
					session = c.sessionCache.getSession();
					if (session !== null) sessionId = session.id;
				}
				c.session = {
					id: sessionId,
					version: null,
					cipherSuite: null,
					compressionMethod: null,
					serverCertificate: null,
					certificateRequest: null,
					clientCertificate: null,
					sp: {},
					md5: forge.md.md5.create(),
					sha1: forge.md.sha1.create()
				};
				if (session) {
					c.version = session.version;
					c.session.sp = session.sp;
				}
				c.session.sp.client_random = tls.createRandom().getBytes();
				c.open = true;
				tls.queue(c, tls.createRecord(c, {
					type: tls.ContentType.handshake,
					data: tls.createClientHello(c)
				}));
				tls.flush(c);
			}
		};
		/**
		* Called when TLS protocol data has been received from somewhere and should
		* be processed by the TLS engine.
		*
		* @param data the TLS protocol data, as a string, to process.
		*
		* @return 0 if the data could be processed, otherwise the number of bytes
		*         required for data to be processed.
		*/
		c.process = function(data) {
			var rval = 0;
			if (data) c.input.putBytes(data);
			if (!c.fail) {
				if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) c.record = null;
				if (c.record === null) rval = _readRecordHeader(c);
				if (!c.fail && c.record !== null && !c.record.ready) rval = _readRecord(c);
				if (!c.fail && c.record !== null && c.record.ready) _update(c, c.record);
			}
			return rval;
		};
		/**
		* Requests that application data be packaged into a TLS record. The
		* tlsDataReady handler will be called when the TLS record(s) have been
		* prepared.
		*
		* @param data the application data, as a raw 'binary' encoded string, to
		*          be sent; to send utf-16/utf-8 string data, use the return value
		*          of util.encodeUtf8(str).
		*
		* @return true on success, false on failure.
		*/
		c.prepare = function(data) {
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.application_data,
				data: forge.util.createBuffer(data)
			}));
			return tls.flush(c);
		};
		/**
		* Requests that a heartbeat request be packaged into a TLS record for
		* transmission. The tlsDataReady handler will be called when TLS record(s)
		* have been prepared.
		*
		* When a heartbeat response has been received, the heartbeatReceived
		* handler will be called with the matching payload. This handler can
		* be used to clear a retransmission timer, etc.
		*
		* @param payload the heartbeat data to send as the payload in the message.
		* @param [payloadLength] the payload length to use, defaults to the
		*          actual payload length.
		*
		* @return true on success, false on failure.
		*/
		c.prepareHeartbeatRequest = function(payload, payloadLength) {
			if (payload instanceof forge.util.ByteBuffer) payload = payload.bytes();
			if (typeof payloadLength === "undefined") payloadLength = payload.length;
			c.expectedHeartbeatPayload = payload;
			tls.queue(c, tls.createRecord(c, {
				type: tls.ContentType.heartbeat,
				data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)
			}));
			return tls.flush(c);
		};
		/**
		* Closes the connection (sends a close_notify alert).
		*
		* @param clearFail true to clear the fail flag (default: true).
		*/
		c.close = function(clearFail) {
			if (!c.fail && c.sessionCache && c.session) {
				var session = {
					id: c.session.id,
					version: c.session.version,
					sp: c.session.sp
				};
				session.sp.keys = null;
				c.sessionCache.setSession(session.id, session);
			}
			if (c.open) {
				c.open = false;
				c.input.clear();
				if (c.isConnected || c.handshaking) {
					c.isConnected = c.handshaking = false;
					tls.queue(c, tls.createAlert(c, {
						level: tls.Alert.Level.warning,
						description: tls.Alert.Description.close_notify
					}));
					tls.flush(c);
				}
				c.closed(c);
			}
			c.reset(clearFail);
		};
		return c;
	};
	module.exports = forge.tls = forge.tls || {};
	for (var key in tls) if (typeof tls[key] !== "function") forge.tls[key] = tls[key];
	forge.tls.prf_tls1 = prf_TLS1;
	forge.tls.hmac_sha1 = hmac_sha1;
	forge.tls.createSessionCache = tls.createSessionCache;
	/**
	* Creates a new TLS connection. This does not make any assumptions about the
	* transport layer that TLS is working on top of, ie: it does not assume there
	* is a TCP/IP connection or establish one. A TLS connection is totally
	* abstracted away from the layer is runs on top of, it merely establishes a
	* secure channel between a client" and a "server".
	*
	* A TLS connection contains 4 connection states: pending read and write, and
	* current read and write.
	*
	* At initialization, the current read and write states will be null. Only once
	* the security parameters have been set and the keys have been generated can
	* the pending states be converted into current states. Current states will be
	* updated for each record processed.
	*
	* A custom certificate verify callback may be provided to check information
	* like the common name on the server's certificate. It will be called for
	* every certificate in the chain. It has the following signature:
	*
	* variable func(c, certs, index, preVerify)
	* Where:
	* c         The TLS connection
	* verified  Set to true if certificate was verified, otherwise the alert
	*           tls.Alert.Description for why the certificate failed.
	* depth     The current index in the chain, where 0 is the server's cert.
	* certs     The certificate chain, *NOTE* if the server was anonymous then
	*           the chain will be empty.
	*
	* The function returns true on success and on failure either the appropriate
	* tls.Alert.Description or an object with 'alert' set to the appropriate
	* tls.Alert.Description and 'message' set to a custom error message. If true
	* is not returned then the connection will abort using, in order of
	* availability, first the returned alert description, second the preVerify
	* alert description, and lastly the default 'bad_certificate'.
	*
	* There are three callbacks that can be used to make use of client-side
	* certificates where each takes the TLS connection as the first parameter:
	*
	* getCertificate(conn, hint)
	*   The second parameter is a hint as to which certificate should be
	*   returned. If the connection entity is a client, then the hint will be
	*   the CertificateRequest message from the server that is part of the
	*   TLS protocol. If the connection entity is a server, then it will be
	*   the servername list provided via an SNI extension the ClientHello, if
	*   one was provided (empty array if not). The hint can be examined to
	*   determine which certificate to use (advanced). Most implementations
	*   will just return a certificate. The return value must be a
	*   PEM-formatted certificate or an array of PEM-formatted certificates
	*   that constitute a certificate chain, with the first in the array/chain
	*   being the client's certificate.
	* getPrivateKey(conn, certificate)
	*   The second parameter is an forge.pki X.509 certificate object that
	*   is associated with the requested private key. The return value must
	*   be a PEM-formatted private key.
	* getSignature(conn, bytes, callback)
	*   This callback can be used instead of getPrivateKey if the private key
	*   is not directly accessible in javascript or should not be. For
	*   instance, a secure external web service could provide the signature
	*   in exchange for appropriate credentials. The second parameter is a
	*   string of bytes to be signed that are part of the TLS protocol. These
	*   bytes are used to verify that the private key for the previously
	*   provided client-side certificate is accessible to the client. The
	*   callback is a function that takes 2 parameters, the TLS connection
	*   and the RSA encrypted (signed) bytes as a string. This callback must
	*   be called once the signature is ready.
	*
	* @param options the options for this connection:
	*   server: true if the connection is server-side, false for client.
	*   sessionId: a session ID to reuse, null for a new connection.
	*   caStore: an array of certificates to trust.
	*   sessionCache: a session cache to use.
	*   cipherSuites: an optional array of cipher suites to use,
	*     see tls.CipherSuites.
	*   connected: function(conn) called when the first handshake completes.
	*   virtualHost: the virtual server name to use in a TLS SNI extension.
	*   verifyClient: true to require a client certificate in server mode,
	*     'optional' to request one, false not to (default: false).
	*   verify: a handler used to custom verify certificates in the chain.
	*   verifyOptions: an object with options for the certificate chain validation.
	*     See documentation of pki.verifyCertificateChain for possible options.
	*     verifyOptions.verify is ignored. If you wish to specify a verify handler
	*     use the verify key.
	*   getCertificate: an optional callback used to get a certificate or
	*     a chain of certificates (as an array).
	*   getPrivateKey: an optional callback used to get a private key.
	*   getSignature: an optional callback used to get a signature.
	*   tlsDataReady: function(conn) called when TLS protocol data has been
	*     prepared and is ready to be used (typically sent over a socket
	*     connection to its destination), read from conn.tlsData buffer.
	*   dataReady: function(conn) called when application data has
	*     been parsed from a TLS record and should be consumed by the
	*     application, read from conn.data buffer.
	*   closed: function(conn) called when the connection has been closed.
	*   error: function(conn, error) called when there was an error.
	*   deflate: function(inBytes) if provided, will deflate TLS records using
	*     the deflate algorithm if the server supports it.
	*   inflate: function(inBytes) if provided, will inflate TLS records using
	*     the deflate algorithm if the server supports it.
	*
	* @return the new TLS connection.
	*/
	forge.tls.createConnection = tls.createConnection;
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* A Javascript implementation of AES Cipher Suites for TLS.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2009-2015 Digital Bazaar, Inc.
	*
	*/
	var forge = require_forge();
	require_aes();
	require_tls();
	var tls = module.exports = forge.tls;
	/**
	* Supported cipher suites.
	*/
	tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
		id: [0, 47],
		name: "TLS_RSA_WITH_AES_128_CBC_SHA",
		initSecurityParameters: function(sp) {
			sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
			sp.cipher_type = tls.CipherType.block;
			sp.enc_key_length = 16;
			sp.block_length = 16;
			sp.fixed_iv_length = 16;
			sp.record_iv_length = 16;
			sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
			sp.mac_length = 20;
			sp.mac_key_length = 20;
		},
		initConnectionState
	};
	tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
		id: [0, 53],
		name: "TLS_RSA_WITH_AES_256_CBC_SHA",
		initSecurityParameters: function(sp) {
			sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
			sp.cipher_type = tls.CipherType.block;
			sp.enc_key_length = 32;
			sp.block_length = 16;
			sp.fixed_iv_length = 16;
			sp.record_iv_length = 16;
			sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
			sp.mac_length = 20;
			sp.mac_key_length = 20;
		},
		initConnectionState
	};
	function initConnectionState(state, c, sp) {
		var client = c.entity === forge.tls.ConnectionEnd.client;
		state.read.cipherState = {
			init: false,
			cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
			iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
		};
		state.write.cipherState = {
			init: false,
			cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
			iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
		};
		state.read.cipherFunction = decrypt_aes_cbc_sha1;
		state.write.cipherFunction = encrypt_aes_cbc_sha1;
		state.read.macLength = state.write.macLength = sp.mac_length;
		state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
	}
	/**
	* Encrypts the TLSCompressed record into a TLSCipherText record using AES
	* in CBC mode.
	*
	* @param record the TLSCompressed record to encrypt.
	* @param s the ConnectionState to use.
	*
	* @return true on success, false on failure.
	*/
	function encrypt_aes_cbc_sha1(record, s) {
		var rval = false;
		var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
		record.fragment.putBytes(mac);
		s.updateSequenceNumber();
		var iv;
		if (record.version.minor === tls.Versions.TLS_1_0.minor) iv = s.cipherState.init ? null : s.cipherState.iv;
		else iv = forge.random.getBytesSync(16);
		s.cipherState.init = true;
		var cipher = s.cipherState.cipher;
		cipher.start({ iv });
		if (record.version.minor >= tls.Versions.TLS_1_1.minor) cipher.output.putBytes(iv);
		cipher.update(record.fragment);
		if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
			record.fragment = cipher.output;
			record.length = record.fragment.length();
			rval = true;
		}
		return rval;
	}
	/**
	* Handles padding for aes_cbc_sha1 in encrypt mode.
	*
	* @param blockSize the block size.
	* @param input the input buffer.
	* @param decrypt true in decrypt mode, false in encrypt mode.
	*
	* @return true on success, false on failure.
	*/
	function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
		if (!decrypt) {
			var padding = blockSize - input.length() % blockSize;
			input.fillWithByte(padding - 1, padding);
		}
		return true;
	}
	/**
	* Handles padding for aes_cbc_sha1 in decrypt mode.
	*
	* @param blockSize the block size.
	* @param output the output buffer.
	* @param decrypt true in decrypt mode, false in encrypt mode.
	*
	* @return true on success, false on failure.
	*/
	function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
		var rval = true;
		if (decrypt) {
			var len = output.length();
			var paddingLength = output.last();
			for (var i = len - 1 - paddingLength; i < len - 1; ++i) rval = rval && output.at(i) == paddingLength;
			if (rval) output.truncate(paddingLength + 1);
		}
		return rval;
	}
	/**
	* Decrypts a TLSCipherText record into a TLSCompressed record using
	* AES in CBC mode.
	*
	* @param record the TLSCipherText record to decrypt.
	* @param s the ConnectionState to use.
	*
	* @return true on success, false on failure.
	*/
	function decrypt_aes_cbc_sha1(record, s) {
		var rval = false;
		var iv;
		if (record.version.minor === tls.Versions.TLS_1_0.minor) iv = s.cipherState.init ? null : s.cipherState.iv;
		else iv = record.fragment.getBytes(16);
		s.cipherState.init = true;
		var cipher = s.cipherState.cipher;
		cipher.start({ iv });
		cipher.update(record.fragment);
		rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
		var macLen = s.macLength;
		var mac = forge.random.getBytesSync(macLen);
		var len = cipher.output.length();
		if (len >= macLen) {
			record.fragment = cipher.output.getBytes(len - macLen);
			mac = cipher.output.getBytes(macLen);
		} else record.fragment = cipher.output.getBytes();
		record.fragment = forge.util.createBuffer(record.fragment);
		record.length = record.fragment.length();
		var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
		s.updateSequenceNumber();
		rval = compareMacs(s.macKey, mac, mac2) && rval;
		return rval;
	}
	/**
	* Safely compare two MACs. This function will compare two MACs in a way
	* that protects against timing attacks.
	*
	* TODO: Expose elsewhere as a utility API.
	*
	* See: https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/
	*
	* @param key the MAC key to use.
	* @param mac1 as a binary-encoded string of bytes.
	* @param mac2 as a binary-encoded string of bytes.
	*
	* @return true if the MACs are the same, false if not.
	*/
	function compareMacs(key, mac1, mac2) {
		var hmac = forge.hmac.create();
		hmac.start("SHA1", key);
		hmac.update(mac1);
		mac1 = hmac.digest().getBytes();
		hmac.start(null, null);
		hmac.update(mac2);
		mac2 = hmac.digest().getBytes();
		return mac1 === mac2;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/sha512.js
var require_sha512 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Secure Hash Algorithm with a 1024-bit block size implementation.
	*
	* This includes: SHA-512, SHA-384, SHA-512/224, and SHA-512/256. For
	* SHA-256 (block size 512 bits), see sha256.js.
	*
	* See FIPS 180-4 for details.
	*
	* @author Dave Longley
	*
	* Copyright (c) 2014-2015 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_md();
	require_util();
	var sha512 = module.exports = forge.sha512 = forge.sha512 || {};
	forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
	var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
	sha384.create = function() {
		return sha512.create("SHA-384");
	};
	forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
	forge.sha512.sha256 = forge.sha512.sha256 || { create: function() {
		return sha512.create("SHA-512/256");
	} };
	forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
	forge.sha512.sha224 = forge.sha512.sha224 || { create: function() {
		return sha512.create("SHA-512/224");
	} };
	forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
	/**
	* Creates a SHA-2 message digest object.
	*
	* @param algorithm the algorithm to use (SHA-512, SHA-384, SHA-512/224,
	*          SHA-512/256).
	*
	* @return a message digest object.
	*/
	sha512.create = function(algorithm) {
		if (!_initialized) _init();
		if (typeof algorithm === "undefined") algorithm = "SHA-512";
		if (!(algorithm in _states)) throw new Error("Invalid SHA-512 algorithm: " + algorithm);
		var _state = _states[algorithm];
		var _h = null;
		var _input = forge.util.createBuffer();
		var _w = new Array(80);
		for (var wi = 0; wi < 80; ++wi) _w[wi] = new Array(2);
		var digestLength = 64;
		switch (algorithm) {
			case "SHA-384":
				digestLength = 48;
				break;
			case "SHA-512/256":
				digestLength = 32;
				break;
			case "SHA-512/224":
				digestLength = 28;
				break;
		}
		var md = {
			algorithm: algorithm.replace("-", "").toLowerCase(),
			blockLength: 128,
			digestLength,
			messageLength: 0,
			fullMessageLength: null,
			messageLengthSize: 16
		};
		/**
		* Starts the digest.
		*
		* @return this digest object.
		*/
		md.start = function() {
			md.messageLength = 0;
			md.fullMessageLength = md.messageLength128 = [];
			var int32s = md.messageLengthSize / 4;
			for (var i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
			_input = forge.util.createBuffer();
			_h = new Array(_state.length);
			for (var i = 0; i < _state.length; ++i) _h[i] = _state[i].slice(0);
			return md;
		};
		md.start();
		/**
		* Updates the digest with the given message input. The given input can
		* treated as raw input (no encoding will be applied) or an encoding of
		* 'utf8' maybe given to encode the input using UTF-8.
		*
		* @param msg the message input to update with.
		* @param encoding the encoding to use (default: 'raw', other: 'utf8').
		*
		* @return this digest object.
		*/
		md.update = function(msg, encoding) {
			if (encoding === "utf8") msg = forge.util.encodeUtf8(msg);
			var len = msg.length;
			md.messageLength += len;
			len = [len / 4294967296 >>> 0, len >>> 0];
			for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
				md.fullMessageLength[i] += len[1];
				len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
				md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
				len[0] = len[1] / 4294967296 >>> 0;
			}
			_input.putBytes(msg);
			_update(_h, _w, _input);
			if (_input.read > 2048 || _input.length() === 0) _input.compact();
			return md;
		};
		/**
		* Produces the digest.
		*
		* @return a byte buffer containing the digest value.
		*/
		md.digest = function() {
			var finalBlock = forge.util.createBuffer();
			finalBlock.putBytes(_input.bytes());
			var overflow = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize & md.blockLength - 1;
			finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
			var next, carry;
			var bits = md.fullMessageLength[0] * 8;
			for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
				next = md.fullMessageLength[i + 1] * 8;
				carry = next / 4294967296 >>> 0;
				bits += carry;
				finalBlock.putInt32(bits >>> 0);
				bits = next >>> 0;
			}
			finalBlock.putInt32(bits);
			var h = new Array(_h.length);
			for (var i = 0; i < _h.length; ++i) h[i] = _h[i].slice(0);
			_update(h, _w, finalBlock);
			var rval = forge.util.createBuffer();
			var hlen;
			if (algorithm === "SHA-512") hlen = h.length;
			else if (algorithm === "SHA-384") hlen = h.length - 2;
			else hlen = h.length - 4;
			for (var i = 0; i < hlen; ++i) {
				rval.putInt32(h[i][0]);
				if (i !== hlen - 1 || algorithm !== "SHA-512/224") rval.putInt32(h[i][1]);
			}
			return rval;
		};
		return md;
	};
	var _padding = null;
	var _initialized = false;
	var _k = null;
	var _states = null;
	/**
	* Initializes the constant tables.
	*/
	function _init() {
		_padding = String.fromCharCode(128);
		_padding += forge.util.fillString(String.fromCharCode(0), 128);
		_k = [
			[1116352408, 3609767458],
			[1899447441, 602891725],
			[3049323471, 3964484399],
			[3921009573, 2173295548],
			[961987163, 4081628472],
			[1508970993, 3053834265],
			[2453635748, 2937671579],
			[2870763221, 3664609560],
			[3624381080, 2734883394],
			[310598401, 1164996542],
			[607225278, 1323610764],
			[1426881987, 3590304994],
			[1925078388, 4068182383],
			[2162078206, 991336113],
			[2614888103, 633803317],
			[3248222580, 3479774868],
			[3835390401, 2666613458],
			[4022224774, 944711139],
			[264347078, 2341262773],
			[604807628, 2007800933],
			[770255983, 1495990901],
			[1249150122, 1856431235],
			[1555081692, 3175218132],
			[1996064986, 2198950837],
			[2554220882, 3999719339],
			[2821834349, 766784016],
			[2952996808, 2566594879],
			[3210313671, 3203337956],
			[3336571891, 1034457026],
			[3584528711, 2466948901],
			[113926993, 3758326383],
			[338241895, 168717936],
			[666307205, 1188179964],
			[773529912, 1546045734],
			[1294757372, 1522805485],
			[1396182291, 2643833823],
			[1695183700, 2343527390],
			[1986661051, 1014477480],
			[2177026350, 1206759142],
			[2456956037, 344077627],
			[2730485921, 1290863460],
			[2820302411, 3158454273],
			[3259730800, 3505952657],
			[3345764771, 106217008],
			[3516065817, 3606008344],
			[3600352804, 1432725776],
			[4094571909, 1467031594],
			[275423344, 851169720],
			[430227734, 3100823752],
			[506948616, 1363258195],
			[659060556, 3750685593],
			[883997877, 3785050280],
			[958139571, 3318307427],
			[1322822218, 3812723403],
			[1537002063, 2003034995],
			[1747873779, 3602036899],
			[1955562222, 1575990012],
			[2024104815, 1125592928],
			[2227730452, 2716904306],
			[2361852424, 442776044],
			[2428436474, 593698344],
			[2756734187, 3733110249],
			[3204031479, 2999351573],
			[3329325298, 3815920427],
			[3391569614, 3928383900],
			[3515267271, 566280711],
			[3940187606, 3454069534],
			[4118630271, 4000239992],
			[116418474, 1914138554],
			[174292421, 2731055270],
			[289380356, 3203993006],
			[460393269, 320620315],
			[685471733, 587496836],
			[852142971, 1086792851],
			[1017036298, 365543100],
			[1126000580, 2618297676],
			[1288033470, 3409855158],
			[1501505948, 4234509866],
			[1607167915, 987167468],
			[1816402316, 1246189591]
		];
		_states = {};
		_states["SHA-512"] = [
			[1779033703, 4089235720],
			[3144134277, 2227873595],
			[1013904242, 4271175723],
			[2773480762, 1595750129],
			[1359893119, 2917565137],
			[2600822924, 725511199],
			[528734635, 4215389547],
			[1541459225, 327033209]
		];
		_states["SHA-384"] = [
			[3418070365, 3238371032],
			[1654270250, 914150663],
			[2438529370, 812702999],
			[355462360, 4144912697],
			[1731405415, 4290775857],
			[2394180231, 1750603025],
			[3675008525, 1694076839],
			[1203062813, 3204075428]
		];
		_states["SHA-512/256"] = [
			[573645204, 4230739756],
			[2673172387, 3360449730],
			[596883563, 1867755857],
			[2520282905, 1497426621],
			[2519219938, 2827943907],
			[3193839141, 1401305490],
			[721525244, 746961066],
			[246885852, 2177182882]
		];
		_states["SHA-512/224"] = [
			[2352822216, 424955298],
			[1944164710, 2312950998],
			[502970286, 855612546],
			[1738396948, 1479516111],
			[258812777, 2077511080],
			[2011393907, 79989058],
			[1067287976, 1780299464],
			[286451373, 2446758561]
		];
		_initialized = true;
	}
	/**
	* Updates a SHA-512 state with the given byte buffer.
	*
	* @param s the SHA-512 state to update.
	* @param w the array to use to store words.
	* @param bytes the byte buffer to update with.
	*/
	function _update(s, w, bytes) {
		var t1_hi, t1_lo;
		var t2_hi, t2_lo;
		var s0_hi, s0_lo;
		var s1_hi, s1_lo;
		var ch_hi, ch_lo;
		var maj_hi, maj_lo;
		var a_hi, a_lo;
		var b_hi, b_lo;
		var c_hi, c_lo;
		var d_hi, d_lo;
		var e_hi, e_lo;
		var f_hi, f_lo;
		var g_hi, g_lo;
		var h_hi, h_lo;
		var i, hi, lo, w2, w7, w15, w16;
		var len = bytes.length();
		while (len >= 128) {
			for (i = 0; i < 16; ++i) {
				w[i][0] = bytes.getInt32() >>> 0;
				w[i][1] = bytes.getInt32() >>> 0;
			}
			for (; i < 80; ++i) {
				w2 = w[i - 2];
				hi = w2[0];
				lo = w2[1];
				t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
				t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
				w15 = w[i - 15];
				hi = w15[0];
				lo = w15[1];
				t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
				t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
				w7 = w[i - 7];
				w16 = w[i - 16];
				lo = t1_lo + w7[1] + t2_lo + w16[1];
				w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
				w[i][1] = lo >>> 0;
			}
			a_hi = s[0][0];
			a_lo = s[0][1];
			b_hi = s[1][0];
			b_lo = s[1][1];
			c_hi = s[2][0];
			c_lo = s[2][1];
			d_hi = s[3][0];
			d_lo = s[3][1];
			e_hi = s[4][0];
			e_lo = s[4][1];
			f_hi = s[5][0];
			f_lo = s[5][1];
			g_hi = s[6][0];
			g_lo = s[6][1];
			h_hi = s[7][0];
			h_lo = s[7][1];
			for (i = 0; i < 80; ++i) {
				s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
				s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
				ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
				ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
				s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
				s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
				maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
				maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
				lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
				t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
				t1_lo = lo >>> 0;
				lo = s0_lo + maj_lo;
				t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
				t2_lo = lo >>> 0;
				h_hi = g_hi;
				h_lo = g_lo;
				g_hi = f_hi;
				g_lo = f_lo;
				f_hi = e_hi;
				f_lo = e_lo;
				lo = d_lo + t1_lo;
				e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
				e_lo = lo >>> 0;
				d_hi = c_hi;
				d_lo = c_lo;
				c_hi = b_hi;
				c_lo = b_lo;
				b_hi = a_hi;
				b_lo = a_lo;
				lo = t1_lo + t2_lo;
				a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
				a_lo = lo >>> 0;
			}
			lo = s[0][1] + a_lo;
			s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[0][1] = lo >>> 0;
			lo = s[1][1] + b_lo;
			s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[1][1] = lo >>> 0;
			lo = s[2][1] + c_lo;
			s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[2][1] = lo >>> 0;
			lo = s[3][1] + d_lo;
			s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[3][1] = lo >>> 0;
			lo = s[4][1] + e_lo;
			s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[4][1] = lo >>> 0;
			lo = s[5][1] + f_lo;
			s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[5][1] = lo >>> 0;
			lo = s[6][1] + g_lo;
			s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[6][1] = lo >>> 0;
			lo = s[7][1] + h_lo;
			s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
			s[7][1] = lo >>> 0;
			len -= 128;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* Copyright (c) 2019 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_asn1();
	var asn1 = forge.asn1;
	exports.privateKeyValidator = {
		name: "PrivateKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		value: [
			{
				name: "PrivateKeyInfo.version",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.INTEGER,
				constructed: false,
				capture: "privateKeyVersion"
			},
			{
				name: "PrivateKeyInfo.privateKeyAlgorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.SEQUENCE,
				constructed: true,
				value: [{
					name: "AlgorithmIdentifier.algorithm",
					tagClass: asn1.Class.UNIVERSAL,
					type: asn1.Type.OID,
					constructed: false,
					capture: "privateKeyOid"
				}]
			},
			{
				name: "PrivateKeyInfo",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OCTETSTRING,
				constructed: false,
				capture: "privateKey"
			}
		]
	};
	exports.publicKeyValidator = {
		name: "SubjectPublicKeyInfo",
		tagClass: asn1.Class.UNIVERSAL,
		type: asn1.Type.SEQUENCE,
		constructed: true,
		captureAsn1: "subjectPublicKeyInfo",
		value: [{
			name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.SEQUENCE,
			constructed: true,
			value: [{
				name: "AlgorithmIdentifier.algorithm",
				tagClass: asn1.Class.UNIVERSAL,
				type: asn1.Type.OID,
				constructed: false,
				capture: "publicKeyOid"
			}]
		}, {
			tagClass: asn1.Class.UNIVERSAL,
			type: asn1.Type.BITSTRING,
			constructed: false,
			composed: true,
			captureBitStringValue: "ed25519PublicKey"
		}]
	};
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/ed25519.js
var require_ed25519 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* JavaScript implementation of Ed25519.
	*
	* Copyright (c) 2017-2019 Digital Bazaar, Inc.
	*
	* This implementation is based on the most excellent TweetNaCl which is
	* in the public domain. Many thanks to its contributors:
	*
	* https://github.com/dchest/tweetnacl-js
	*/
	var forge = require_forge();
	require_jsbn();
	require_random();
	require_sha512();
	require_util();
	var asn1Validator = require_asn1_validator();
	var publicKeyValidator = asn1Validator.publicKeyValidator;
	var privateKeyValidator = asn1Validator.privateKeyValidator;
	if (typeof BigInteger === "undefined") var BigInteger = forge.jsbn.BigInteger;
	var ByteBuffer = forge.util.ByteBuffer;
	var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
	forge.pki = forge.pki || {};
	module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
	var ed25519 = forge.ed25519;
	ed25519.constants = {};
	ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
	ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
	ed25519.constants.SEED_BYTE_LENGTH = 32;
	ed25519.constants.SIGN_BYTE_LENGTH = 64;
	ed25519.constants.HASH_BYTE_LENGTH = 64;
	ed25519.generateKeyPair = function(options) {
		options = options || {};
		var seed = options.seed;
		if (seed === void 0) seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
		else if (typeof seed === "string") {
			if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) throw new TypeError("\"seed\" must be " + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.");
		} else if (!(seed instanceof Uint8Array)) throw new TypeError("\"seed\" must be a node.js Buffer, Uint8Array, or a binary string.");
		seed = messageToNativeBuffer({
			message: seed,
			encoding: "binary"
		});
		var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
		var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
		for (var i = 0; i < 32; ++i) sk[i] = seed[i];
		crypto_sign_keypair(pk, sk);
		return {
			publicKey: pk,
			privateKey: sk
		};
	};
	/**
	* Converts a private key from a RFC8410 ASN.1 encoding.
	*
	* @param obj - The asn1 representation of a private key.
	*
	* @returns {Object} keyInfo - The key information.
	* @returns {Buffer|Uint8Array} keyInfo.privateKeyBytes - 32 private key bytes.
	*/
	ed25519.privateKeyFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (!forge.asn1.validate(obj, privateKeyValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Invalid Key.");
			error.errors = errors;
			throw error;
		}
		var oid = forge.asn1.derToOid(capture.privateKeyOid);
		var ed25519Oid = forge.oids.EdDSA25519;
		if (oid !== ed25519Oid) throw new Error("Invalid OID \"" + oid + "\"; OID must be \"" + ed25519Oid + "\".");
		var privateKey = capture.privateKey;
		return { privateKeyBytes: messageToNativeBuffer({
			message: forge.asn1.fromDer(privateKey).value,
			encoding: "binary"
		}) };
	};
	/**
	* Converts a public key from a RFC8410 ASN.1 encoding.
	*
	* @param obj - The asn1 representation of a public key.
	*
	* @return {Buffer|Uint8Array} - 32 public key bytes.
	*/
	ed25519.publicKeyFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (!forge.asn1.validate(obj, publicKeyValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Invalid Key.");
			error.errors = errors;
			throw error;
		}
		var oid = forge.asn1.derToOid(capture.publicKeyOid);
		var ed25519Oid = forge.oids.EdDSA25519;
		if (oid !== ed25519Oid) throw new Error("Invalid OID \"" + oid + "\"; OID must be \"" + ed25519Oid + "\".");
		var publicKeyBytes = capture.ed25519PublicKey;
		if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error("Key length is invalid.");
		return messageToNativeBuffer({
			message: publicKeyBytes,
			encoding: "binary"
		});
	};
	ed25519.publicKeyFromPrivateKey = function(options) {
		options = options || {};
		var privateKey = messageToNativeBuffer({
			message: options.privateKey,
			encoding: "binary"
		});
		if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError("\"options.privateKey\" must have a byte length of " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
		var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
		for (var i = 0; i < pk.length; ++i) pk[i] = privateKey[32 + i];
		return pk;
	};
	ed25519.sign = function(options) {
		options = options || {};
		var msg = messageToNativeBuffer(options);
		var privateKey = messageToNativeBuffer({
			message: options.privateKey,
			encoding: "binary"
		});
		if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) privateKey = ed25519.generateKeyPair({ seed: privateKey }).privateKey;
		else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError("\"options.privateKey\" must have a byte length of " + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
		var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
		crypto_sign(signedMsg, msg, msg.length, privateKey);
		var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
		for (var i = 0; i < sig.length; ++i) sig[i] = signedMsg[i];
		return sig;
	};
	ed25519.verify = function(options) {
		options = options || {};
		var msg = messageToNativeBuffer(options);
		if (options.signature === void 0) throw new TypeError("\"options.signature\" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.");
		var sig = messageToNativeBuffer({
			message: options.signature,
			encoding: "binary"
		});
		if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) throw new TypeError("\"options.signature\" must have a byte length of " + ed25519.constants.SIGN_BYTE_LENGTH);
		var publicKey = messageToNativeBuffer({
			message: options.publicKey,
			encoding: "binary"
		});
		if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) throw new TypeError("\"options.publicKey\" must have a byte length of " + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
		var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
		var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
		var i;
		for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) sm[i] = sig[i];
		for (i = 0; i < msg.length; ++i) sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
		return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
	};
	function messageToNativeBuffer(options) {
		var message = options.message;
		if (message instanceof Uint8Array || message instanceof NativeBuffer) return message;
		var encoding = options.encoding;
		if (message === void 0) if (options.md) {
			message = options.md.digest().getBytes();
			encoding = "binary";
		} else throw new TypeError("\"options.message\" or \"options.md\" not specified.");
		if (typeof message === "string" && !encoding) throw new TypeError("\"options.encoding\" must be \"binary\" or \"utf8\".");
		if (typeof message === "string") {
			if (typeof Buffer !== "undefined") return Buffer.from(message, encoding);
			message = new ByteBuffer(message, encoding);
		} else if (!(message instanceof ByteBuffer)) throw new TypeError("\"options.message\" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with \"options.encoding\" specifying its encoding.");
		var buffer = new NativeBuffer(message.length());
		for (var i = 0; i < buffer.length; ++i) buffer[i] = message.at(i);
		return buffer;
	}
	var gf0 = gf();
	var gf1 = gf([1]);
	var D = gf([
		30883,
		4953,
		19914,
		30187,
		55467,
		16705,
		2637,
		112,
		59544,
		30585,
		16505,
		36039,
		65139,
		11119,
		27886,
		20995
	]);
	var D2 = gf([
		61785,
		9906,
		39828,
		60374,
		45398,
		33411,
		5274,
		224,
		53552,
		61171,
		33010,
		6542,
		64743,
		22239,
		55772,
		9222
	]);
	var X = gf([
		54554,
		36645,
		11616,
		51542,
		42930,
		38181,
		51040,
		26924,
		56412,
		64982,
		57905,
		49316,
		21502,
		52590,
		14035,
		8553
	]);
	var Y = gf([
		26200,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214,
		26214
	]);
	var L = new Float64Array([
		237,
		211,
		245,
		92,
		26,
		99,
		18,
		88,
		214,
		156,
		247,
		162,
		222,
		249,
		222,
		20,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		16
	]);
	var I = gf([
		41136,
		18958,
		6951,
		50414,
		58488,
		44335,
		6150,
		12099,
		55207,
		15867,
		153,
		11085,
		57099,
		20417,
		9344,
		11139
	]);
	function sha512(msg, msgLen) {
		var md = forge.md.sha512.create();
		var buffer = new ByteBuffer(msg);
		md.update(buffer.getBytes(msgLen), "binary");
		var hash = md.digest().getBytes();
		if (typeof Buffer !== "undefined") return Buffer.from(hash, "binary");
		var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
		for (var i = 0; i < 64; ++i) out[i] = hash.charCodeAt(i);
		return out;
	}
	function crypto_sign_keypair(pk, sk) {
		var p = [
			gf(),
			gf(),
			gf(),
			gf()
		];
		var i;
		var d = sha512(sk, 32);
		d[0] &= 248;
		d[31] &= 127;
		d[31] |= 64;
		scalarbase(p, d);
		pack(pk, p);
		for (i = 0; i < 32; ++i) sk[i + 32] = pk[i];
		return 0;
	}
	function crypto_sign(sm, m, n, sk) {
		var i, j, x = new Float64Array(64);
		var p = [
			gf(),
			gf(),
			gf(),
			gf()
		];
		var d = sha512(sk, 32);
		d[0] &= 248;
		d[31] &= 127;
		d[31] |= 64;
		var smlen = n + 64;
		for (i = 0; i < n; ++i) sm[64 + i] = m[i];
		for (i = 0; i < 32; ++i) sm[32 + i] = d[32 + i];
		var r = sha512(sm.subarray(32), n + 32);
		reduce(r);
		scalarbase(p, r);
		pack(sm, p);
		for (i = 32; i < 64; ++i) sm[i] = sk[i];
		var h = sha512(sm, n + 64);
		reduce(h);
		for (i = 32; i < 64; ++i) x[i] = 0;
		for (i = 0; i < 32; ++i) x[i] = r[i];
		for (i = 0; i < 32; ++i) for (j = 0; j < 32; j++) x[i + j] += h[i] * d[j];
		modL(sm.subarray(32), x);
		return smlen;
	}
	function crypto_sign_open(m, sm, n, pk) {
		var i, mlen;
		var t = new NativeBuffer(32);
		var p = [
			gf(),
			gf(),
			gf(),
			gf()
		], q = [
			gf(),
			gf(),
			gf(),
			gf()
		];
		mlen = -1;
		if (n < 64) return -1;
		if (unpackneg(q, pk)) return -1;
		for (i = 0; i < n; ++i) m[i] = sm[i];
		for (i = 0; i < 32; ++i) m[i + 32] = pk[i];
		var h = sha512(m, n);
		reduce(h);
		scalarmult(p, q, h);
		scalarbase(q, sm.subarray(32));
		add(p, q);
		pack(t, p);
		n -= 64;
		if (crypto_verify_32(sm, 0, t, 0)) {
			for (i = 0; i < n; ++i) m[i] = 0;
			return -1;
		}
		for (i = 0; i < n; ++i) m[i] = sm[i + 64];
		mlen = n;
		return mlen;
	}
	function modL(r, x) {
		var carry, i, j, k;
		for (i = 63; i >= 32; --i) {
			carry = 0;
			for (j = i - 32, k = i - 12; j < k; ++j) {
				x[j] += carry - 16 * x[i] * L[j - (i - 32)];
				carry = x[j] + 128 >> 8;
				x[j] -= carry * 256;
			}
			x[j] += carry;
			x[i] = 0;
		}
		carry = 0;
		for (j = 0; j < 32; ++j) {
			x[j] += carry - (x[31] >> 4) * L[j];
			carry = x[j] >> 8;
			x[j] &= 255;
		}
		for (j = 0; j < 32; ++j) x[j] -= carry * L[j];
		for (i = 0; i < 32; ++i) {
			x[i + 1] += x[i] >> 8;
			r[i] = x[i] & 255;
		}
	}
	function reduce(r) {
		var x = new Float64Array(64);
		for (var i = 0; i < 64; ++i) {
			x[i] = r[i];
			r[i] = 0;
		}
		modL(r, x);
	}
	function add(p, q) {
		var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
		Z(a, p[1], p[0]);
		Z(t, q[1], q[0]);
		M(a, a, t);
		A(b, p[0], p[1]);
		A(t, q[0], q[1]);
		M(b, b, t);
		M(c, p[3], q[3]);
		M(c, c, D2);
		M(d, p[2], q[2]);
		A(d, d, d);
		Z(e, b, a);
		Z(f, d, c);
		A(g, d, c);
		A(h, b, a);
		M(p[0], e, f);
		M(p[1], h, g);
		M(p[2], g, f);
		M(p[3], e, h);
	}
	function cswap(p, q, b) {
		for (var i = 0; i < 4; ++i) sel25519(p[i], q[i], b);
	}
	function pack(r, p) {
		var tx = gf(), ty = gf(), zi = gf();
		inv25519(zi, p[2]);
		M(tx, p[0], zi);
		M(ty, p[1], zi);
		pack25519(r, ty);
		r[31] ^= par25519(tx) << 7;
	}
	function pack25519(o, n) {
		var i, j, b;
		var m = gf(), t = gf();
		for (i = 0; i < 16; ++i) t[i] = n[i];
		car25519(t);
		car25519(t);
		car25519(t);
		for (j = 0; j < 2; ++j) {
			m[0] = t[0] - 65517;
			for (i = 1; i < 15; ++i) {
				m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
				m[i - 1] &= 65535;
			}
			m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
			b = m[15] >> 16 & 1;
			m[14] &= 65535;
			sel25519(t, m, 1 - b);
		}
		for (i = 0; i < 16; i++) {
			o[2 * i] = t[i] & 255;
			o[2 * i + 1] = t[i] >> 8;
		}
	}
	function unpackneg(r, p) {
		var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
		set25519(r[2], gf1);
		unpack25519(r[1], p);
		S(num, r[1]);
		M(den, num, D);
		Z(num, num, r[2]);
		A(den, r[2], den);
		S(den2, den);
		S(den4, den2);
		M(den6, den4, den2);
		M(t, den6, num);
		M(t, t, den);
		pow2523(t, t);
		M(t, t, num);
		M(t, t, den);
		M(t, t, den);
		M(r[0], t, den);
		S(chk, r[0]);
		M(chk, chk, den);
		if (neq25519(chk, num)) M(r[0], r[0], I);
		S(chk, r[0]);
		M(chk, chk, den);
		if (neq25519(chk, num)) return -1;
		if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
		M(r[3], r[0], r[1]);
		return 0;
	}
	function unpack25519(o, n) {
		var i;
		for (i = 0; i < 16; ++i) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
		o[15] &= 32767;
	}
	function pow2523(o, i) {
		var c = gf();
		var a;
		for (a = 0; a < 16; ++a) c[a] = i[a];
		for (a = 250; a >= 0; --a) {
			S(c, c);
			if (a !== 1) M(c, c, i);
		}
		for (a = 0; a < 16; ++a) o[a] = c[a];
	}
	function neq25519(a, b) {
		var c = new NativeBuffer(32);
		var d = new NativeBuffer(32);
		pack25519(c, a);
		pack25519(d, b);
		return crypto_verify_32(c, 0, d, 0);
	}
	function crypto_verify_32(x, xi, y, yi) {
		return vn(x, xi, y, yi, 32);
	}
	function vn(x, xi, y, yi, n) {
		var i, d = 0;
		for (i = 0; i < n; ++i) d |= x[xi + i] ^ y[yi + i];
		return (1 & d - 1 >>> 8) - 1;
	}
	function par25519(a) {
		var d = new NativeBuffer(32);
		pack25519(d, a);
		return d[0] & 1;
	}
	function scalarmult(p, q, s) {
		var b, i;
		set25519(p[0], gf0);
		set25519(p[1], gf1);
		set25519(p[2], gf1);
		set25519(p[3], gf0);
		for (i = 255; i >= 0; --i) {
			b = s[i / 8 | 0] >> (i & 7) & 1;
			cswap(p, q, b);
			add(q, p);
			add(p, p);
			cswap(p, q, b);
		}
	}
	function scalarbase(p, s) {
		var q = [
			gf(),
			gf(),
			gf(),
			gf()
		];
		set25519(q[0], X);
		set25519(q[1], Y);
		set25519(q[2], gf1);
		M(q[3], X, Y);
		scalarmult(p, q, s);
	}
	function set25519(r, a) {
		var i;
		for (i = 0; i < 16; i++) r[i] = a[i] | 0;
	}
	function inv25519(o, i) {
		var c = gf();
		var a;
		for (a = 0; a < 16; ++a) c[a] = i[a];
		for (a = 253; a >= 0; --a) {
			S(c, c);
			if (a !== 2 && a !== 4) M(c, c, i);
		}
		for (a = 0; a < 16; ++a) o[a] = c[a];
	}
	function car25519(o) {
		var i, v, c = 1;
		for (i = 0; i < 16; ++i) {
			v = o[i] + c + 65535;
			c = Math.floor(v / 65536);
			o[i] = v - c * 65536;
		}
		o[0] += c - 1 + 37 * (c - 1);
	}
	function sel25519(p, q, b) {
		var t, c = ~(b - 1);
		for (var i = 0; i < 16; ++i) {
			t = c & (p[i] ^ q[i]);
			p[i] ^= t;
			q[i] ^= t;
		}
	}
	function gf(init) {
		var i, r = new Float64Array(16);
		if (init) for (i = 0; i < init.length; ++i) r[i] = init[i];
		return r;
	}
	function A(o, a, b) {
		for (var i = 0; i < 16; ++i) o[i] = a[i] + b[i];
	}
	function Z(o, a, b) {
		for (var i = 0; i < 16; ++i) o[i] = a[i] - b[i];
	}
	function S(o, a) {
		M(o, a, a);
	}
	function M(o, a, b) {
		var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
		v = a[0];
		t0 += v * b0;
		t1 += v * b1;
		t2 += v * b2;
		t3 += v * b3;
		t4 += v * b4;
		t5 += v * b5;
		t6 += v * b6;
		t7 += v * b7;
		t8 += v * b8;
		t9 += v * b9;
		t10 += v * b10;
		t11 += v * b11;
		t12 += v * b12;
		t13 += v * b13;
		t14 += v * b14;
		t15 += v * b15;
		v = a[1];
		t1 += v * b0;
		t2 += v * b1;
		t3 += v * b2;
		t4 += v * b3;
		t5 += v * b4;
		t6 += v * b5;
		t7 += v * b6;
		t8 += v * b7;
		t9 += v * b8;
		t10 += v * b9;
		t11 += v * b10;
		t12 += v * b11;
		t13 += v * b12;
		t14 += v * b13;
		t15 += v * b14;
		t16 += v * b15;
		v = a[2];
		t2 += v * b0;
		t3 += v * b1;
		t4 += v * b2;
		t5 += v * b3;
		t6 += v * b4;
		t7 += v * b5;
		t8 += v * b6;
		t9 += v * b7;
		t10 += v * b8;
		t11 += v * b9;
		t12 += v * b10;
		t13 += v * b11;
		t14 += v * b12;
		t15 += v * b13;
		t16 += v * b14;
		t17 += v * b15;
		v = a[3];
		t3 += v * b0;
		t4 += v * b1;
		t5 += v * b2;
		t6 += v * b3;
		t7 += v * b4;
		t8 += v * b5;
		t9 += v * b6;
		t10 += v * b7;
		t11 += v * b8;
		t12 += v * b9;
		t13 += v * b10;
		t14 += v * b11;
		t15 += v * b12;
		t16 += v * b13;
		t17 += v * b14;
		t18 += v * b15;
		v = a[4];
		t4 += v * b0;
		t5 += v * b1;
		t6 += v * b2;
		t7 += v * b3;
		t8 += v * b4;
		t9 += v * b5;
		t10 += v * b6;
		t11 += v * b7;
		t12 += v * b8;
		t13 += v * b9;
		t14 += v * b10;
		t15 += v * b11;
		t16 += v * b12;
		t17 += v * b13;
		t18 += v * b14;
		t19 += v * b15;
		v = a[5];
		t5 += v * b0;
		t6 += v * b1;
		t7 += v * b2;
		t8 += v * b3;
		t9 += v * b4;
		t10 += v * b5;
		t11 += v * b6;
		t12 += v * b7;
		t13 += v * b8;
		t14 += v * b9;
		t15 += v * b10;
		t16 += v * b11;
		t17 += v * b12;
		t18 += v * b13;
		t19 += v * b14;
		t20 += v * b15;
		v = a[6];
		t6 += v * b0;
		t7 += v * b1;
		t8 += v * b2;
		t9 += v * b3;
		t10 += v * b4;
		t11 += v * b5;
		t12 += v * b6;
		t13 += v * b7;
		t14 += v * b8;
		t15 += v * b9;
		t16 += v * b10;
		t17 += v * b11;
		t18 += v * b12;
		t19 += v * b13;
		t20 += v * b14;
		t21 += v * b15;
		v = a[7];
		t7 += v * b0;
		t8 += v * b1;
		t9 += v * b2;
		t10 += v * b3;
		t11 += v * b4;
		t12 += v * b5;
		t13 += v * b6;
		t14 += v * b7;
		t15 += v * b8;
		t16 += v * b9;
		t17 += v * b10;
		t18 += v * b11;
		t19 += v * b12;
		t20 += v * b13;
		t21 += v * b14;
		t22 += v * b15;
		v = a[8];
		t8 += v * b0;
		t9 += v * b1;
		t10 += v * b2;
		t11 += v * b3;
		t12 += v * b4;
		t13 += v * b5;
		t14 += v * b6;
		t15 += v * b7;
		t16 += v * b8;
		t17 += v * b9;
		t18 += v * b10;
		t19 += v * b11;
		t20 += v * b12;
		t21 += v * b13;
		t22 += v * b14;
		t23 += v * b15;
		v = a[9];
		t9 += v * b0;
		t10 += v * b1;
		t11 += v * b2;
		t12 += v * b3;
		t13 += v * b4;
		t14 += v * b5;
		t15 += v * b6;
		t16 += v * b7;
		t17 += v * b8;
		t18 += v * b9;
		t19 += v * b10;
		t20 += v * b11;
		t21 += v * b12;
		t22 += v * b13;
		t23 += v * b14;
		t24 += v * b15;
		v = a[10];
		t10 += v * b0;
		t11 += v * b1;
		t12 += v * b2;
		t13 += v * b3;
		t14 += v * b4;
		t15 += v * b5;
		t16 += v * b6;
		t17 += v * b7;
		t18 += v * b8;
		t19 += v * b9;
		t20 += v * b10;
		t21 += v * b11;
		t22 += v * b12;
		t23 += v * b13;
		t24 += v * b14;
		t25 += v * b15;
		v = a[11];
		t11 += v * b0;
		t12 += v * b1;
		t13 += v * b2;
		t14 += v * b3;
		t15 += v * b4;
		t16 += v * b5;
		t17 += v * b6;
		t18 += v * b7;
		t19 += v * b8;
		t20 += v * b9;
		t21 += v * b10;
		t22 += v * b11;
		t23 += v * b12;
		t24 += v * b13;
		t25 += v * b14;
		t26 += v * b15;
		v = a[12];
		t12 += v * b0;
		t13 += v * b1;
		t14 += v * b2;
		t15 += v * b3;
		t16 += v * b4;
		t17 += v * b5;
		t18 += v * b6;
		t19 += v * b7;
		t20 += v * b8;
		t21 += v * b9;
		t22 += v * b10;
		t23 += v * b11;
		t24 += v * b12;
		t25 += v * b13;
		t26 += v * b14;
		t27 += v * b15;
		v = a[13];
		t13 += v * b0;
		t14 += v * b1;
		t15 += v * b2;
		t16 += v * b3;
		t17 += v * b4;
		t18 += v * b5;
		t19 += v * b6;
		t20 += v * b7;
		t21 += v * b8;
		t22 += v * b9;
		t23 += v * b10;
		t24 += v * b11;
		t25 += v * b12;
		t26 += v * b13;
		t27 += v * b14;
		t28 += v * b15;
		v = a[14];
		t14 += v * b0;
		t15 += v * b1;
		t16 += v * b2;
		t17 += v * b3;
		t18 += v * b4;
		t19 += v * b5;
		t20 += v * b6;
		t21 += v * b7;
		t22 += v * b8;
		t23 += v * b9;
		t24 += v * b10;
		t25 += v * b11;
		t26 += v * b12;
		t27 += v * b13;
		t28 += v * b14;
		t29 += v * b15;
		v = a[15];
		t15 += v * b0;
		t16 += v * b1;
		t17 += v * b2;
		t18 += v * b3;
		t19 += v * b4;
		t20 += v * b5;
		t21 += v * b6;
		t22 += v * b7;
		t23 += v * b8;
		t24 += v * b9;
		t25 += v * b10;
		t26 += v * b11;
		t27 += v * b12;
		t28 += v * b13;
		t29 += v * b14;
		t30 += v * b15;
		t0 += 38 * t16;
		t1 += 38 * t17;
		t2 += 38 * t18;
		t3 += 38 * t19;
		t4 += 38 * t20;
		t5 += 38 * t21;
		t6 += 38 * t22;
		t7 += 38 * t23;
		t8 += 38 * t24;
		t9 += 38 * t25;
		t10 += 38 * t26;
		t11 += 38 * t27;
		t12 += 38 * t28;
		t13 += 38 * t29;
		t14 += 38 * t30;
		c = 1;
		v = t0 + c + 65535;
		c = Math.floor(v / 65536);
		t0 = v - c * 65536;
		v = t1 + c + 65535;
		c = Math.floor(v / 65536);
		t1 = v - c * 65536;
		v = t2 + c + 65535;
		c = Math.floor(v / 65536);
		t2 = v - c * 65536;
		v = t3 + c + 65535;
		c = Math.floor(v / 65536);
		t3 = v - c * 65536;
		v = t4 + c + 65535;
		c = Math.floor(v / 65536);
		t4 = v - c * 65536;
		v = t5 + c + 65535;
		c = Math.floor(v / 65536);
		t5 = v - c * 65536;
		v = t6 + c + 65535;
		c = Math.floor(v / 65536);
		t6 = v - c * 65536;
		v = t7 + c + 65535;
		c = Math.floor(v / 65536);
		t7 = v - c * 65536;
		v = t8 + c + 65535;
		c = Math.floor(v / 65536);
		t8 = v - c * 65536;
		v = t9 + c + 65535;
		c = Math.floor(v / 65536);
		t9 = v - c * 65536;
		v = t10 + c + 65535;
		c = Math.floor(v / 65536);
		t10 = v - c * 65536;
		v = t11 + c + 65535;
		c = Math.floor(v / 65536);
		t11 = v - c * 65536;
		v = t12 + c + 65535;
		c = Math.floor(v / 65536);
		t12 = v - c * 65536;
		v = t13 + c + 65535;
		c = Math.floor(v / 65536);
		t13 = v - c * 65536;
		v = t14 + c + 65535;
		c = Math.floor(v / 65536);
		t14 = v - c * 65536;
		v = t15 + c + 65535;
		c = Math.floor(v / 65536);
		t15 = v - c * 65536;
		t0 += c - 1 + 37 * (c - 1);
		c = 1;
		v = t0 + c + 65535;
		c = Math.floor(v / 65536);
		t0 = v - c * 65536;
		v = t1 + c + 65535;
		c = Math.floor(v / 65536);
		t1 = v - c * 65536;
		v = t2 + c + 65535;
		c = Math.floor(v / 65536);
		t2 = v - c * 65536;
		v = t3 + c + 65535;
		c = Math.floor(v / 65536);
		t3 = v - c * 65536;
		v = t4 + c + 65535;
		c = Math.floor(v / 65536);
		t4 = v - c * 65536;
		v = t5 + c + 65535;
		c = Math.floor(v / 65536);
		t5 = v - c * 65536;
		v = t6 + c + 65535;
		c = Math.floor(v / 65536);
		t6 = v - c * 65536;
		v = t7 + c + 65535;
		c = Math.floor(v / 65536);
		t7 = v - c * 65536;
		v = t8 + c + 65535;
		c = Math.floor(v / 65536);
		t8 = v - c * 65536;
		v = t9 + c + 65535;
		c = Math.floor(v / 65536);
		t9 = v - c * 65536;
		v = t10 + c + 65535;
		c = Math.floor(v / 65536);
		t10 = v - c * 65536;
		v = t11 + c + 65535;
		c = Math.floor(v / 65536);
		t11 = v - c * 65536;
		v = t12 + c + 65535;
		c = Math.floor(v / 65536);
		t12 = v - c * 65536;
		v = t13 + c + 65535;
		c = Math.floor(v / 65536);
		t13 = v - c * 65536;
		v = t14 + c + 65535;
		c = Math.floor(v / 65536);
		t14 = v - c * 65536;
		v = t15 + c + 65535;
		c = Math.floor(v / 65536);
		t15 = v - c * 65536;
		t0 += c - 1 + 37 * (c - 1);
		o[0] = t0;
		o[1] = t1;
		o[2] = t2;
		o[3] = t3;
		o[4] = t4;
		o[5] = t5;
		o[6] = t6;
		o[7] = t7;
		o[8] = t8;
		o[9] = t9;
		o[10] = t10;
		o[11] = t11;
		o[12] = t12;
		o[13] = t13;
		o[14] = t14;
		o[15] = t15;
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/kem.js
var require_kem = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of RSA-KEM.
	*
	* @author Lautaro Cozzani Rodriguez
	* @author Dave Longley
	*
	* Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>
	* Copyright (c) 2014 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	require_random();
	require_jsbn();
	module.exports = forge.kem = forge.kem || {};
	var BigInteger = forge.jsbn.BigInteger;
	/**
	* The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.
	*/
	forge.kem.rsa = {};
	/**
	* Creates an RSA KEM API object for generating a secret asymmetric key.
	*
	* The symmetric key may be generated via a call to 'encrypt', which will
	* produce a ciphertext to be transmitted to the recipient and a key to be
	* kept secret. The ciphertext is a parameter to be passed to 'decrypt' which
	* will produce the same secret key for the recipient to use to decrypt a
	* message that was encrypted with the secret key.
	*
	* @param kdf the KDF API to use (eg: new forge.kem.kdf1()).
	* @param options the options to use.
	*          [prng] a custom crypto-secure pseudo-random number generator to use,
	*            that must define "getBytesSync".
	*/
	forge.kem.rsa.create = function(kdf, options) {
		options = options || {};
		var prng = options.prng || forge.random;
		var kem = {};
		/**
		* Generates a secret key and its encapsulation.
		*
		* @param publicKey the RSA public key to encrypt with.
		* @param keyLength the length, in bytes, of the secret key to generate.
		*
		* @return an object with:
		*   encapsulation: the ciphertext for generating the secret key, as a
		*     binary-encoded string of bytes.
		*   key: the secret key to use for encrypting a message.
		*/
		kem.encrypt = function(publicKey, keyLength) {
			var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
			var r;
			do
				r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n);
			while (r.compareTo(BigInteger.ONE) <= 0);
			r = forge.util.hexToBytes(r.toString(16));
			var zeros = byteLength - r.length;
			if (zeros > 0) r = forge.util.fillString(String.fromCharCode(0), zeros) + r;
			return {
				encapsulation: publicKey.encrypt(r, "NONE"),
				key: kdf.generate(r, keyLength)
			};
		};
		/**
		* Decrypts an encapsulated secret key.
		*
		* @param privateKey the RSA private key to decrypt with.
		* @param encapsulation the ciphertext for generating the secret key, as
		*          a binary-encoded string of bytes.
		* @param keyLength the length, in bytes, of the secret key to generate.
		*
		* @return the secret key as a binary-encoded string of bytes.
		*/
		kem.decrypt = function(privateKey, encapsulation, keyLength) {
			var r = privateKey.decrypt(encapsulation, "NONE");
			return kdf.generate(r, keyLength);
		};
		return kem;
	};
	/**
	* Creates a key derivation API object that implements KDF1 per ISO 18033-2.
	*
	* @param md the hash API to use.
	* @param [digestLength] an optional digest length that must be positive and
	*          less than or equal to md.digestLength.
	*
	* @return a KDF1 API object.
	*/
	forge.kem.kdf1 = function(md, digestLength) {
		_createKDF(this, md, 0, digestLength || md.digestLength);
	};
	/**
	* Creates a key derivation API object that implements KDF2 per ISO 18033-2.
	*
	* @param md the hash API to use.
	* @param [digestLength] an optional digest length that must be positive and
	*          less than or equal to md.digestLength.
	*
	* @return a KDF2 API object.
	*/
	forge.kem.kdf2 = function(md, digestLength) {
		_createKDF(this, md, 1, digestLength || md.digestLength);
	};
	/**
	* Creates a KDF1 or KDF2 API object.
	*
	* @param md the hash API to use.
	* @param counterStart the starting index for the counter.
	* @param digestLength the digest length to use.
	*
	* @return the KDF API object.
	*/
	function _createKDF(kdf, md, counterStart, digestLength) {
		/**
		* Generate a key of the specified length.
		*
		* @param x the binary-encoded byte string to generate a key from.
		* @param length the number of bytes to generate (the size of the key).
		*
		* @return the key as a binary-encoded string.
		*/
		kdf.generate = function(x, length) {
			var key = new forge.util.ByteBuffer();
			var k = Math.ceil(length / digestLength) + counterStart;
			var c = new forge.util.ByteBuffer();
			for (var i = counterStart; i < k; ++i) {
				c.putInt32(i);
				md.start();
				md.update(x + c.getBytes());
				var hash = md.digest();
				key.putBytes(hash.getBytes(digestLength));
			}
			key.truncate(key.length() - length);
			return key.getBytes();
		};
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/log.js
var require_log = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Cross-browser support for logging in a web application.
	*
	* @author David I. Lehn <dlehn@digitalbazaar.com>
	*
	* Copyright (c) 2008-2013 Digital Bazaar, Inc.
	*/
	var forge = require_forge();
	require_util();
	module.exports = forge.log = forge.log || {};
	/**
	* Application logging system.
	*
	* Each logger level available as it's own function of the form:
	*   forge.log.level(category, args...)
	* The category is an arbitrary string, and the args are the same as
	* Firebug's console.log API. By default the call will be output as:
	*   'LEVEL [category] <args[0]>, args[1], ...'
	* This enables proper % formatting via the first argument.
	* Each category is enabled by default but can be enabled or disabled with
	* the setCategoryEnabled() function.
	*/
	forge.log.levels = [
		"none",
		"error",
		"warning",
		"info",
		"debug",
		"verbose",
		"max"
	];
	var sLevelInfo = {};
	var sLoggers = [];
	/**
	* Standard console logger. If no console support is enabled this will
	* remain null. Check before using.
	*/
	var sConsoleLogger = null;
	/**
	* Lock the level at the current value. Used in cases where user config may
	* set the level such that only critical messages are seen but more verbose
	* messages are needed for debugging or other purposes.
	*/
	forge.log.LEVEL_LOCKED = 2;
	/**
	* Always call log function. By default, the logging system will check the
	* message level against logger.level before calling the log function. This
	* flag allows the function to do its own check.
	*/
	forge.log.NO_LEVEL_CHECK = 4;
	/**
	* Perform message interpolation with the passed arguments. "%" style
	* fields in log messages will be replaced by arguments as needed. Some
	* loggers, such as Firebug, may do this automatically. The original log
	* message will be available as 'message' and the interpolated version will
	* be available as 'fullMessage'.
	*/
	forge.log.INTERPOLATE = 8;
	for (var i = 0; i < forge.log.levels.length; ++i) {
		var level = forge.log.levels[i];
		sLevelInfo[level] = {
			index: i,
			name: level.toUpperCase()
		};
	}
	/**
	* Message logger. Will dispatch a message to registered loggers as needed.
	*
	* @param message message object
	*/
	forge.log.logMessage = function(message) {
		var messageLevelIndex = sLevelInfo[message.level].index;
		for (var i = 0; i < sLoggers.length; ++i) {
			var logger = sLoggers[i];
			if (logger.flags & forge.log.NO_LEVEL_CHECK) logger.f(message);
			else if (messageLevelIndex <= sLevelInfo[logger.level].index) logger.f(logger, message);
		}
	};
	/**
	* Sets the 'standard' key on a message object to:
	* "LEVEL [category] " + message
	*
	* @param message a message log object
	*/
	forge.log.prepareStandard = function(message) {
		if (!("standard" in message)) message.standard = sLevelInfo[message.level].name + " [" + message.category + "] " + message.message;
	};
	/**
	* Sets the 'full' key on a message object to the original message
	* interpolated via % formatting with the message arguments.
	*
	* @param message a message log object.
	*/
	forge.log.prepareFull = function(message) {
		if (!("full" in message)) {
			var args = [message.message];
			args = args.concat([]);
			message.full = forge.util.format.apply(this, args);
		}
	};
	/**
	* Applies both preparseStandard() and prepareFull() to a message object and
	* store result in 'standardFull'.
	*
	* @param message a message log object.
	*/
	forge.log.prepareStandardFull = function(message) {
		if (!("standardFull" in message)) {
			forge.log.prepareStandard(message);
			message.standardFull = message.standard;
		}
	};
	var levels = [
		"error",
		"warning",
		"info",
		"debug",
		"verbose"
	];
	for (var i = 0; i < levels.length; ++i) (function(level) {
		forge.log[level] = function(category, message) {
			var args = Array.prototype.slice.call(arguments).slice(2);
			var msg = {
				timestamp: /* @__PURE__ */ new Date(),
				level,
				category,
				message,
				"arguments": args
			};
			forge.log.logMessage(msg);
		};
	})(levels[i]);
	/**
	* Creates a new logger with specified custom logging function.
	*
	* The logging function has a signature of:
	*   function(logger, message)
	* logger: current logger
	* message: object:
	*   level: level id
	*   category: category
	*   message: string message
	*   arguments: Array of extra arguments
	*   fullMessage: interpolated message and arguments if INTERPOLATE flag set
	*
	* @param logFunction a logging function which takes a log message object
	*          as a parameter.
	*
	* @return a logger object.
	*/
	forge.log.makeLogger = function(logFunction) {
		var logger = {
			flags: 0,
			f: logFunction
		};
		forge.log.setLevel(logger, "none");
		return logger;
	};
	/**
	* Sets the current log level on a logger.
	*
	* @param logger the target logger.
	* @param level the new maximum log level as a string.
	*
	* @return true if set, false if not.
	*/
	forge.log.setLevel = function(logger, level) {
		var rval = false;
		if (logger && !(logger.flags & forge.log.LEVEL_LOCKED)) {
			for (var i = 0; i < forge.log.levels.length; ++i) if (level == forge.log.levels[i]) {
				logger.level = level;
				rval = true;
				break;
			}
		}
		return rval;
	};
	/**
	* Locks the log level at its current value.
	*
	* @param logger the target logger.
	* @param lock boolean lock value, default to true.
	*/
	forge.log.lock = function(logger, lock) {
		if (typeof lock === "undefined" || lock) logger.flags |= forge.log.LEVEL_LOCKED;
		else logger.flags &= ~forge.log.LEVEL_LOCKED;
	};
	/**
	* Adds a logger.
	*
	* @param logger the logger object.
	*/
	forge.log.addLogger = function(logger) {
		sLoggers.push(logger);
	};
	if (typeof console !== "undefined" && "log" in console) {
		var logger;
		if (console.error && console.warn && console.info && console.debug) {
			var levelHandlers = {
				error: console.error,
				warning: console.warn,
				info: console.info,
				debug: console.debug,
				verbose: console.debug
			};
			var f = function(logger, message) {
				forge.log.prepareStandard(message);
				var handler = levelHandlers[message.level];
				var args = [message.standard];
				args = args.concat(message["arguments"].slice());
				handler.apply(console, args);
			};
			logger = forge.log.makeLogger(f);
		} else {
			var f = function(logger, message) {
				forge.log.prepareStandardFull(message);
				console.log(message.standardFull);
			};
			logger = forge.log.makeLogger(f);
		}
		forge.log.setLevel(logger, "debug");
		forge.log.addLogger(logger);
		sConsoleLogger = logger;
	} else console = { log: function() {} };
	if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
		var query = new URL(window.location.href).searchParams;
		if (query.has("console.level")) forge.log.setLevel(sConsoleLogger, query.get("console.level").slice(-1)[0]);
		if (query.has("console.lock")) {
			if (query.get("console.lock").slice(-1)[0] == "true") forge.log.lock(sConsoleLogger);
		}
	}
	forge.log.consoleLogger = sConsoleLogger;
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/md.all.js
var require_md_all = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for all known Forge message digests.
	*
	* @author Dave Longley
	*
	* Copyright 2011-2017 Digital Bazaar, Inc.
	*/
	module.exports = require_md();
	require_md5();
	require_sha1();
	require_sha256();
	require_sha512();
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Javascript implementation of PKCS#7 v1.5.
	*
	* @author Stefan Siegl
	* @author Dave Longley
	*
	* Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
	* Copyright (c) 2012-2015 Digital Bazaar, Inc.
	*
	* Currently this implementation only supports ContentType of EnvelopedData,
	* EncryptedData, or SignedData at the root level. The top level elements may
	* contain only a ContentInfo of ContentType Data, i.e. plain data. Further
	* nesting is not (yet) supported.
	*
	* The Forge validators for PKCS #7's ASN.1 structures are available from
	* a separate file pkcs7asn1.js, since those are referenced from other
	* PKCS standards like PKCS #12.
	*/
	var forge = require_forge();
	require_aes();
	require_asn1();
	require_des();
	require_oids();
	require_pem();
	require_pkcs7asn1();
	require_random();
	require_util();
	require_x509();
	var asn1 = forge.asn1;
	var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};
	/**
	* Converts a PKCS#7 message from PEM format.
	*
	* @param pem the PEM-formatted PKCS#7 message.
	*
	* @return the PKCS#7 message.
	*/
	p7.messageFromPem = function(pem) {
		var msg = forge.pem.decode(pem)[0];
		if (msg.type !== "PKCS7") {
			var error = /* @__PURE__ */ new Error("Could not convert PKCS#7 message from PEM; PEM header type is not \"PKCS#7\".");
			error.headerType = msg.type;
			throw error;
		}
		if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
		var obj = asn1.fromDer(msg.body);
		return p7.messageFromAsn1(obj);
	};
	/**
	* Converts a PKCS#7 message to PEM format.
	*
	* @param msg The PKCS#7 message object
	* @param maxline The maximum characters per line, defaults to 64.
	*
	* @return The PEM-formatted PKCS#7 message.
	*/
	p7.messageToPem = function(msg, maxline) {
		var pemObj = {
			type: "PKCS7",
			body: asn1.toDer(msg.toAsn1()).getBytes()
		};
		return forge.pem.encode(pemObj, { maxline });
	};
	/**
	* Converts a PKCS#7 message from an ASN.1 object.
	*
	* @param obj the ASN.1 representation of a ContentInfo.
	*
	* @return the PKCS#7 message.
	*/
	p7.messageFromAsn1 = function(obj) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
			error.errors = errors;
			throw error;
		}
		var contentType = asn1.derToOid(capture.contentType);
		var msg;
		switch (contentType) {
			case forge.pki.oids.envelopedData:
				msg = p7.createEnvelopedData();
				break;
			case forge.pki.oids.encryptedData:
				msg = p7.createEncryptedData();
				break;
			case forge.pki.oids.signedData:
				msg = p7.createSignedData();
				break;
			default: throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
		}
		msg.fromAsn1(capture.content.value[0]);
		return msg;
	};
	p7.createSignedData = function() {
		var msg = null;
		msg = {
			type: forge.pki.oids.signedData,
			version: 1,
			certificates: [],
			crls: [],
			signers: [],
			digestAlgorithmIdentifiers: [],
			contentInfo: null,
			signerInfos: [],
			fromAsn1: function(obj) {
				_fromAsn1(msg, obj, p7.asn1.signedDataValidator);
				msg.certificates = [];
				msg.crls = [];
				msg.digestAlgorithmIdentifiers = [];
				msg.contentInfo = null;
				msg.signerInfos = [];
				if (msg.rawCapture.certificates) {
					var certs = msg.rawCapture.certificates.value;
					for (var i = 0; i < certs.length; ++i) msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
				}
			},
			toAsn1: function() {
				if (!msg.contentInfo) msg.sign();
				var certs = [];
				for (var i = 0; i < msg.certificates.length; ++i) certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
				var crls = [];
				var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),
					msg.contentInfo
				])]);
				if (certs.length > 0) signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
				if (crls.length > 0) signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
				signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
				return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), signedData]);
			},
			addSigner: function(signer) {
				var issuer = signer.issuer;
				var serialNumber = signer.serialNumber;
				if (signer.certificate) {
					var cert = signer.certificate;
					if (typeof cert === "string") cert = forge.pki.certificateFromPem(cert);
					issuer = cert.issuer.attributes;
					serialNumber = cert.serialNumber;
				}
				var key = signer.key;
				if (!key) throw new Error("Could not add PKCS#7 signer; no private key specified.");
				if (typeof key === "string") key = forge.pki.privateKeyFromPem(key);
				var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
				switch (digestAlgorithm) {
					case forge.pki.oids.sha1:
					case forge.pki.oids.sha256:
					case forge.pki.oids.sha384:
					case forge.pki.oids.sha512:
					case forge.pki.oids.md5: break;
					default: throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
				}
				var authenticatedAttributes = signer.authenticatedAttributes || [];
				if (authenticatedAttributes.length > 0) {
					var contentType = false;
					var messageDigest = false;
					for (var i = 0; i < authenticatedAttributes.length; ++i) {
						var attr = authenticatedAttributes[i];
						if (!contentType && attr.type === forge.pki.oids.contentType) {
							contentType = true;
							if (messageDigest) break;
							continue;
						}
						if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
							messageDigest = true;
							if (contentType) break;
							continue;
						}
					}
					if (!contentType || !messageDigest) throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
				}
				msg.signers.push({
					key,
					version: 1,
					issuer,
					serialNumber,
					digestAlgorithm,
					signatureAlgorithm: forge.pki.oids.rsaEncryption,
					signature: null,
					authenticatedAttributes,
					unauthenticatedAttributes: []
				});
			},
			sign: function(options) {
				options = options || {};
				if (typeof msg.content !== "object" || msg.contentInfo === null) {
					msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())]);
					if ("content" in msg) {
						var content;
						if (msg.content instanceof forge.util.ByteBuffer) content = msg.content.bytes();
						else if (typeof msg.content === "string") content = forge.util.encodeUtf8(msg.content);
						if (options.detached) msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
						else msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)]));
					}
				}
				if (msg.signers.length === 0) return;
				addSignerInfos(addDigestAlgorithmIds());
			},
			verify: function() {
				throw new Error("PKCS#7 signature verification not yet implemented.");
			},
			addCertificate: function(cert) {
				if (typeof cert === "string") cert = forge.pki.certificateFromPem(cert);
				msg.certificates.push(cert);
			},
			addCertificateRevokationList: function(crl) {
				throw new Error("PKCS#7 CRL support not yet implemented.");
			}
		};
		return msg;
		function addDigestAlgorithmIds() {
			var mds = {};
			for (var i = 0; i < msg.signers.length; ++i) {
				var signer = msg.signers[i];
				var oid = signer.digestAlgorithm;
				if (!(oid in mds)) mds[oid] = forge.md[forge.pki.oids[oid]].create();
				if (signer.authenticatedAttributes.length === 0) signer.md = mds[oid];
				else signer.md = forge.md[forge.pki.oids[oid]].create();
			}
			msg.digestAlgorithmIdentifiers = [];
			for (var oid in mds) msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]));
			return mds;
		}
		function addSignerInfos(mds) {
			var content;
			if (msg.detachedContent) content = msg.detachedContent;
			else {
				content = msg.contentInfo.value[1];
				content = content.value[0];
			}
			if (!content) throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
			var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
			var bytes = asn1.toDer(content);
			bytes.getByte();
			asn1.getBerValueLength(bytes);
			bytes = bytes.getBytes();
			for (var oid in mds) mds[oid].start().update(bytes);
			var signingTime = /* @__PURE__ */ new Date();
			for (var i = 0; i < msg.signers.length; ++i) {
				var signer = msg.signers[i];
				if (signer.authenticatedAttributes.length === 0) {
					if (contentType !== forge.pki.oids.data) throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
				} else {
					signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
					var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
					for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
						var attr = signer.authenticatedAttributes[ai];
						if (attr.type === forge.pki.oids.messageDigest) attr.value = mds[signer.digestAlgorithm].digest();
						else if (attr.type === forge.pki.oids.signingTime) {
							if (!attr.value) attr.value = signingTime;
						}
						attrsAsn1.value.push(_attributeToAsn1(attr));
						signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
					}
					bytes = asn1.toDer(attrsAsn1).getBytes();
					signer.md.start().update(bytes);
				}
				signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
			}
			msg.signerInfos = _signersToAsn1(msg.signers);
		}
	};
	/**
	* Creates an empty PKCS#7 message of type EncryptedData.
	*
	* @return the message.
	*/
	p7.createEncryptedData = function() {
		var msg = null;
		msg = {
			type: forge.pki.oids.encryptedData,
			version: 0,
			encryptedContent: { algorithm: forge.pki.oids["aes256-CBC"] },
			fromAsn1: function(obj) {
				_fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
			},
			decrypt: function(key) {
				if (key !== void 0) msg.encryptedContent.key = key;
				_decryptContent(msg);
			}
		};
		return msg;
	};
	/**
	* Creates an empty PKCS#7 message of type EnvelopedData.
	*
	* @return the message.
	*/
	p7.createEnvelopedData = function() {
		var msg = null;
		msg = {
			type: forge.pki.oids.envelopedData,
			version: 0,
			recipients: [],
			encryptedContent: { algorithm: forge.pki.oids["aes256-CBC"] },
			fromAsn1: function(obj) {
				var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
				msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
			},
			toAsn1: function() {
				return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),
					asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))
				])])]);
			},
			findRecipient: function(cert) {
				var sAttr = cert.issuer.attributes;
				for (var i = 0; i < msg.recipients.length; ++i) {
					var r = msg.recipients[i];
					var rAttr = r.issuer;
					if (r.serialNumber !== cert.serialNumber) continue;
					if (rAttr.length !== sAttr.length) continue;
					var match = true;
					for (var j = 0; j < sAttr.length; ++j) if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
						match = false;
						break;
					}
					if (match) return r;
				}
				return null;
			},
			decrypt: function(recipient, privKey) {
				if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) switch (recipient.encryptedContent.algorithm) {
					case forge.pki.oids.rsaEncryption:
					case forge.pki.oids.desCBC:
						var key = privKey.decrypt(recipient.encryptedContent.content);
						msg.encryptedContent.key = forge.util.createBuffer(key);
						break;
					default: throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
				}
				_decryptContent(msg);
			},
			addRecipient: function(cert) {
				msg.recipients.push({
					version: 0,
					issuer: cert.issuer.attributes,
					serialNumber: cert.serialNumber,
					encryptedContent: {
						algorithm: forge.pki.oids.rsaEncryption,
						key: cert.publicKey
					}
				});
			},
			encrypt: function(key, cipher) {
				if (msg.encryptedContent.content === void 0) {
					cipher = cipher || msg.encryptedContent.algorithm;
					key = key || msg.encryptedContent.key;
					var keyLen, ivLen, ciphFn;
					switch (cipher) {
						case forge.pki.oids["aes128-CBC"]:
							keyLen = 16;
							ivLen = 16;
							ciphFn = forge.aes.createEncryptionCipher;
							break;
						case forge.pki.oids["aes192-CBC"]:
							keyLen = 24;
							ivLen = 16;
							ciphFn = forge.aes.createEncryptionCipher;
							break;
						case forge.pki.oids["aes256-CBC"]:
							keyLen = 32;
							ivLen = 16;
							ciphFn = forge.aes.createEncryptionCipher;
							break;
						case forge.pki.oids["des-EDE3-CBC"]:
							keyLen = 24;
							ivLen = 8;
							ciphFn = forge.des.createEncryptionCipher;
							break;
						default: throw new Error("Unsupported symmetric cipher, OID " + cipher);
					}
					if (key === void 0) key = forge.util.createBuffer(forge.random.getBytes(keyLen));
					else if (key.length() != keyLen) throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
					msg.encryptedContent.algorithm = cipher;
					msg.encryptedContent.key = key;
					msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
					var ciph = ciphFn(key);
					ciph.start(msg.encryptedContent.parameter.copy());
					ciph.update(msg.content);
					if (!ciph.finish()) throw new Error("Symmetric encryption failed.");
					msg.encryptedContent.content = ciph.output;
				}
				for (var i = 0; i < msg.recipients.length; ++i) {
					var recipient = msg.recipients[i];
					if (recipient.encryptedContent.content !== void 0) continue;
					switch (recipient.encryptedContent.algorithm) {
						case forge.pki.oids.rsaEncryption:
							recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
							break;
						default: throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
					}
				}
			}
		};
		return msg;
	};
	/**
	* Converts a single recipient from an ASN.1 object.
	*
	* @param obj the ASN.1 RecipientInfo.
	*
	* @return the recipient object.
	*/
	function _recipientFromAsn1(obj) {
		var capture = {};
		var errors = [];
		if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
			var error = /* @__PURE__ */ new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
			error.errors = errors;
			throw error;
		}
		return {
			version: capture.version.charCodeAt(0),
			issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
			serialNumber: forge.util.createBuffer(capture.serial).toHex(),
			encryptedContent: {
				algorithm: asn1.derToOid(capture.encAlgorithm),
				parameter: capture.encParameter ? capture.encParameter.value : void 0,
				content: capture.encKey
			}
		};
	}
	/**
	* Converts a single recipient object to an ASN.1 object.
	*
	* @param obj the recipient object.
	*
	* @return the ASN.1 RecipientInfo.
	*/
	function _recipientToAsn1(obj) {
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)
		]);
	}
	/**
	* Map a set of RecipientInfo ASN.1 objects to recipient objects.
	*
	* @param infos an array of ASN.1 representations RecipientInfo (i.e. SET OF).
	*
	* @return an array of recipient objects.
	*/
	function _recipientsFromAsn1(infos) {
		var ret = [];
		for (var i = 0; i < infos.length; ++i) ret.push(_recipientFromAsn1(infos[i]));
		return ret;
	}
	/**
	* Map an array of recipient objects to ASN.1 RecipientInfo objects.
	*
	* @param recipients an array of recipientInfo objects.
	*
	* @return an array of ASN.1 RecipientInfos.
	*/
	function _recipientsToAsn1(recipients) {
		var ret = [];
		for (var i = 0; i < recipients.length; ++i) ret.push(_recipientToAsn1(recipients[i]));
		return ret;
	}
	/**
	* Converts a single signerInfo object to an ASN.1 object.
	*
	* @param obj the signerInfo object.
	*
	* @return the ASN.1 representation of a SignerInfo.
	*/
	function _signerToAsn1(obj) {
		var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])
		]);
		if (obj.authenticatedAttributesAsn1) rval.value.push(obj.authenticatedAttributesAsn1);
		rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]));
		rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
		if (obj.unauthenticatedAttributes.length > 0) {
			var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
			for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
				var attr = obj.unauthenticatedAttributes[i];
				attrsAsn1.values.push(_attributeToAsn1(attr));
			}
			rval.value.push(attrsAsn1);
		}
		return rval;
	}
	/**
	* Map an array of signer objects to ASN.1 objects.
	*
	* @param signers an array of signer objects.
	*
	* @return an array of ASN.1 SignerInfos.
	*/
	function _signersToAsn1(signers) {
		var ret = [];
		for (var i = 0; i < signers.length; ++i) ret.push(_signerToAsn1(signers[i]));
		return ret;
	}
	/**
	* Convert an attribute object to an ASN.1 Attribute.
	*
	* @param attr the attribute object.
	*
	* @return the ASN.1 Attribute.
	*/
	function _attributeToAsn1(attr) {
		var value;
		if (attr.type === forge.pki.oids.contentType) value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
		else if (attr.type === forge.pki.oids.messageDigest) value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
		else if (attr.type === forge.pki.oids.signingTime) {
			var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
			var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
			var date = attr.value;
			if (typeof date === "string") {
				var timestamp = Date.parse(date);
				if (!isNaN(timestamp)) date = new Date(timestamp);
				else if (date.length === 13) date = asn1.utcTimeToDate(date);
				else date = asn1.generalizedTimeToDate(date);
			}
			if (date >= jan_1_1950 && date < jan_1_2050) value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
			else value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
		}
		return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [value])]);
	}
	/**
	* Map messages encrypted content to ASN.1 objects.
	*
	* @param ec The encryptedContent object of the message.
	*
	* @return ASN.1 representation of the encryptedContent object (SEQUENCE).
	*/
	function _encryptedContentToAsn1(ec) {
		return [
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()),
			asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()), !ec.parameter ? void 0 : asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())]),
			asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())])
		];
	}
	/**
	* Reads the "common part" of an PKCS#7 content block (in ASN.1 format)
	*
	* This function reads the "common part" of the PKCS#7 content blocks
	* EncryptedData and EnvelopedData, i.e. version number and symmetrically
	* encrypted content block.
	*
	* The result of the ASN.1 validate and capture process is returned
	* to allow the caller to extract further data, e.g. the list of recipients
	* in case of a EnvelopedData object.
	*
	* @param msg the PKCS#7 object to read the data to.
	* @param obj the ASN.1 representation of the content block.
	* @param validator the ASN.1 structure validator object to use.
	*
	* @return the value map captured by validator object.
	*/
	function _fromAsn1(msg, obj, validator) {
		var capture = {};
		if (!asn1.validate(obj, validator, capture, [])) {
			var error = /* @__PURE__ */ new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
			error.errors = error;
			throw error;
		}
		if (asn1.derToOid(capture.contentType) !== forge.pki.oids.data) throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
		if (capture.encryptedContent) {
			var content = "";
			if (forge.util.isArray(capture.encryptedContent)) for (var i = 0; i < capture.encryptedContent.length; ++i) {
				if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
				content += capture.encryptedContent[i].value;
			}
			else content = capture.encryptedContent;
			msg.encryptedContent = {
				algorithm: asn1.derToOid(capture.encAlgorithm),
				parameter: forge.util.createBuffer(capture.encParameter.value),
				content: forge.util.createBuffer(content)
			};
		}
		if (capture.content) {
			var content = "";
			if (forge.util.isArray(capture.content)) for (var i = 0; i < capture.content.length; ++i) {
				if (capture.content[i].type !== asn1.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
				content += capture.content[i].value;
			}
			else content = capture.content;
			msg.content = forge.util.createBuffer(content);
		}
		msg.version = capture.version.charCodeAt(0);
		msg.rawCapture = capture;
		return capture;
	}
	/**
	* Decrypt the symmetrically encrypted content block of the PKCS#7 message.
	*
	* Decryption is skipped in case the PKCS#7 message object already has a
	* (decrypted) content attribute.  The algorithm, key and cipher parameters
	* (probably the iv) are taken from the encryptedContent attribute of the
	* message object.
	*
	* @param The PKCS#7 message object.
	*/
	function _decryptContent(msg) {
		if (msg.encryptedContent.key === void 0) throw new Error("Symmetric key not available.");
		if (msg.content === void 0) {
			var ciph;
			switch (msg.encryptedContent.algorithm) {
				case forge.pki.oids["aes128-CBC"]:
				case forge.pki.oids["aes192-CBC"]:
				case forge.pki.oids["aes256-CBC"]:
					ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
					break;
				case forge.pki.oids["desCBC"]:
				case forge.pki.oids["des-EDE3-CBC"]:
					ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
					break;
				default: throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
			}
			ciph.start(msg.encryptedContent.parameter);
			ciph.update(msg.encryptedContent.content);
			if (!ciph.finish()) throw new Error("Symmetric decryption failed.");
			msg.content = ciph.output;
		}
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/ssh.js
var require_ssh = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Functions to output keys in SSH-friendly formats.
	*
	* This is part of the Forge project which may be used under the terms of
	* either the BSD License or the GNU General Public License (GPL) Version 2.
	*
	* See: https://github.com/digitalbazaar/forge/blob/cbebca3780658703d925b61b2caffb1d263a6c1d/LICENSE
	*
	* @author https://github.com/shellac
	*/
	var forge = require_forge();
	require_aes();
	require_hmac();
	require_md5();
	require_sha1();
	require_util();
	var ssh = module.exports = forge.ssh = forge.ssh || {};
	/**
	* Encodes (and optionally encrypts) a private RSA key as a Putty PPK file.
	*
	* @param privateKey the key.
	* @param passphrase a passphrase to protect the key (falsy for no encryption).
	* @param comment a comment to include in the key file.
	*
	* @return the PPK file as a string.
	*/
	ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
		comment = comment || "";
		passphrase = passphrase || "";
		var algorithm = "ssh-rsa";
		var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
		var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
		ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
		ppk += "Comment: " + comment + "\r\n";
		var pubbuffer = forge.util.createBuffer();
		_addStringToBuffer(pubbuffer, algorithm);
		_addBigIntegerToBuffer(pubbuffer, privateKey.e);
		_addBigIntegerToBuffer(pubbuffer, privateKey.n);
		var pub = forge.util.encode64(pubbuffer.bytes(), 64);
		var length = Math.floor(pub.length / 66) + 1;
		ppk += "Public-Lines: " + length + "\r\n";
		ppk += pub;
		var privbuffer = forge.util.createBuffer();
		_addBigIntegerToBuffer(privbuffer, privateKey.d);
		_addBigIntegerToBuffer(privbuffer, privateKey.p);
		_addBigIntegerToBuffer(privbuffer, privateKey.q);
		_addBigIntegerToBuffer(privbuffer, privateKey.qInv);
		var priv;
		if (!passphrase) priv = forge.util.encode64(privbuffer.bytes(), 64);
		else {
			var encLen = privbuffer.length() + 16 - 1;
			encLen -= encLen % 16;
			var padding = _sha1(privbuffer.bytes());
			padding.truncate(padding.length() - encLen + privbuffer.length());
			privbuffer.putBuffer(padding);
			var aeskey = forge.util.createBuffer();
			aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
			aeskey.putBuffer(_sha1("\0\0\0", passphrase));
			var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
			cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
			cipher.update(privbuffer.copy());
			cipher.finish();
			var encrypted = cipher.output;
			encrypted.truncate(16);
			priv = forge.util.encode64(encrypted.bytes(), 64);
		}
		length = Math.floor(priv.length / 66) + 1;
		ppk += "\r\nPrivate-Lines: " + length + "\r\n";
		ppk += priv;
		var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
		var macbuffer = forge.util.createBuffer();
		_addStringToBuffer(macbuffer, algorithm);
		_addStringToBuffer(macbuffer, encryptionAlgorithm);
		_addStringToBuffer(macbuffer, comment);
		macbuffer.putInt32(pubbuffer.length());
		macbuffer.putBuffer(pubbuffer);
		macbuffer.putInt32(privbuffer.length());
		macbuffer.putBuffer(privbuffer);
		var hmac = forge.hmac.create();
		hmac.start("sha1", mackey);
		hmac.update(macbuffer.bytes());
		ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
		return ppk;
	};
	/**
	* Encodes a public RSA key as an OpenSSH file.
	*
	* @param key the key.
	* @param comment a comment.
	*
	* @return the public key in OpenSSH format.
	*/
	ssh.publicKeyToOpenSSH = function(key, comment) {
		var type = "ssh-rsa";
		comment = comment || "";
		var buffer = forge.util.createBuffer();
		_addStringToBuffer(buffer, type);
		_addBigIntegerToBuffer(buffer, key.e);
		_addBigIntegerToBuffer(buffer, key.n);
		return type + " " + forge.util.encode64(buffer.bytes()) + " " + comment;
	};
	/**
	* Encodes a private RSA key as an OpenSSH file.
	*
	* @param key the key.
	* @param passphrase a passphrase to protect the key (falsy for no encryption).
	*
	* @return the public key in OpenSSH format.
	*/
	ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
		if (!passphrase) return forge.pki.privateKeyToPem(privateKey);
		return forge.pki.encryptRsaPrivateKey(privateKey, passphrase, {
			legacy: true,
			algorithm: "aes128"
		});
	};
	/**
	* Gets the SSH fingerprint for the given public key.
	*
	* @param options the options to use.
	*          [md] the message digest object to use (defaults to forge.md.md5).
	*          [encoding] an alternative output encoding, such as 'hex'
	*            (defaults to none, outputs a byte buffer).
	*          [delimiter] the delimiter to use between bytes for 'hex' encoded
	*            output, eg: ':' (defaults to none).
	*
	* @return the fingerprint as a byte buffer or other encoding based on options.
	*/
	ssh.getPublicKeyFingerprint = function(key, options) {
		options = options || {};
		var md = options.md || forge.md.md5.create();
		var type = "ssh-rsa";
		var buffer = forge.util.createBuffer();
		_addStringToBuffer(buffer, type);
		_addBigIntegerToBuffer(buffer, key.e);
		_addBigIntegerToBuffer(buffer, key.n);
		md.start();
		md.update(buffer.getBytes());
		var digest = md.digest();
		if (options.encoding === "hex") {
			var hex = digest.toHex();
			if (options.delimiter) return hex.match(/.{2}/g).join(options.delimiter);
			return hex;
		} else if (options.encoding === "binary") return digest.getBytes();
		else if (options.encoding) throw new Error("Unknown encoding \"" + options.encoding + "\".");
		return digest;
	};
	/**
	* Adds len(val) then val to a buffer.
	*
	* @param buffer the buffer to add to.
	* @param val a big integer.
	*/
	function _addBigIntegerToBuffer(buffer, val) {
		var hexVal = val.toString(16);
		if (hexVal[0] >= "8") hexVal = "00" + hexVal;
		var bytes = forge.util.hexToBytes(hexVal);
		buffer.putInt32(bytes.length);
		buffer.putBytes(bytes);
	}
	/**
	* Adds len(val) then val to a buffer.
	*
	* @param buffer the buffer to add to.
	* @param val a string.
	*/
	function _addStringToBuffer(buffer, val) {
		buffer.putInt32(val.length);
		buffer.putString(val);
	}
	/**
	* Hashes the arguments into one value using SHA-1.
	*
	* @return the sha1 hash of the provided arguments.
	*/
	function _sha1() {
		var sha = forge.md.sha1.create();
		var num = arguments.length;
		for (var i = 0; i < num; ++i) sha.update(arguments[i]);
		return sha.digest();
	}
}));

//#endregion
//#region ../../node_modules/.pnpm/node-forge@1.3.3/node_modules/node-forge/lib/index.js
var require_lib = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Node.js module for Forge.
	*
	* @author Dave Longley
	*
	* Copyright 2011-2016 Digital Bazaar, Inc.
	*/
	module.exports = require_forge();
	require_aes();
	require_aesCipherSuites();
	require_asn1();
	require_cipher();
	require_des();
	require_ed25519();
	require_hmac();
	require_kem();
	require_log();
	require_md_all();
	require_mgf1();
	require_pbkdf2();
	require_pem();
	require_pkcs1();
	require_pkcs12();
	require_pkcs7();
	require_pki();
	require_prime();
	require_prng();
	require_pss();
	require_random();
	require_rc2();
	require_ssh();
	require_tls();
	require_util();
}));

//#endregion
//#region ../../node_modules/.pnpm/acorn@8.15.0/node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [
	509,
	0,
	227,
	0,
	150,
	4,
	294,
	9,
	1368,
	2,
	2,
	1,
	6,
	3,
	41,
	2,
	5,
	0,
	166,
	1,
	574,
	3,
	9,
	9,
	7,
	9,
	32,
	4,
	318,
	1,
	80,
	3,
	71,
	10,
	50,
	3,
	123,
	2,
	54,
	14,
	32,
	10,
	3,
	1,
	11,
	3,
	46,
	10,
	8,
	0,
	46,
	9,
	7,
	2,
	37,
	13,
	2,
	9,
	6,
	1,
	45,
	0,
	13,
	2,
	49,
	13,
	9,
	3,
	2,
	11,
	83,
	11,
	7,
	0,
	3,
	0,
	158,
	11,
	6,
	9,
	7,
	3,
	56,
	1,
	2,
	6,
	3,
	1,
	3,
	2,
	10,
	0,
	11,
	1,
	3,
	6,
	4,
	4,
	68,
	8,
	2,
	0,
	3,
	0,
	2,
	3,
	2,
	4,
	2,
	0,
	15,
	1,
	83,
	17,
	10,
	9,
	5,
	0,
	82,
	19,
	13,
	9,
	214,
	6,
	3,
	8,
	28,
	1,
	83,
	16,
	16,
	9,
	82,
	12,
	9,
	9,
	7,
	19,
	58,
	14,
	5,
	9,
	243,
	14,
	166,
	9,
	71,
	5,
	2,
	1,
	3,
	3,
	2,
	0,
	2,
	1,
	13,
	9,
	120,
	6,
	3,
	6,
	4,
	0,
	29,
	9,
	41,
	6,
	2,
	3,
	9,
	0,
	10,
	10,
	47,
	15,
	343,
	9,
	54,
	7,
	2,
	7,
	17,
	9,
	57,
	21,
	2,
	13,
	123,
	5,
	4,
	0,
	2,
	1,
	2,
	6,
	2,
	0,
	9,
	9,
	49,
	4,
	2,
	1,
	2,
	4,
	9,
	9,
	330,
	3,
	10,
	1,
	2,
	0,
	49,
	6,
	4,
	4,
	14,
	10,
	5350,
	0,
	7,
	14,
	11465,
	27,
	2343,
	9,
	87,
	9,
	39,
	4,
	60,
	6,
	26,
	9,
	535,
	9,
	470,
	0,
	2,
	54,
	8,
	3,
	82,
	0,
	12,
	1,
	19628,
	1,
	4178,
	9,
	519,
	45,
	3,
	22,
	543,
	4,
	4,
	5,
	9,
	7,
	3,
	6,
	31,
	3,
	149,
	2,
	1418,
	49,
	513,
	54,
	5,
	49,
	9,
	0,
	15,
	0,
	23,
	4,
	2,
	14,
	1361,
	6,
	2,
	16,
	3,
	6,
	2,
	1,
	2,
	4,
	101,
	0,
	161,
	6,
	10,
	9,
	357,
	0,
	62,
	13,
	499,
	13,
	245,
	1,
	2,
	9,
	726,
	6,
	110,
	6,
	6,
	9,
	4759,
	9,
	787719,
	239
];
var astralIdentifierStartCodes = [
	0,
	11,
	2,
	25,
	2,
	18,
	2,
	1,
	2,
	14,
	3,
	13,
	35,
	122,
	70,
	52,
	268,
	28,
	4,
	48,
	48,
	31,
	14,
	29,
	6,
	37,
	11,
	29,
	3,
	35,
	5,
	7,
	2,
	4,
	43,
	157,
	19,
	35,
	5,
	35,
	5,
	39,
	9,
	51,
	13,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	2,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	4,
	51,
	13,
	310,
	10,
	21,
	11,
	7,
	25,
	5,
	2,
	41,
	2,
	8,
	70,
	5,
	3,
	0,
	2,
	43,
	2,
	1,
	4,
	0,
	3,
	22,
	11,
	22,
	10,
	30,
	66,
	18,
	2,
	1,
	11,
	21,
	11,
	25,
	71,
	55,
	7,
	1,
	65,
	0,
	16,
	3,
	2,
	2,
	2,
	28,
	43,
	28,
	4,
	28,
	36,
	7,
	2,
	27,
	28,
	53,
	11,
	21,
	11,
	18,
	14,
	17,
	111,
	72,
	56,
	50,
	14,
	50,
	14,
	35,
	39,
	27,
	10,
	22,
	251,
	41,
	7,
	1,
	17,
	2,
	60,
	28,
	11,
	0,
	9,
	21,
	43,
	17,
	47,
	20,
	28,
	22,
	13,
	52,
	58,
	1,
	3,
	0,
	14,
	44,
	33,
	24,
	27,
	35,
	30,
	0,
	3,
	0,
	9,
	34,
	4,
	0,
	13,
	47,
	15,
	3,
	22,
	0,
	2,
	0,
	36,
	17,
	2,
	24,
	20,
	1,
	64,
	6,
	2,
	0,
	2,
	3,
	2,
	14,
	2,
	9,
	8,
	46,
	39,
	7,
	3,
	1,
	3,
	21,
	2,
	6,
	2,
	1,
	2,
	4,
	4,
	0,
	19,
	0,
	13,
	4,
	31,
	9,
	2,
	0,
	3,
	0,
	2,
	37,
	2,
	0,
	26,
	0,
	2,
	0,
	45,
	52,
	19,
	3,
	21,
	2,
	31,
	47,
	21,
	1,
	2,
	0,
	185,
	46,
	42,
	3,
	37,
	47,
	21,
	0,
	60,
	42,
	14,
	0,
	72,
	26,
	38,
	6,
	186,
	43,
	117,
	63,
	32,
	7,
	3,
	0,
	3,
	7,
	2,
	1,
	2,
	23,
	16,
	0,
	2,
	0,
	95,
	7,
	3,
	38,
	17,
	0,
	2,
	0,
	29,
	0,
	11,
	39,
	8,
	0,
	22,
	0,
	12,
	45,
	20,
	0,
	19,
	72,
	200,
	32,
	32,
	8,
	2,
	36,
	18,
	0,
	50,
	29,
	113,
	6,
	2,
	1,
	2,
	37,
	22,
	0,
	26,
	5,
	2,
	1,
	2,
	31,
	15,
	0,
	328,
	18,
	16,
	0,
	2,
	12,
	2,
	33,
	125,
	0,
	80,
	921,
	103,
	110,
	18,
	195,
	2637,
	96,
	16,
	1071,
	18,
	5,
	26,
	3994,
	6,
	582,
	6842,
	29,
	1763,
	568,
	8,
	30,
	18,
	78,
	18,
	29,
	19,
	47,
	17,
	3,
	32,
	20,
	6,
	18,
	433,
	44,
	212,
	63,
	129,
	74,
	6,
	0,
	67,
	12,
	65,
	1,
	2,
	0,
	29,
	6135,
	9,
	1237,
	42,
	9,
	8936,
	3,
	2,
	6,
	2,
	1,
	2,
	290,
	16,
	0,
	30,
	2,
	3,
	0,
	15,
	3,
	9,
	395,
	2309,
	106,
	6,
	12,
	4,
	8,
	8,
	9,
	5991,
	84,
	2,
	70,
	2,
	1,
	3,
	0,
	3,
	1,
	3,
	3,
	2,
	11,
	2,
	0,
	2,
	6,
	2,
	64,
	2,
	3,
	3,
	7,
	2,
	6,
	2,
	27,
	2,
	3,
	2,
	4,
	2,
	0,
	4,
	6,
	2,
	339,
	3,
	24,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	7,
	1845,
	30,
	7,
	5,
	262,
	61,
	147,
	44,
	11,
	6,
	17,
	0,
	322,
	29,
	19,
	43,
	485,
	27,
	229,
	29,
	3,
	0,
	496,
	6,
	2,
	3,
	2,
	1,
	2,
	14,
	2,
	196,
	60,
	67,
	8,
	0,
	1205,
	3,
	2,
	26,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	9,
	2,
	3,
	2,
	0,
	2,
	0,
	7,
	0,
	5,
	0,
	2,
	0,
	2,
	0,
	2,
	2,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	1,
	2,
	0,
	3,
	3,
	2,
	6,
	2,
	3,
	2,
	3,
	2,
	0,
	2,
	9,
	2,
	16,
	6,
	2,
	2,
	4,
	2,
	16,
	4421,
	42719,
	33,
	4153,
	7,
	221,
	3,
	5761,
	15,
	7472,
	16,
	621,
	2467,
	541,
	1507,
	4938,
	6,
	4191
];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
	3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	5: "class enum extends super const export import",
	6: "enum",
	strict: "implements interface let package private protected public static yield",
	strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
	5: ecma5AndLessKeywords,
	"5module": ecma5AndLessKeywords + " export import",
	6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set) {
	var pos = 65536;
	for (var i = 0; i < set.length; i += 2) {
		pos += set[i];
		if (pos > code) return false;
		pos += set[i + 1];
		if (pos >= code) return true;
	}
	return false;
}
function isIdentifierStart(code, astral) {
	if (code < 65) return code === 36;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
	if (code < 48) return code === 36;
	if (code < 58) return true;
	if (code < 65) return false;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType(label, conf) {
	if (conf === void 0) conf = {};
	this.label = label;
	this.keyword = conf.keyword;
	this.beforeExpr = !!conf.beforeExpr;
	this.startsExpr = !!conf.startsExpr;
	this.isLoop = !!conf.isLoop;
	this.isAssign = !!conf.isAssign;
	this.prefix = !!conf.prefix;
	this.postfix = !!conf.postfix;
	this.binop = conf.binop || null;
	this.updateContext = null;
};
function binop(name, prec) {
	return new TokenType(name, {
		beforeExpr: true,
		binop: prec
	});
}
var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
	if (options === void 0) options = {};
	options.keyword = name;
	return keywords[name] = new TokenType(name, options);
}
var types$1 = {
	num: new TokenType("num", startsExpr),
	regexp: new TokenType("regexp", startsExpr),
	string: new TokenType("string", startsExpr),
	name: new TokenType("name", startsExpr),
	privateId: new TokenType("privateId", startsExpr),
	eof: new TokenType("eof"),
	bracketL: new TokenType("[", {
		beforeExpr: true,
		startsExpr: true
	}),
	bracketR: new TokenType("]"),
	braceL: new TokenType("{", {
		beforeExpr: true,
		startsExpr: true
	}),
	braceR: new TokenType("}"),
	parenL: new TokenType("(", {
		beforeExpr: true,
		startsExpr: true
	}),
	parenR: new TokenType(")"),
	comma: new TokenType(",", beforeExpr),
	semi: new TokenType(";", beforeExpr),
	colon: new TokenType(":", beforeExpr),
	dot: new TokenType("."),
	question: new TokenType("?", beforeExpr),
	questionDot: new TokenType("?."),
	arrow: new TokenType("=>", beforeExpr),
	template: new TokenType("template"),
	invalidTemplate: new TokenType("invalidTemplate"),
	ellipsis: new TokenType("...", beforeExpr),
	backQuote: new TokenType("`", startsExpr),
	dollarBraceL: new TokenType("${", {
		beforeExpr: true,
		startsExpr: true
	}),
	eq: new TokenType("=", {
		beforeExpr: true,
		isAssign: true
	}),
	assign: new TokenType("_=", {
		beforeExpr: true,
		isAssign: true
	}),
	incDec: new TokenType("++/--", {
		prefix: true,
		postfix: true,
		startsExpr: true
	}),
	prefix: new TokenType("!/~", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	logicalOR: binop("||", 1),
	logicalAND: binop("&&", 2),
	bitwiseOR: binop("|", 3),
	bitwiseXOR: binop("^", 4),
	bitwiseAND: binop("&", 5),
	equality: binop("==/!=/===/!==", 6),
	relational: binop("</>/<=/>=", 7),
	bitShift: binop("<</>>/>>>", 8),
	plusMin: new TokenType("+/-", {
		beforeExpr: true,
		binop: 9,
		prefix: true,
		startsExpr: true
	}),
	modulo: binop("%", 10),
	star: binop("*", 10),
	slash: binop("/", 10),
	starstar: new TokenType("**", { beforeExpr: true }),
	coalesce: binop("??", 1),
	_break: kw("break"),
	_case: kw("case", beforeExpr),
	_catch: kw("catch"),
	_continue: kw("continue"),
	_debugger: kw("debugger"),
	_default: kw("default", beforeExpr),
	_do: kw("do", {
		isLoop: true,
		beforeExpr: true
	}),
	_else: kw("else", beforeExpr),
	_finally: kw("finally"),
	_for: kw("for", { isLoop: true }),
	_function: kw("function", startsExpr),
	_if: kw("if"),
	_return: kw("return", beforeExpr),
	_switch: kw("switch"),
	_throw: kw("throw", beforeExpr),
	_try: kw("try"),
	_var: kw("var"),
	_const: kw("const"),
	_while: kw("while", { isLoop: true }),
	_with: kw("with"),
	_new: kw("new", {
		beforeExpr: true,
		startsExpr: true
	}),
	_this: kw("this", startsExpr),
	_super: kw("super", startsExpr),
	_class: kw("class", startsExpr),
	_extends: kw("extends", beforeExpr),
	_export: kw("export"),
	_import: kw("import", startsExpr),
	_null: kw("null", startsExpr),
	_true: kw("true", startsExpr),
	_false: kw("false", startsExpr),
	_in: kw("in", {
		beforeExpr: true,
		binop: 7
	}),
	_instanceof: kw("instanceof", {
		beforeExpr: true,
		binop: 7
	}),
	_typeof: kw("typeof", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_void: kw("void", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_delete: kw("delete", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	})
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
	return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
	if (end === void 0) end = code.length;
	for (var i = from; i < end; i++) {
		var next = code.charCodeAt(i);
		if (isNewLine(next)) return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
	}
	return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty$2 = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || (function(obj, propName) {
	return hasOwnProperty$2.call(obj, propName);
});
var isArray$1 = Array.isArray || (function(obj) {
	return toString.call(obj) === "[object Array]";
});
var regexpCache = Object.create(null);
function wordsRegexp(words) {
	return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
	if (code <= 65535) return String.fromCharCode(code);
	code -= 65536;
	return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position(line, col) {
	this.line = line;
	this.column = col;
};
Position.prototype.offset = function offset(n) {
	return new Position(this.line, this.column + n);
};
var SourceLocation = function SourceLocation(p, start, end) {
	this.start = start;
	this.end = end;
	if (p.sourceFile !== null) this.source = p.sourceFile;
};
function getLineInfo(input, offset) {
	for (var line = 1, cur = 0;;) {
		var nextBreak = nextLineBreak(input, cur, offset);
		if (nextBreak < 0) return new Position(line, offset - cur);
		++line;
		cur = nextBreak;
	}
}
var defaultOptions = {
	ecmaVersion: null,
	sourceType: "script",
	onInsertedSemicolon: null,
	onTrailingComma: null,
	allowReserved: null,
	allowReturnOutsideFunction: false,
	allowImportExportEverywhere: false,
	allowAwaitOutsideFunction: null,
	allowSuperOutsideMethod: null,
	allowHashBang: false,
	checkPrivateFields: true,
	locations: false,
	onToken: null,
	onComment: null,
	ranges: false,
	program: null,
	sourceFile: null,
	directSourceFile: null,
	preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
	var options = {};
	for (var opt in defaultOptions) options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
	if (options.ecmaVersion === "latest") options.ecmaVersion = 1e8;
	else if (options.ecmaVersion == null) {
		if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
			warnedAboutEcmaVersion = true;
			console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
		}
		options.ecmaVersion = 11;
	} else if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;
	if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
	if (!opts || opts.allowHashBang == null) options.allowHashBang = options.ecmaVersion >= 14;
	if (isArray$1(options.onToken)) {
		var tokens = options.onToken;
		options.onToken = function(token) {
			return tokens.push(token);
		};
	}
	if (isArray$1(options.onComment)) options.onComment = pushComment(options, options.onComment);
	return options;
}
function pushComment(options, array) {
	return function(block, text, start, end, startLoc, endLoc) {
		var comment = {
			type: block ? "Block" : "Line",
			value: text,
			start,
			end
		};
		if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
		if (options.ranges) comment.range = [start, end];
		array.push(comment);
	};
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
	return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
var Parser$1 = function Parser(options, input, startPos) {
	this.options = options = getOptions(options);
	this.sourceFile = options.sourceFile;
	this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
	var reserved = "";
	if (options.allowReserved !== true) {
		reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
		if (options.sourceType === "module") reserved += " await";
	}
	this.reservedWords = wordsRegexp(reserved);
	var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
	this.reservedWordsStrict = wordsRegexp(reservedStrict);
	this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
	this.input = String(input);
	this.containsEsc = false;
	if (startPos) {
		this.pos = startPos;
		this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
		this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
	} else {
		this.pos = this.lineStart = 0;
		this.curLine = 1;
	}
	this.type = types$1.eof;
	this.value = null;
	this.start = this.end = this.pos;
	this.startLoc = this.endLoc = this.curPosition();
	this.lastTokEndLoc = this.lastTokStartLoc = null;
	this.lastTokStart = this.lastTokEnd = this.pos;
	this.context = this.initialContext();
	this.exprAllowed = true;
	this.inModule = options.sourceType === "module";
	this.strict = this.inModule || this.strictDirective(this.pos);
	this.potentialArrowAt = -1;
	this.potentialArrowInForAwait = false;
	this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
	this.labels = [];
	this.undefinedExports = Object.create(null);
	if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
	this.scopeStack = [];
	this.enterScope(SCOPE_TOP);
	this.regexpState = null;
	this.privateNameStack = [];
};
var prototypeAccessors = {
	inFunction: { configurable: true },
	inGenerator: { configurable: true },
	inAsync: { configurable: true },
	canAwait: { configurable: true },
	allowSuper: { configurable: true },
	allowDirectSuper: { configurable: true },
	treatFunctionsAsVar: { configurable: true },
	allowNewDotTarget: { configurable: true },
	inClassStaticBlock: { configurable: true }
};
Parser$1.prototype.parse = function parse() {
	var node = this.options.program || this.startNode();
	this.nextToken();
	return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
	return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
	return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
	return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
	for (var i = this.scopeStack.length - 1; i >= 0; i--) {
		var flags = this.scopeStack[i].flags;
		if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) return false;
		if (flags & SCOPE_FUNCTION) return (flags & SCOPE_ASYNC) > 0;
	}
	return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
	return (this.currentThisScope().flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
	return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
	return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
	for (var i = this.scopeStack.length - 1; i >= 0; i--) {
		var flags = this.scopeStack[i].flags;
		if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) return true;
	}
	return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
	return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser$1.extend = function extend() {
	var plugins = [], len = arguments.length;
	while (len--) plugins[len] = arguments[len];
	var cls = this;
	for (var i = 0; i < plugins.length; i++) cls = plugins[i](cls);
	return cls;
};
Parser$1.parse = function parse(input, options) {
	return new this(options, input).parse();
};
Parser$1.parseExpressionAt = function parseExpressionAt(input, pos, options) {
	var parser = new this(options, input, pos);
	parser.nextToken();
	return parser.parseExpression();
};
Parser$1.tokenizer = function tokenizer(input, options) {
	return new this(options, input);
};
Object.defineProperties(Parser$1.prototype, prototypeAccessors);
var pp$9 = Parser$1.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
	if (this.options.ecmaVersion < 5) return false;
	for (;;) {
		skipWhiteSpace.lastIndex = start;
		start += skipWhiteSpace.exec(this.input)[0].length;
		var match = literal.exec(this.input.slice(start));
		if (!match) return false;
		if ((match[1] || match[2]) === "use strict") {
			skipWhiteSpace.lastIndex = start + match[0].length;
			var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
			var next = this.input.charAt(end);
			return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
		}
		start += match[0].length;
		skipWhiteSpace.lastIndex = start;
		start += skipWhiteSpace.exec(this.input)[0].length;
		if (this.input[start] === ";") start++;
	}
};
pp$9.eat = function(type) {
	if (this.type === type) {
		this.next();
		return true;
	} else return false;
};
pp$9.isContextual = function(name) {
	return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
	if (!this.isContextual(name)) return false;
	this.next();
	return true;
};
pp$9.expectContextual = function(name) {
	if (!this.eatContextual(name)) this.unexpected();
};
pp$9.canInsertSemicolon = function() {
	return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
	if (this.canInsertSemicolon()) {
		if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
		return true;
	}
};
pp$9.semicolon = function() {
	if (!this.eat(types$1.semi) && !this.insertSemicolon()) this.unexpected();
};
pp$9.afterTrailingComma = function(tokType, notNext) {
	if (this.type === tokType) {
		if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
		if (!notNext) this.next();
		return true;
	}
};
pp$9.expect = function(type) {
	this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
	this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors() {
	this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
	if (!refDestructuringErrors) return;
	if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
	var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
	if (parens > -1) this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	if (!refDestructuringErrors) return false;
	var shorthandAssign = refDestructuringErrors.shorthandAssign;
	var doubleProto = refDestructuringErrors.doubleProto;
	if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
	if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
	if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
};
pp$9.checkYieldAwaitInDefaultParams = function() {
	if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
	if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
};
pp$9.isSimpleAssignTarget = function(expr) {
	if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
	return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser$1.prototype;
pp$8.parseTopLevel = function(node) {
	var exports = Object.create(null);
	if (!node.body) node.body = [];
	while (this.type !== types$1.eof) {
		var stmt = this.parseStatement(null, true, exports);
		node.body.push(stmt);
	}
	if (this.inModule) for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
		var name = list[i];
		this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
	}
	this.adaptDirectivePrologue(node.body);
	this.next();
	node.sourceType = this.options.sourceType;
	return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
	if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
	skipWhiteSpace.lastIndex = this.pos;
	var skip = skipWhiteSpace.exec(this.input);
	var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
	if (nextCh === 91 || nextCh === 92) return true;
	if (context) return false;
	if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) return true;
	if (isIdentifierStart(nextCh, true)) {
		var pos = next + 1;
		while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) ++pos;
		if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) return true;
		var ident = this.input.slice(next, pos);
		if (!keywordRelationalOperator.test(ident)) return true;
	}
	return false;
};
pp$8.isAsyncFunction = function() {
	if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
	skipWhiteSpace.lastIndex = this.pos;
	var skip = skipWhiteSpace.exec(this.input);
	var next = this.pos + skip[0].length, after;
	return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
	if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) return false;
	skipWhiteSpace.lastIndex = this.pos;
	var skip = skipWhiteSpace.exec(this.input);
	var next = this.pos + skip[0].length;
	if (lineBreak.test(this.input.slice(this.pos, next))) return false;
	if (isAwaitUsing) {
		var awaitEndPos = next + 5, after;
		if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) return false;
		skipWhiteSpace.lastIndex = awaitEndPos;
		var skipAfterUsing = skipWhiteSpace.exec(this.input);
		if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) return false;
	}
	if (isFor) {
		var ofEndPos = next + 2, after$1;
		if (this.input.slice(next, ofEndPos) === "of") {
			if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) return false;
		}
	}
	var ch = this.input.charCodeAt(next);
	return isIdentifierStart(ch, true) || ch === 92;
};
pp$8.isAwaitUsing = function(isFor) {
	return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
	return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context, topLevel, exports) {
	var starttype = this.type, node = this.startNode(), kind;
	if (this.isLet(context)) {
		starttype = types$1._var;
		kind = "let";
	}
	switch (starttype) {
		case types$1._break:
		case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword);
		case types$1._debugger: return this.parseDebuggerStatement(node);
		case types$1._do: return this.parseDoStatement(node);
		case types$1._for: return this.parseForStatement(node);
		case types$1._function:
			if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
			return this.parseFunctionStatement(node, false, !context);
		case types$1._class:
			if (context) this.unexpected();
			return this.parseClass(node, true);
		case types$1._if: return this.parseIfStatement(node);
		case types$1._return: return this.parseReturnStatement(node);
		case types$1._switch: return this.parseSwitchStatement(node);
		case types$1._throw: return this.parseThrowStatement(node);
		case types$1._try: return this.parseTryStatement(node);
		case types$1._const:
		case types$1._var:
			kind = kind || this.value;
			if (context && kind !== "var") this.unexpected();
			return this.parseVarStatement(node, kind);
		case types$1._while: return this.parseWhileStatement(node);
		case types$1._with: return this.parseWithStatement(node);
		case types$1.braceL: return this.parseBlock(true, node);
		case types$1.semi: return this.parseEmptyStatement(node);
		case types$1._export:
		case types$1._import:
			if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
				skipWhiteSpace.lastIndex = this.pos;
				var skip = skipWhiteSpace.exec(this.input);
				var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
				if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
			}
			if (!this.options.allowImportExportEverywhere) {
				if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
				if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
			}
			return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
		default:
			if (this.isAsyncFunction()) {
				if (context) this.unexpected();
				this.next();
				return this.parseFunctionStatement(node, true, !context);
			}
			var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
			if (usingKind) {
				if (topLevel && this.options.sourceType === "script") this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
				if (usingKind === "await using") {
					if (!this.canAwait) this.raise(this.start, "Await using cannot appear outside of async function");
					this.next();
				}
				this.next();
				this.parseVar(node, false, usingKind);
				this.semicolon();
				return this.finishNode(node, "VariableDeclaration");
			}
			var maybeName = this.value, expr = this.parseExpression();
			if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
			else return this.parseExpressionStatement(node, expr);
	}
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
	var isBreak = keyword === "break";
	this.next();
	if (this.eat(types$1.semi) || this.insertSemicolon()) node.label = null;
	else if (this.type !== types$1.name) this.unexpected();
	else {
		node.label = this.parseIdent();
		this.semicolon();
	}
	var i = 0;
	for (; i < this.labels.length; ++i) {
		var lab = this.labels[i];
		if (node.label == null || lab.name === node.label.name) {
			if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
			if (node.label && isBreak) break;
		}
	}
	if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
	this.next();
	this.semicolon();
	return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
	this.next();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("do");
	this.labels.pop();
	this.expect(types$1._while);
	node.test = this.parseParenExpression();
	if (this.options.ecmaVersion >= 6) this.eat(types$1.semi);
	else this.semicolon();
	return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
	this.next();
	var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
	this.labels.push(loopLabel);
	this.enterScope(0);
	this.expect(types$1.parenL);
	if (this.type === types$1.semi) {
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, null);
	}
	var isLet = this.isLet();
	if (this.type === types$1._var || this.type === types$1._const || isLet) {
		var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
		this.next();
		this.parseVar(init$1, true, kind);
		this.finishNode(init$1, "VariableDeclaration");
		return this.parseForAfterInit(node, init$1, awaitAt);
	}
	var startsWithLet = this.isContextual("let"), isForOf = false;
	var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
	if (usingKind) {
		var init$2 = this.startNode();
		this.next();
		if (usingKind === "await using") this.next();
		this.parseVar(init$2, true, usingKind);
		this.finishNode(init$2, "VariableDeclaration");
		return this.parseForAfterInit(node, init$2, awaitAt);
	}
	var containsEsc = this.containsEsc;
	var refDestructuringErrors = new DestructuringErrors();
	var initPos = this.start;
	var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
	if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
		if (awaitAt > -1) {
			if (this.type === types$1._in) this.unexpected(awaitAt);
			node.await = true;
		} else if (isForOf && this.options.ecmaVersion >= 8) {
			if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") this.unexpected();
			else if (this.options.ecmaVersion >= 9) node.await = false;
		}
		if (startsWithLet && isForOf) this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
		this.toAssignable(init, false, refDestructuringErrors);
		this.checkLValPattern(init);
		return this.parseForIn(node, init);
	} else this.checkExpressionErrors(refDestructuringErrors, true);
	if (awaitAt > -1) this.unexpected(awaitAt);
	return this.parseFor(node, init);
};
pp$8.parseForAfterInit = function(node, init, awaitAt) {
	if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
		if (this.options.ecmaVersion >= 9) if (this.type === types$1._in) {
			if (awaitAt > -1) this.unexpected(awaitAt);
		} else node.await = awaitAt > -1;
		return this.parseForIn(node, init);
	}
	if (awaitAt > -1) this.unexpected(awaitAt);
	return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
	this.next();
	return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	node.consequent = this.parseStatement("if");
	node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
	return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
	if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	this.next();
	if (this.eat(types$1.semi) || this.insertSemicolon()) node.argument = null;
	else {
		node.argument = this.parseExpression();
		this.semicolon();
	}
	return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
	this.next();
	node.discriminant = this.parseParenExpression();
	node.cases = [];
	this.expect(types$1.braceL);
	this.labels.push(switchLabel);
	this.enterScope(0);
	var cur;
	for (var sawDefault = false; this.type !== types$1.braceR;) if (this.type === types$1._case || this.type === types$1._default) {
		var isCase = this.type === types$1._case;
		if (cur) this.finishNode(cur, "SwitchCase");
		node.cases.push(cur = this.startNode());
		cur.consequent = [];
		this.next();
		if (isCase) cur.test = this.parseExpression();
		else {
			if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
			sawDefault = true;
			cur.test = null;
		}
		this.expect(types$1.colon);
	} else {
		if (!cur) this.unexpected();
		cur.consequent.push(this.parseStatement(null));
	}
	this.exitScope();
	if (cur) this.finishNode(cur, "SwitchCase");
	this.next();
	this.labels.pop();
	return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
	this.next();
	if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	node.argument = this.parseExpression();
	this.semicolon();
	return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
	var param = this.parseBindingAtom();
	var simple = param.type === "Identifier";
	this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
	this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
	this.expect(types$1.parenR);
	return param;
};
pp$8.parseTryStatement = function(node) {
	this.next();
	node.block = this.parseBlock();
	node.handler = null;
	if (this.type === types$1._catch) {
		var clause = this.startNode();
		this.next();
		if (this.eat(types$1.parenL)) clause.param = this.parseCatchClauseParam();
		else {
			if (this.options.ecmaVersion < 10) this.unexpected();
			clause.param = null;
			this.enterScope(0);
		}
		clause.body = this.parseBlock(false);
		this.exitScope();
		node.handler = this.finishNode(clause, "CatchClause");
	}
	node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
	if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
	this.next();
	this.parseVar(node, false, kind, allowMissingInitializer);
	this.semicolon();
	return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("while");
	this.labels.pop();
	return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
	if (this.strict) this.raise(this.start, "'with' in strict mode");
	this.next();
	node.object = this.parseParenExpression();
	node.body = this.parseStatement("with");
	return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
	this.next();
	return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
	for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) if (list[i$1].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
	for (var i = this.labels.length - 1; i >= 0; i--) {
		var label$1 = this.labels[i];
		if (label$1.statementStart === node.start) {
			label$1.statementStart = this.start;
			label$1.kind = kind;
		} else break;
	}
	this.labels.push({
		name: maybeName,
		kind,
		statementStart: this.start
	});
	node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
	this.labels.pop();
	node.label = expr;
	return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
	node.expression = expr;
	this.semicolon();
	return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
	if (createNewLexicalScope === void 0) createNewLexicalScope = true;
	if (node === void 0) node = this.startNode();
	node.body = [];
	this.expect(types$1.braceL);
	if (createNewLexicalScope) this.enterScope(0);
	while (this.type !== types$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	if (exitStrict) this.strict = false;
	this.next();
	if (createNewLexicalScope) this.exitScope();
	return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
	node.init = init;
	this.expect(types$1.semi);
	node.test = this.type === types$1.semi ? null : this.parseExpression();
	this.expect(types$1.semi);
	node.update = this.type === types$1.parenR ? null : this.parseExpression();
	this.expect(types$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
	var isForIn = this.type === types$1._in;
	this.next();
	if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
	node.left = init;
	node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
	this.expect(types$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
	node.declarations = [];
	node.kind = kind;
	for (;;) {
		var decl = this.startNode();
		this.parseVarId(decl, kind);
		if (this.eat(types$1.eq)) decl.init = this.parseMaybeAssign(isFor);
		else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
		else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
		else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
		else decl.init = null;
		node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
		if (!this.eat(types$1.comma)) break;
	}
	return node;
};
pp$8.parseVarId = function(decl, kind) {
	decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
	this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
	this.initFunction(node);
	if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
		if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
		node.generator = this.eat(types$1.star);
	}
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
	if (statement & FUNC_STATEMENT) {
		node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
		if (node.id && !(statement & FUNC_HANGING_STATEMENT)) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
	}
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags(node.async, node.generator));
	if (!(statement & FUNC_STATEMENT)) node.id = this.type === types$1.name ? this.parseIdent() : null;
	this.parseFunctionParams(node);
	this.parseFunctionBody(node, allowExpressionBody, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
	this.expect(types$1.parenL);
	node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
	this.next();
	var oldStrict = this.strict;
	this.strict = true;
	this.parseClassId(node, isStatement);
	this.parseClassSuper(node);
	var privateNameMap = this.enterClassBody();
	var classBody = this.startNode();
	var hadConstructor = false;
	classBody.body = [];
	this.expect(types$1.braceL);
	while (this.type !== types$1.braceR) {
		var element = this.parseClassElement(node.superClass !== null);
		if (element) {
			classBody.body.push(element);
			if (element.type === "MethodDefinition" && element.kind === "constructor") {
				if (hadConstructor) this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
				hadConstructor = true;
			} else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
		}
	}
	this.strict = oldStrict;
	this.next();
	node.body = this.finishNode(classBody, "ClassBody");
	this.exitClassBody();
	return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
	if (this.eat(types$1.semi)) return null;
	var ecmaVersion = this.options.ecmaVersion;
	var node = this.startNode();
	var keyName = "";
	var isGenerator = false;
	var isAsync = false;
	var kind = "method";
	var isStatic = false;
	if (this.eatContextual("static")) {
		if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
			this.parseClassStaticBlock(node);
			return node;
		}
		if (this.isClassElementNameStart() || this.type === types$1.star) isStatic = true;
		else keyName = "static";
	}
	node.static = isStatic;
	if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) isAsync = true;
	else keyName = "async";
	if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) isGenerator = true;
	if (!keyName && !isAsync && !isGenerator) {
		var lastValue = this.value;
		if (this.eatContextual("get") || this.eatContextual("set")) if (this.isClassElementNameStart()) kind = lastValue;
		else keyName = lastValue;
	}
	if (keyName) {
		node.computed = false;
		node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
		node.key.name = keyName;
		this.finishNode(node.key, "Identifier");
	} else this.parseClassElementName(node);
	if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
		var isConstructor = !node.static && checkKeyName(node, "constructor");
		var allowsDirectSuper = isConstructor && constructorAllowsSuper;
		if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
		node.kind = isConstructor ? "constructor" : kind;
		this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
	} else this.parseClassField(node);
	return node;
};
pp$8.isClassElementNameStart = function() {
	return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
	if (this.type === types$1.privateId) {
		if (this.value === "constructor") this.raise(this.start, "Classes can't have an element named '#constructor'");
		element.computed = false;
		element.key = this.parsePrivateIdent();
	} else this.parsePropertyName(element);
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
	var key = method.key;
	if (method.kind === "constructor") {
		if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
		if (isAsync) this.raise(key.start, "Constructor can't be an async method");
	} else if (method.static && checkKeyName(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
	var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
	if (method.kind === "get" && value.params.length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
	if (method.kind === "set" && value.params.length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
	if (method.kind === "set" && value.params[0].type === "RestElement") this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
	return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
	if (checkKeyName(field, "constructor")) this.raise(field.key.start, "Classes can't have a field named 'constructor'");
	else if (field.static && checkKeyName(field, "prototype")) this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
	if (this.eat(types$1.eq)) {
		this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
		field.value = this.parseMaybeAssign();
		this.exitScope();
	} else field.value = null;
	this.semicolon();
	return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
	node.body = [];
	var oldLabels = this.labels;
	this.labels = [];
	this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
	while (this.type !== types$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	this.next();
	this.exitScope();
	this.labels = oldLabels;
	return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
	if (this.type === types$1.name) {
		node.id = this.parseIdent();
		if (isStatement) this.checkLValSimple(node.id, BIND_LEXICAL, false);
	} else {
		if (isStatement === true) this.unexpected();
		node.id = null;
	}
};
pp$8.parseClassSuper = function(node) {
	node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
	var element = {
		declared: Object.create(null),
		used: []
	};
	this.privateNameStack.push(element);
	return element.declared;
};
pp$8.exitClassBody = function() {
	var ref = this.privateNameStack.pop();
	var declared = ref.declared;
	var used = ref.used;
	if (!this.options.checkPrivateFields) return;
	var len = this.privateNameStack.length;
	var parent = len === 0 ? null : this.privateNameStack[len - 1];
	for (var i = 0; i < used.length; ++i) {
		var id = used[i];
		if (!hasOwn(declared, id.name)) if (parent) parent.used.push(id);
		else this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
	}
};
function isPrivateNameConflicted(privateNameMap, element) {
	var name = element.key.name;
	var curr = privateNameMap[name];
	var next = "true";
	if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) next = (element.static ? "s" : "i") + element.kind;
	if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
		privateNameMap[name] = "true";
		return false;
	} else if (!curr) {
		privateNameMap[name] = next;
		return false;
	} else return true;
}
function checkKeyName(node, name) {
	var computed = node.computed;
	var key = node.key;
	return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
	if (this.options.ecmaVersion >= 11) if (this.eatContextual("as")) {
		node.exported = this.parseModuleExportName();
		this.checkExport(exports, node.exported, this.lastTokStart);
	} else node.exported = null;
	this.expectContextual("from");
	if (this.type !== types$1.string) this.unexpected();
	node.source = this.parseExprAtom();
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
	this.next();
	if (this.eat(types$1.star)) return this.parseExportAllDeclaration(node, exports);
	if (this.eat(types$1._default)) {
		this.checkExport(exports, "default", this.lastTokStart);
		node.declaration = this.parseExportDefaultDeclaration();
		return this.finishNode(node, "ExportDefaultDeclaration");
	}
	if (this.shouldParseExportStatement()) {
		node.declaration = this.parseExportDeclaration(node);
		if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports, node.declaration.declarations);
		else this.checkExport(exports, node.declaration.id, node.declaration.id.start);
		node.specifiers = [];
		node.source = null;
		if (this.options.ecmaVersion >= 16) node.attributes = [];
	} else {
		node.declaration = null;
		node.specifiers = this.parseExportSpecifiers(exports);
		if (this.eatContextual("from")) {
			if (this.type !== types$1.string) this.unexpected();
			node.source = this.parseExprAtom();
			if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
		} else {
			for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
				var spec = list[i];
				this.checkUnreserved(spec.local);
				this.checkLocalExport(spec.local);
				if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
			}
			node.source = null;
			if (this.options.ecmaVersion >= 16) node.attributes = [];
		}
		this.semicolon();
	}
	return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
	return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
	var isAsync;
	if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
		var fNode = this.startNode();
		this.next();
		if (isAsync) this.next();
		return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
	} else if (this.type === types$1._class) {
		var cNode = this.startNode();
		return this.parseClass(cNode, "nullableID");
	} else {
		var declaration = this.parseMaybeAssign();
		this.semicolon();
		return declaration;
	}
};
pp$8.checkExport = function(exports, name, pos) {
	if (!exports) return;
	if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
	if (hasOwn(exports, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
	exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
	var type = pat.type;
	if (type === "Identifier") this.checkExport(exports, pat, pat.start);
	else if (type === "ObjectPattern") for (var i = 0, list = pat.properties; i < list.length; i += 1) {
		var prop = list[i];
		this.checkPatternExport(exports, prop);
	}
	else if (type === "ArrayPattern") for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
		var elt = list$1[i$1];
		if (elt) this.checkPatternExport(exports, elt);
	}
	else if (type === "Property") this.checkPatternExport(exports, pat.value);
	else if (type === "AssignmentPattern") this.checkPatternExport(exports, pat.left);
	else if (type === "RestElement") this.checkPatternExport(exports, pat.argument);
};
pp$8.checkVariableExport = function(exports, decls) {
	if (!exports) return;
	for (var i = 0, list = decls; i < list.length; i += 1) {
		var decl = list[i];
		this.checkPatternExport(exports, decl.id);
	}
};
pp$8.shouldParseExportStatement = function() {
	return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
	var node = this.startNode();
	node.local = this.parseModuleExportName();
	node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
	this.checkExport(exports, node.exported, node.exported.start);
	return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
	var nodes = [], first = true;
	this.expect(types$1.braceL);
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseExportSpecifier(exports));
	}
	return nodes;
};
pp$8.parseImport = function(node) {
	this.next();
	if (this.type === types$1.string) {
		node.specifiers = empty$1;
		node.source = this.parseExprAtom();
	} else {
		node.specifiers = this.parseImportSpecifiers();
		this.expectContextual("from");
		node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
	}
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
	var node = this.startNode();
	node.imported = this.parseModuleExportName();
	if (this.eatContextual("as")) node.local = this.parseIdent();
	else {
		this.checkUnreserved(node.imported);
		node.local = node.imported;
	}
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
	var node = this.startNode();
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
	var node = this.startNode();
	this.next();
	this.expectContextual("as");
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
	var nodes = [], first = true;
	if (this.type === types$1.name) {
		nodes.push(this.parseImportDefaultSpecifier());
		if (!this.eat(types$1.comma)) return nodes;
	}
	if (this.type === types$1.star) {
		nodes.push(this.parseImportNamespaceSpecifier());
		return nodes;
	}
	this.expect(types$1.braceL);
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseImportSpecifier());
	}
	return nodes;
};
pp$8.parseWithClause = function() {
	var nodes = [];
	if (!this.eat(types$1._with)) return nodes;
	this.expect(types$1.braceL);
	var attributeKeys = {};
	var first = true;
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		var attr = this.parseImportAttribute();
		var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
		if (hasOwn(attributeKeys, keyName)) this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
		attributeKeys[keyName] = true;
		nodes.push(attr);
	}
	return nodes;
};
pp$8.parseImportAttribute = function() {
	var node = this.startNode();
	node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
	this.expect(types$1.colon);
	if (this.type !== types$1.string) this.unexpected();
	node.value = this.parseExprAtom();
	return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
	if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
		var stringLiteral = this.parseLiteral(this.value);
		if (loneSurrogate.test(stringLiteral.value)) this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
		return stringLiteral;
	}
	return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
	for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) statements[i].directive = statements[i].expression.raw.slice(1, -1);
};
pp$8.isDirectiveCandidate = function(statement) {
	return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};
var pp$7 = Parser$1.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 6 && node) switch (node.type) {
		case "Identifier":
			if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
			break;
		case "ObjectPattern":
		case "ArrayPattern":
		case "AssignmentPattern":
		case "RestElement": break;
		case "ObjectExpression":
			node.type = "ObjectPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			for (var i = 0, list = node.properties; i < list.length; i += 1) {
				var prop = list[i];
				this.toAssignable(prop, isBinding);
				if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
			}
			break;
		case "Property":
			if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
			this.toAssignable(node.value, isBinding);
			break;
		case "ArrayExpression":
			node.type = "ArrayPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			this.toAssignableList(node.elements, isBinding);
			break;
		case "SpreadElement":
			node.type = "RestElement";
			this.toAssignable(node.argument, isBinding);
			if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
			break;
		case "AssignmentExpression":
			if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
			node.type = "AssignmentPattern";
			delete node.operator;
			this.toAssignable(node.left, isBinding);
			break;
		case "ParenthesizedExpression":
			this.toAssignable(node.expression, isBinding, refDestructuringErrors);
			break;
		case "ChainExpression":
			this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression": if (!isBinding) break;
		default: this.raise(node.start, "Assigning to rvalue");
	}
	else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
	return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
	var end = exprList.length;
	for (var i = 0; i < end; i++) {
		var elt = exprList[i];
		if (elt) this.toAssignable(elt, isBinding);
	}
	if (end) {
		var last = exprList[end - 1];
		if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
	}
	return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
	return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion === 6 && this.type !== types$1.name) this.unexpected();
	node.argument = this.parseBindingAtom();
	return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
	if (this.options.ecmaVersion >= 6) switch (this.type) {
		case types$1.bracketL:
			var node = this.startNode();
			this.next();
			node.elements = this.parseBindingList(types$1.bracketR, true, true);
			return this.finishNode(node, "ArrayPattern");
		case types$1.braceL: return this.parseObj(true);
	}
	return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (first) first = false;
		else this.expect(types$1.comma);
		if (allowEmpty && this.type === types$1.comma) elts.push(null);
		else if (allowTrailingComma && this.afterTrailingComma(close)) break;
		else if (this.type === types$1.ellipsis) {
			var rest = this.parseRestBinding();
			this.parseBindingListItem(rest);
			elts.push(rest);
			if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			this.expect(close);
			break;
		} else elts.push(this.parseAssignableListItem(allowModifiers));
	}
	return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
	var elem = this.parseMaybeDefault(this.start, this.startLoc);
	this.parseBindingListItem(elem);
	return elem;
};
pp$7.parseBindingListItem = function(param) {
	return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
	left = left || this.parseBindingAtom();
	if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) return left;
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.right = this.parseMaybeAssign();
	return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	var isBind = bindingType !== BIND_NONE;
	switch (expr.type) {
		case "Identifier":
			if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
			if (isBind) {
				if (bindingType === BIND_LEXICAL && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
				if (checkClashes) {
					if (hasOwn(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
					checkClashes[expr.name] = true;
				}
				if (bindingType !== BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);
			}
			break;
		case "ChainExpression":
			this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding member expression");
			break;
		case "ParenthesizedExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding parenthesized expression");
			return this.checkLValSimple(expr.expression, bindingType, checkClashes);
		default: this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
	}
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	switch (expr.type) {
		case "ObjectPattern":
			for (var i = 0, list = expr.properties; i < list.length; i += 1) {
				var prop = list[i];
				this.checkLValInnerPattern(prop, bindingType, checkClashes);
			}
			break;
		case "ArrayPattern":
			for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
				var elem = list$1[i$1];
				if (elem) this.checkLValInnerPattern(elem, bindingType, checkClashes);
			}
			break;
		default: this.checkLValSimple(expr, bindingType, checkClashes);
	}
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	switch (expr.type) {
		case "Property":
			this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
			break;
		case "AssignmentPattern":
			this.checkLValPattern(expr.left, bindingType, checkClashes);
			break;
		case "RestElement":
			this.checkLValPattern(expr.argument, bindingType, checkClashes);
			break;
		default: this.checkLValPattern(expr, bindingType, checkClashes);
	}
};
var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
	this.token = token;
	this.isExpr = !!isExpr;
	this.preserveSpace = !!preserveSpace;
	this.override = override;
	this.generator = !!generator;
};
var types$2 = {
	b_stat: new TokContext("{", false),
	b_expr: new TokContext("{", true),
	b_tmpl: new TokContext("${", false),
	p_stat: new TokContext("(", false),
	p_expr: new TokContext("(", true),
	q_tmpl: new TokContext("`", true, true, function(p) {
		return p.tryReadTemplateToken();
	}),
	f_stat: new TokContext("function", false),
	f_expr: new TokContext("function", true),
	f_expr_gen: new TokContext("function", true, false, null, true),
	f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser$1.prototype;
pp$6.initialContext = function() {
	return [types$2.b_stat];
};
pp$6.curContext = function() {
	return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
	var parent = this.curContext();
	if (parent === types$2.f_expr || parent === types$2.f_stat) return true;
	if (prevType === types$1.colon && (parent === types$2.b_stat || parent === types$2.b_expr)) return !parent.isExpr;
	if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) return true;
	if (prevType === types$1.braceL) return parent === types$2.b_stat;
	if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) return false;
	return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
	for (var i = this.context.length - 1; i >= 1; i--) {
		var context = this.context[i];
		if (context.token === "function") return context.generator;
	}
	return false;
};
pp$6.updateContext = function(prevType) {
	var update, type = this.type;
	if (type.keyword && prevType === types$1.dot) this.exprAllowed = false;
	else if (update = type.updateContext) update.call(this, prevType);
	else this.exprAllowed = type.beforeExpr;
};
pp$6.overrideContext = function(tokenCtx) {
	if (this.curContext() !== tokenCtx) this.context[this.context.length - 1] = tokenCtx;
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
	if (this.context.length === 1) {
		this.exprAllowed = true;
		return;
	}
	var out = this.context.pop();
	if (out === types$2.b_stat && this.curContext().token === "function") out = this.context.pop();
	this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
	this.context.push(this.braceIsBlock(prevType) ? types$2.b_stat : types$2.b_expr);
	this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
	this.context.push(types$2.b_tmpl);
	this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
	var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
	this.context.push(statementParens ? types$2.p_stat : types$2.p_expr);
	this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
	if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types$2.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types$2.b_stat)) this.context.push(types$2.f_expr);
	else this.context.push(types$2.f_stat);
	this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
	if (this.curContext().token === "function") this.context.pop();
	this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
	if (this.curContext() === types$2.q_tmpl) this.context.pop();
	else this.context.push(types$2.q_tmpl);
	this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
	if (prevType === types$1._function) {
		var index = this.context.length - 1;
		if (this.context[index] === types$2.f_expr) this.context[index] = types$2.f_expr_gen;
		else this.context[index] = types$2.f_gen;
	}
	this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
	var allowed = false;
	if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
		if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
	}
	this.exprAllowed = allowed;
};
var pp$5 = Parser$1.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
	if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
	var key = prop.key;
	var name;
	switch (key.type) {
		case "Identifier":
			name = key.name;
			break;
		case "Literal":
			name = String(key.value);
			break;
		default: return;
	}
	var kind = prop.kind;
	if (this.options.ecmaVersion >= 6) {
		if (name === "__proto__" && kind === "init") {
			if (propHash.proto) if (refDestructuringErrors) {
				if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
			} else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
			propHash.proto = true;
		}
		return;
	}
	name = "$" + name;
	var other = propHash[name];
	if (other) {
		var redefinition;
		if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
		else redefinition = other.init || other[kind];
		if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
	} else other = propHash[name] = {
		init: false,
		get: false,
		set: false
	};
	other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
	if (this.type === types$1.comma) {
		var node = this.startNodeAt(startPos, startLoc);
		node.expressions = [expr];
		while (this.eat(types$1.comma)) node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
		return this.finishNode(node, "SequenceExpression");
	}
	return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
	if (this.isContextual("yield")) if (this.inGenerator) return this.parseYield(forInit);
	else this.exprAllowed = false;
	var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
	if (refDestructuringErrors) {
		oldParenAssign = refDestructuringErrors.parenthesizedAssign;
		oldTrailingComma = refDestructuringErrors.trailingComma;
		oldDoubleProto = refDestructuringErrors.doubleProto;
		refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
	} else {
		refDestructuringErrors = new DestructuringErrors();
		ownDestructuringErrors = true;
	}
	var startPos = this.start, startLoc = this.startLoc;
	if (this.type === types$1.parenL || this.type === types$1.name) {
		this.potentialArrowAt = this.start;
		this.potentialArrowInForAwait = forInit === "await";
	}
	var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
	if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
	if (this.type.isAssign) {
		var node = this.startNodeAt(startPos, startLoc);
		node.operator = this.value;
		if (this.type === types$1.eq) left = this.toAssignable(left, false, refDestructuringErrors);
		if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
		if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
		if (this.type === types$1.eq) this.checkLValPattern(left);
		else this.checkLValSimple(left);
		node.left = left;
		this.next();
		node.right = this.parseMaybeAssign(forInit);
		if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
		return this.finishNode(node, "AssignmentExpression");
	} else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
	if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
	if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
	return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprOps(forInit, refDestructuringErrors);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	if (this.eat(types$1.question)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.test = expr;
		node.consequent = this.parseMaybeAssign();
		this.expect(types$1.colon);
		node.alternate = this.parseMaybeAssign(forInit);
		return this.finishNode(node, "ConditionalExpression");
	}
	return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
	var prec = this.type.binop;
	if (prec != null && (!forInit || this.type !== types$1._in)) {
		if (prec > minPrec) {
			var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
			var coalesce = this.type === types$1.coalesce;
			if (coalesce) prec = types$1.logicalAND.binop;
			var op = this.value;
			this.next();
			var startPos = this.start, startLoc = this.startLoc;
			var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
			var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
			if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
			return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
		}
	}
	return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	if (right.type === "PrivateIdentifier") this.raise(right.start, "Private identifier can only be left side of binary expression");
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.operator = op;
	node.right = right;
	return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
	var startPos = this.start, startLoc = this.startLoc, expr;
	if (this.isContextual("await") && this.canAwait) {
		expr = this.parseAwait(forInit);
		sawUnary = true;
	} else if (this.type.prefix) {
		var node = this.startNode(), update = this.type === types$1.incDec;
		node.operator = this.value;
		node.prefix = true;
		this.next();
		node.argument = this.parseMaybeUnary(null, true, update, forInit);
		this.checkExpressionErrors(refDestructuringErrors, true);
		if (update) this.checkLValSimple(node.argument);
		else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
		else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) this.raiseRecoverable(node.start, "Private fields can not be deleted");
		else sawUnary = true;
		expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	} else if (!sawUnary && this.type === types$1.privateId) {
		if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) this.unexpected();
		expr = this.parsePrivateIdent();
		if (this.type !== types$1._in) this.unexpected();
	} else {
		expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
		if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
		while (this.type.postfix && !this.canInsertSemicolon()) {
			var node$1 = this.startNodeAt(startPos, startLoc);
			node$1.operator = this.value;
			node$1.prefix = false;
			node$1.argument = expr;
			this.checkLValSimple(expr);
			this.next();
			expr = this.finishNode(node$1, "UpdateExpression");
		}
	}
	if (!incDec && this.eat(types$1.starstar)) if (sawUnary) this.unexpected(this.lastTokStart);
	else return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
	else return expr;
};
function isLocalVariableAccess(node) {
	return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
	return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprAtom(refDestructuringErrors, forInit);
	if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
	var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
	if (refDestructuringErrors && result.type === "MemberExpression") {
		if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
		if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
		if (refDestructuringErrors.trailingComma >= result.start) refDestructuringErrors.trailingComma = -1;
	}
	return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
	var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
	var optionalChained = false;
	while (true) {
		var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
		if (element.optional) optionalChained = true;
		if (element === base || element.type === "ArrowFunctionExpression") {
			if (optionalChained) {
				var chainNode = this.startNodeAt(startPos, startLoc);
				chainNode.expression = element;
				element = this.finishNode(chainNode, "ChainExpression");
			}
			return element;
		}
		base = element;
	}
};
pp$5.shouldParseAsyncArrow = function() {
	return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
	var optionalSupported = this.options.ecmaVersion >= 11;
	var optional = optionalSupported && this.eat(types$1.questionDot);
	if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
	var computed = this.eat(types$1.bracketL);
	if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.object = base;
		if (computed) {
			node.property = this.parseExpression();
			this.expect(types$1.bracketR);
		} else if (this.type === types$1.privateId && base.type !== "Super") node.property = this.parsePrivateIdent();
		else node.property = this.parseIdent(this.options.allowReserved !== "never");
		node.computed = !!computed;
		if (optionalSupported) node.optional = optional;
		base = this.finishNode(node, "MemberExpression");
	} else if (!noCalls && this.eat(types$1.parenL)) {
		var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		this.yieldPos = 0;
		this.awaitPos = 0;
		this.awaitIdentPos = 0;
		var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
		if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			this.awaitIdentPos = oldAwaitIdentPos;
			return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
		}
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
		var node$1 = this.startNodeAt(startPos, startLoc);
		node$1.callee = base;
		node$1.arguments = exprList;
		if (optionalSupported) node$1.optional = optional;
		base = this.finishNode(node$1, "CallExpression");
	} else if (this.type === types$1.backQuote) {
		if (optional || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
		var node$2 = this.startNodeAt(startPos, startLoc);
		node$2.tag = base;
		node$2.quasi = this.parseTemplate({ isTagged: true });
		base = this.finishNode(node$2, "TaggedTemplateExpression");
	}
	return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
	if (this.type === types$1.slash) this.readRegexp();
	var node, canBeArrow = this.potentialArrowAt === this.start;
	switch (this.type) {
		case types$1._super:
			if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
			node = this.startNode();
			this.next();
			if (this.type === types$1.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
			if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) this.unexpected();
			return this.finishNode(node, "Super");
		case types$1._this:
			node = this.startNode();
			this.next();
			return this.finishNode(node, "ThisExpression");
		case types$1.name:
			var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
			var id = this.parseIdent(false);
			if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
				this.overrideContext(types$2.f_expr);
				return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
			}
			if (canBeArrow && !this.canInsertSemicolon()) {
				if (this.eat(types$1.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
				if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
					id = this.parseIdent(false);
					if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) this.unexpected();
					return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
				}
			}
			return id;
		case types$1.regexp:
			var value = this.value;
			node = this.parseLiteral(value.value);
			node.regex = {
				pattern: value.pattern,
				flags: value.flags
			};
			return node;
		case types$1.num:
		case types$1.string: return this.parseLiteral(this.value);
		case types$1._null:
		case types$1._true:
		case types$1._false:
			node = this.startNode();
			node.value = this.type === types$1._null ? null : this.type === types$1._true;
			node.raw = this.type.keyword;
			this.next();
			return this.finishNode(node, "Literal");
		case types$1.parenL:
			var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
			if (refDestructuringErrors) {
				if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
				if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
			}
			return expr;
		case types$1.bracketL:
			node = this.startNode();
			this.next();
			node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
			return this.finishNode(node, "ArrayExpression");
		case types$1.braceL:
			this.overrideContext(types$2.b_expr);
			return this.parseObj(false, refDestructuringErrors);
		case types$1._function:
			node = this.startNode();
			this.next();
			return this.parseFunction(node, 0);
		case types$1._class: return this.parseClass(this.startNode(), false);
		case types$1._new: return this.parseNew();
		case types$1.backQuote: return this.parseTemplate();
		case types$1._import: if (this.options.ecmaVersion >= 11) return this.parseExprImport(forNew);
		else return this.unexpected();
		default: return this.parseExprAtomDefault();
	}
};
pp$5.parseExprAtomDefault = function() {
	this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
	var node = this.startNode();
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
	this.next();
	if (this.type === types$1.parenL && !forNew) return this.parseDynamicImport(node);
	else if (this.type === types$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "import";
		node.meta = this.finishNode(meta, "Identifier");
		return this.parseImportMeta(node);
	} else this.unexpected();
};
pp$5.parseDynamicImport = function(node) {
	this.next();
	node.source = this.parseMaybeAssign();
	if (this.options.ecmaVersion >= 16) if (!this.eat(types$1.parenR)) {
		this.expect(types$1.comma);
		if (!this.afterTrailingComma(types$1.parenR)) {
			node.options = this.parseMaybeAssign();
			if (!this.eat(types$1.parenR)) {
				this.expect(types$1.comma);
				if (!this.afterTrailingComma(types$1.parenR)) this.unexpected();
			}
		} else node.options = null;
	} else node.options = null;
	else if (!this.eat(types$1.parenR)) {
		var errorPos = this.start;
		if (this.eat(types$1.comma) && this.eat(types$1.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
		else this.unexpected(errorPos);
	}
	return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
	this.next();
	var containsEsc = this.containsEsc;
	node.property = this.parseIdent(true);
	if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
	if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
	if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
	return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
	var node = this.startNode();
	node.value = value;
	node.raw = this.input.slice(this.start, this.end);
	if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
	this.next();
	return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
	this.expect(types$1.parenL);
	var val = this.parseExpression();
	this.expect(types$1.parenR);
	return val;
};
pp$5.shouldParseArrow = function(exprList) {
	return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
	var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
	if (this.options.ecmaVersion >= 6) {
		this.next();
		var innerStartPos = this.start, innerStartLoc = this.startLoc;
		var exprList = [], first = true, lastIsComma = false;
		var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
		this.yieldPos = 0;
		this.awaitPos = 0;
		while (this.type !== types$1.parenR) {
			first ? first = false : this.expect(types$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
				lastIsComma = true;
				break;
			} else if (this.type === types$1.ellipsis) {
				spreadStart = this.start;
				exprList.push(this.parseParenItem(this.parseRestBinding()));
				if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
				break;
			} else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
		}
		var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
		this.expect(types$1.parenR);
		if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
		}
		if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
		if (spreadStart) this.unexpected(spreadStart);
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		if (exprList.length > 1) {
			val = this.startNodeAt(innerStartPos, innerStartLoc);
			val.expressions = exprList;
			this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
		} else val = exprList[0];
	} else val = this.parseParenExpression();
	if (this.options.preserveParens) {
		var par = this.startNodeAt(startPos, startLoc);
		par.expression = val;
		return this.finishNode(par, "ParenthesizedExpression");
	} else return val;
};
pp$5.parseParenItem = function(item) {
	return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "new";
		node.meta = this.finishNode(meta, "Identifier");
		this.next();
		var containsEsc = this.containsEsc;
		node.property = this.parseIdent(true);
		if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
		if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
		if (!this.allowNewDotTarget) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
		return this.finishNode(node, "MetaProperty");
	}
	var startPos = this.start, startLoc = this.startLoc;
	node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
	if (this.eat(types$1.parenL)) node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
	else node.arguments = empty;
	return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref) {
	var isTagged = ref.isTagged;
	var elem = this.startNode();
	if (this.type === types$1.invalidTemplate) {
		if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
		elem.value = {
			raw: this.value.replace(/\r\n?/g, "\n"),
			cooked: null
		};
	} else elem.value = {
		raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
		cooked: this.value
	};
	this.next();
	elem.tail = this.type === types$1.backQuote;
	return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref) {
	if (ref === void 0) ref = {};
	var isTagged = ref.isTagged;
	if (isTagged === void 0) isTagged = false;
	var node = this.startNode();
	this.next();
	node.expressions = [];
	var curElt = this.parseTemplateElement({ isTagged });
	node.quasis = [curElt];
	while (!curElt.tail) {
		if (this.type === types$1.eof) this.raise(this.pos, "Unterminated template literal");
		this.expect(types$1.dollarBraceL);
		node.expressions.push(this.parseExpression());
		this.expect(types$1.braceR);
		node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
	}
	this.next();
	return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
	return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
	var node = this.startNode(), first = true, propHash = {};
	node.properties = [];
	this.next();
	while (!this.eat(types$1.braceR)) {
		if (!first) {
			this.expect(types$1.comma);
			if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) break;
		} else first = false;
		var prop = this.parseProperty(isPattern, refDestructuringErrors);
		if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
		node.properties.push(prop);
	}
	return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
	var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
	if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
		if (isPattern) {
			prop.argument = this.parseIdent(false);
			if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			return this.finishNode(prop, "RestElement");
		}
		prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		return this.finishNode(prop, "SpreadElement");
	}
	if (this.options.ecmaVersion >= 6) {
		prop.method = false;
		prop.shorthand = false;
		if (isPattern || refDestructuringErrors) {
			startPos = this.start;
			startLoc = this.startLoc;
		}
		if (!isPattern) isGenerator = this.eat(types$1.star);
	}
	var containsEsc = this.containsEsc;
	this.parsePropertyName(prop);
	if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
		isAsync = true;
		isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
		this.parsePropertyName(prop);
	} else isAsync = false;
	this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
	return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
	var kind = prop.key.name;
	this.parsePropertyName(prop);
	prop.value = this.parseMethod(false);
	prop.kind = kind;
	var paramCount = prop.kind === "get" ? 0 : 1;
	if (prop.value.params.length !== paramCount) {
		var start = prop.value.start;
		if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
		else this.raiseRecoverable(start, "setter should have exactly one param");
	} else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
	if ((isGenerator || isAsync) && this.type === types$1.colon) this.unexpected();
	if (this.eat(types$1.colon)) {
		prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
		prop.kind = "init";
	} else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
		if (isPattern) this.unexpected();
		prop.method = true;
		prop.value = this.parseMethod(isGenerator, isAsync);
		prop.kind = "init";
	} else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {
		if (isGenerator || isAsync) this.unexpected();
		this.parseGetterSetter(prop);
	} else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
		if (isGenerator || isAsync) this.unexpected();
		this.checkUnreserved(prop.key);
		if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
		if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		else if (this.type === types$1.eq && refDestructuringErrors) {
			if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
			prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		} else prop.value = this.copyNode(prop.key);
		prop.kind = "init";
		prop.shorthand = true;
	} else this.unexpected();
};
pp$5.parsePropertyName = function(prop) {
	if (this.options.ecmaVersion >= 6) if (this.eat(types$1.bracketL)) {
		prop.computed = true;
		prop.key = this.parseMaybeAssign();
		this.expect(types$1.bracketR);
		return prop.key;
	} else prop.computed = false;
	return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
	node.id = null;
	if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
	if (this.options.ecmaVersion >= 8) node.async = false;
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
	var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.initFunction(node);
	if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
	this.expect(types$1.parenL);
	node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
	this.parseFunctionBody(node, false, true, false);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
	this.initFunction(node);
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	node.params = this.toAssignableList(params, true);
	this.parseFunctionBody(node, true, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
	var isExpression = isArrowFunction && this.type !== types$1.braceL;
	var oldStrict = this.strict, useStrict = false;
	if (isExpression) {
		node.body = this.parseMaybeAssign(forInit);
		node.expression = true;
		this.checkParams(node, false);
	} else {
		var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
		if (!oldStrict || nonSimple) {
			useStrict = this.strictDirective(this.end);
			if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
		}
		var oldLabels = this.labels;
		this.labels = [];
		if (useStrict) this.strict = true;
		this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
		if (this.strict && node.id) this.checkLValSimple(node.id, BIND_OUTSIDE);
		node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
		node.expression = false;
		this.adaptDirectivePrologue(node.body.body);
		this.labels = oldLabels;
	}
	this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
	for (var i = 0, list = params; i < list.length; i += 1) if (list[i].type !== "Identifier") return false;
	return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
	var nameHash = Object.create(null);
	for (var i = 0, list = node.params; i < list.length; i += 1) {
		var param = list[i];
		this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
	}
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (!first) {
			this.expect(types$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(close)) break;
		} else first = false;
		var elt = void 0;
		if (allowEmpty && this.type === types$1.comma) elt = null;
		else if (this.type === types$1.ellipsis) {
			elt = this.parseSpread(refDestructuringErrors);
			if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		} else elt = this.parseMaybeAssign(false, refDestructuringErrors);
		elts.push(elt);
	}
	return elts;
};
pp$5.checkUnreserved = function(ref) {
	var start = ref.start;
	var end = ref.end;
	var name = ref.name;
	if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
	if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
	if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
	if (this.inClassStaticBlock && (name === "arguments" || name === "await")) this.raise(start, "Cannot use " + name + " in class static initialization block");
	if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
	if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
	if ((this.strict ? this.reservedWordsStrict : this.reservedWords).test(name)) {
		if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
		this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
	}
};
pp$5.parseIdent = function(liberal) {
	var node = this.parseIdentNode();
	this.next(!!liberal);
	this.finishNode(node, "Identifier");
	if (!liberal) {
		this.checkUnreserved(node);
		if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
	}
	return node;
};
pp$5.parseIdentNode = function() {
	var node = this.startNode();
	if (this.type === types$1.name) node.name = this.value;
	else if (this.type.keyword) {
		node.name = this.type.keyword;
		if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
		this.type = types$1.name;
	} else this.unexpected();
	return node;
};
pp$5.parsePrivateIdent = function() {
	var node = this.startNode();
	if (this.type === types$1.privateId) node.name = this.value;
	else this.unexpected();
	this.next();
	this.finishNode(node, "PrivateIdentifier");
	if (this.options.checkPrivateFields) if (this.privateNameStack.length === 0) this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
	else this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
	return node;
};
pp$5.parseYield = function(forInit) {
	if (!this.yieldPos) this.yieldPos = this.start;
	var node = this.startNode();
	this.next();
	if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
		node.delegate = false;
		node.argument = null;
	} else {
		node.delegate = this.eat(types$1.star);
		node.argument = this.parseMaybeAssign(forInit);
	}
	return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
	if (!this.awaitPos) this.awaitPos = this.start;
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeUnary(null, true, false, forInit);
	return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser$1.prototype;
pp$4.raise = function(pos, message) {
	var loc = getLineInfo(this.input, pos);
	message += " (" + loc.line + ":" + loc.column + ")";
	if (this.sourceFile) message += " in " + this.sourceFile;
	var err = new SyntaxError(message);
	err.pos = pos;
	err.loc = loc;
	err.raisedAt = this.pos;
	throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
	if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
};
var pp$3 = Parser$1.prototype;
var Scope = function Scope(flags) {
	this.flags = flags;
	this.var = [];
	this.lexical = [];
	this.functions = [];
};
pp$3.enterScope = function(flags) {
	this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
	this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
	return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
	var redeclared = false;
	if (bindingType === BIND_LEXICAL) {
		var scope = this.currentScope();
		redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
		scope.lexical.push(name);
		if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
	} else if (bindingType === BIND_SIMPLE_CATCH) this.currentScope().lexical.push(name);
	else if (bindingType === BIND_FUNCTION) {
		var scope$2 = this.currentScope();
		if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
		else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
		scope$2.functions.push(name);
	} else for (var i = this.scopeStack.length - 1; i >= 0; --i) {
		var scope$3 = this.scopeStack[i];
		if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
			redeclared = true;
			break;
		}
		scope$3.var.push(name);
		if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
		if (scope$3.flags & SCOPE_VAR) break;
	}
	if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
};
pp$3.checkLocalExport = function(id) {
	if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
};
pp$3.currentScope = function() {
	return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
	for (var i = this.scopeStack.length - 1;; i--) {
		var scope = this.scopeStack[i];
		if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) return scope;
	}
};
pp$3.currentThisScope = function() {
	for (var i = this.scopeStack.length - 1;; i--) {
		var scope = this.scopeStack[i];
		if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) return scope;
	}
};
var Node = function Node(parser, pos, loc) {
	this.type = "";
	this.start = pos;
	this.end = 0;
	if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
	if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
	if (parser.options.ranges) this.range = [pos, 0];
};
var pp$2 = Parser$1.prototype;
pp$2.startNode = function() {
	return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
	return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
	node.type = type;
	node.end = pos;
	if (this.options.locations) node.loc.end = loc;
	if (this.options.ranges) node.range[1] = pos;
	return node;
}
pp$2.finishNode = function(node, type) {
	return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
	return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
	var newNode = new Node(this, node.start, this.startLoc);
	for (var prop in node) newNode[prop] = node[prop];
	return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
	9: ecma9BinaryProperties,
	10: ecma10BinaryProperties,
	11: ecma11BinaryProperties,
	12: ecma12BinaryProperties,
	13: ecma13BinaryProperties,
	14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
	9: "",
	10: "",
	11: "",
	12: "",
	13: "",
	14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
	9: ecma9ScriptValues,
	10: ecma10ScriptValues,
	11: ecma11ScriptValues,
	12: ecma12ScriptValues,
	13: ecma13ScriptValues,
	14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
	var d = data[ecmaVersion] = {
		binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
		binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
		nonBinary: {
			General_Category: wordsRegexp(unicodeGeneralCategoryValues),
			Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
		}
	};
	d.nonBinary.Script_Extensions = d.nonBinary.Script;
	d.nonBinary.gc = d.nonBinary.General_Category;
	d.nonBinary.sc = d.nonBinary.Script;
	d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (var i$2 = 0, list = [
	9,
	10,
	11,
	12,
	13,
	14
]; i$2 < list.length; i$2 += 1) {
	var ecmaVersion = list[i$2];
	buildUnicodeData(ecmaVersion);
}
var pp$1 = Parser$1.prototype;
var BranchID = function BranchID(parent, base) {
	this.parent = parent;
	this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
	for (var self = this; self; self = self.parent) for (var other = alt; other; other = other.parent) if (self.base === other.base && self !== other) return true;
	return false;
};
BranchID.prototype.sibling = function sibling() {
	return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState(parser) {
	this.parser = parser;
	this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
	this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
	this.source = "";
	this.flags = "";
	this.start = 0;
	this.switchU = false;
	this.switchV = false;
	this.switchN = false;
	this.pos = 0;
	this.lastIntValue = 0;
	this.lastStringValue = "";
	this.lastAssertionIsQuantifiable = false;
	this.numCapturingParens = 0;
	this.maxBackReference = 0;
	this.groupNames = Object.create(null);
	this.backReferenceNames = [];
	this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
	var unicodeSets = flags.indexOf("v") !== -1;
	var unicode = flags.indexOf("u") !== -1;
	this.start = start | 0;
	this.source = pattern + "";
	this.flags = flags;
	if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
		this.switchU = true;
		this.switchV = true;
		this.switchN = true;
	} else {
		this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
		this.switchV = false;
		this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
	}
};
RegExpValidationState.prototype.raise = function raise(message) {
	this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
	if (forceU === void 0) forceU = false;
	var s = this.source;
	var l = s.length;
	if (i >= l) return -1;
	var c = s.charCodeAt(i);
	if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) return c;
	var next = s.charCodeAt(i + 1);
	return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
	if (forceU === void 0) forceU = false;
	var s = this.source;
	var l = s.length;
	if (i >= l) return l;
	var c = s.charCodeAt(i), next;
	if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) return i + 1;
	return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
	if (forceU === void 0) forceU = false;
	this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
	if (forceU === void 0) forceU = false;
	if (this.current(forceU) === ch) {
		this.advance(forceU);
		return true;
	}
	return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
	if (forceU === void 0) forceU = false;
	var pos = this.pos;
	for (var i = 0, list = chs; i < list.length; i += 1) {
		var ch = list[i];
		var current = this.at(pos, forceU);
		if (current === -1 || current !== ch) return false;
		pos = this.nextIndex(pos, forceU);
	}
	this.pos = pos;
	return true;
};
/**
* Validate the flags part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpFlags = function(state) {
	var validFlags = state.validFlags;
	var flags = state.flags;
	var u = false;
	var v = false;
	for (var i = 0; i < flags.length; i++) {
		var flag = flags.charAt(i);
		if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
		if (flags.indexOf(flag, i + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
		if (flag === "u") u = true;
		if (flag === "v") v = true;
	}
	if (this.options.ecmaVersion >= 15 && u && v) this.raise(state.start, "Invalid regular expression flag");
};
function hasProp(obj) {
	for (var _ in obj) return true;
	return false;
}
/**
* Validate the pattern part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpPattern = function(state) {
	this.regexp_pattern(state);
	if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
		state.switchN = true;
		this.regexp_pattern(state);
	}
};
pp$1.regexp_pattern = function(state) {
	state.pos = 0;
	state.lastIntValue = 0;
	state.lastStringValue = "";
	state.lastAssertionIsQuantifiable = false;
	state.numCapturingParens = 0;
	state.maxBackReference = 0;
	state.groupNames = Object.create(null);
	state.backReferenceNames.length = 0;
	state.branchID = null;
	this.regexp_disjunction(state);
	if (state.pos !== state.source.length) {
		if (state.eat(41)) state.raise("Unmatched ')'");
		if (state.eat(93) || state.eat(125)) state.raise("Lone quantifier brackets");
	}
	if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
	for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
		var name = list[i];
		if (!state.groupNames[name]) state.raise("Invalid named capture referenced");
	}
};
pp$1.regexp_disjunction = function(state) {
	var trackDisjunction = this.options.ecmaVersion >= 16;
	if (trackDisjunction) state.branchID = new BranchID(state.branchID, null);
	this.regexp_alternative(state);
	while (state.eat(124)) {
		if (trackDisjunction) state.branchID = state.branchID.sibling();
		this.regexp_alternative(state);
	}
	if (trackDisjunction) state.branchID = state.branchID.parent;
	if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
	if (state.eat(123)) state.raise("Lone quantifier brackets");
};
pp$1.regexp_alternative = function(state) {
	while (state.pos < state.source.length && this.regexp_eatTerm(state));
};
pp$1.regexp_eatTerm = function(state) {
	if (this.regexp_eatAssertion(state)) {
		if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
			if (state.switchU) state.raise("Invalid quantifier");
		}
		return true;
	}
	if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
		this.regexp_eatQuantifier(state);
		return true;
	}
	return false;
};
pp$1.regexp_eatAssertion = function(state) {
	var start = state.pos;
	state.lastAssertionIsQuantifiable = false;
	if (state.eat(94) || state.eat(36)) return true;
	if (state.eat(92)) {
		if (state.eat(66) || state.eat(98)) return true;
		state.pos = start;
	}
	if (state.eat(40) && state.eat(63)) {
		var lookbehind = false;
		if (this.options.ecmaVersion >= 9) lookbehind = state.eat(60);
		if (state.eat(61) || state.eat(33)) {
			this.regexp_disjunction(state);
			if (!state.eat(41)) state.raise("Unterminated group");
			state.lastAssertionIsQuantifiable = !lookbehind;
			return true;
		}
	}
	state.pos = start;
	return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
	if (noError === void 0) noError = false;
	if (this.regexp_eatQuantifierPrefix(state, noError)) {
		state.eat(63);
		return true;
	}
	return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
	return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
	var start = state.pos;
	if (state.eat(123)) {
		var min = 0, max = -1;
		if (this.regexp_eatDecimalDigits(state)) {
			min = state.lastIntValue;
			if (state.eat(44) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
			if (state.eat(125)) {
				if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
				return true;
			}
		}
		if (state.switchU && !noError) state.raise("Incomplete quantifier");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatAtom = function(state) {
	return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatAtomEscape(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
	var start = state.pos;
	if (state.eat(40)) {
		if (state.eat(63)) {
			if (this.options.ecmaVersion >= 16) {
				var addModifiers = this.regexp_eatModifiers(state);
				var hasHyphen = state.eat(45);
				if (addModifiers || hasHyphen) {
					for (var i = 0; i < addModifiers.length; i++) {
						var modifier = addModifiers.charAt(i);
						if (addModifiers.indexOf(modifier, i + 1) > -1) state.raise("Duplicate regular expression modifiers");
					}
					if (hasHyphen) {
						var removeModifiers = this.regexp_eatModifiers(state);
						if (!addModifiers && !removeModifiers && state.current() === 58) state.raise("Invalid regular expression modifiers");
						for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
							var modifier$1 = removeModifiers.charAt(i$1);
							if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) state.raise("Duplicate regular expression modifiers");
						}
					}
				}
			}
			if (state.eat(58)) {
				this.regexp_disjunction(state);
				if (state.eat(41)) return true;
				state.raise("Unterminated group");
			}
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
	if (state.eat(40)) {
		if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
		else if (state.current() === 63) state.raise("Invalid group");
		this.regexp_disjunction(state);
		if (state.eat(41)) {
			state.numCapturingParens += 1;
			return true;
		}
		state.raise("Unterminated group");
	}
	return false;
};
pp$1.regexp_eatModifiers = function(state) {
	var modifiers = "";
	var ch = 0;
	while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
		modifiers += codePointToString(ch);
		state.advance();
	}
	return modifiers;
};
function isRegularExpressionModifier(ch) {
	return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
	return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
	if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
	return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
	var ch = state.current();
	if (isSyntaxCharacter(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isSyntaxCharacter(ch) {
	return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
	var start = state.pos;
	var ch = 0;
	while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) state.advance();
	return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
	var ch = state.current();
	if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_groupSpecifier = function(state) {
	if (state.eat(63)) {
		if (!this.regexp_eatGroupName(state)) state.raise("Invalid group");
		var trackDisjunction = this.options.ecmaVersion >= 16;
		var known = state.groupNames[state.lastStringValue];
		if (known) if (trackDisjunction) {
			for (var i = 0, list = known; i < list.length; i += 1) if (!list[i].separatedFrom(state.branchID)) state.raise("Duplicate capture group name");
		} else state.raise("Duplicate capture group name");
		if (trackDisjunction) (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
		else state.groupNames[state.lastStringValue] = true;
	}
};
pp$1.regexp_eatGroupName = function(state) {
	state.lastStringValue = "";
	if (state.eat(60)) {
		if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) return true;
		state.raise("Invalid capture group name");
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
	state.lastStringValue = "";
	if (this.regexp_eatRegExpIdentifierStart(state)) {
		state.lastStringValue += codePointToString(state.lastIntValue);
		while (this.regexp_eatRegExpIdentifierPart(state)) state.lastStringValue += codePointToString(state.lastIntValue);
		return true;
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierStart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierStart(ch) {
	return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierPart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierPart(ch) {
	return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
	if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
	if (state.switchU) {
		if (state.current() === 99) state.raise("Invalid unicode escape");
		state.raise("Invalid escape");
	}
	return false;
};
pp$1.regexp_eatBackReference = function(state) {
	var start = state.pos;
	if (this.regexp_eatDecimalEscape(state)) {
		var n = state.lastIntValue;
		if (state.switchU) {
			if (n > state.maxBackReference) state.maxBackReference = n;
			return true;
		}
		if (n <= state.numCapturingParens) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatKGroupName = function(state) {
	if (state.eat(107)) {
		if (this.regexp_eatGroupName(state)) {
			state.backReferenceNames.push(state.lastStringValue);
			return true;
		}
		state.raise("Invalid named reference");
	}
	return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
	return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
	var start = state.pos;
	if (state.eat(99)) {
		if (this.regexp_eatControlLetter(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatZero = function(state) {
	if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
		state.lastIntValue = 0;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlEscape = function(state) {
	var ch = state.current();
	if (ch === 116) {
		state.lastIntValue = 9;
		state.advance();
		return true;
	}
	if (ch === 110) {
		state.lastIntValue = 10;
		state.advance();
		return true;
	}
	if (ch === 118) {
		state.lastIntValue = 11;
		state.advance();
		return true;
	}
	if (ch === 102) {
		state.lastIntValue = 12;
		state.advance();
		return true;
	}
	if (ch === 114) {
		state.lastIntValue = 13;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlLetter = function(state) {
	var ch = state.current();
	if (isControlLetter(ch)) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
function isControlLetter(ch) {
	return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
	if (forceU === void 0) forceU = false;
	var start = state.pos;
	var switchU = forceU || state.switchU;
	if (state.eat(117)) {
		if (this.regexp_eatFixedHexDigits(state, 4)) {
			var lead = state.lastIntValue;
			if (switchU && lead >= 55296 && lead <= 56319) {
				var leadSurrogateEnd = state.pos;
				if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
					var trail = state.lastIntValue;
					if (trail >= 56320 && trail <= 57343) {
						state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
						return true;
					}
				}
				state.pos = leadSurrogateEnd;
				state.lastIntValue = lead;
			}
			return true;
		}
		if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) return true;
		if (switchU) state.raise("Invalid unicode escape");
		state.pos = start;
	}
	return false;
};
function isValidUnicode(ch) {
	return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
	if (state.switchU) {
		if (this.regexp_eatSyntaxCharacter(state)) return true;
		if (state.eat(47)) {
			state.lastIntValue = 47;
			return true;
		}
		return false;
	}
	var ch = state.current();
	if (ch !== 99 && (!state.switchN || ch !== 107)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
	state.lastIntValue = 0;
	var ch = state.current();
	if (ch >= 49 && ch <= 57) {
		do {
			state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
			state.advance();
		} while ((ch = state.current()) >= 48 && ch <= 57);
		return true;
	}
	return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
	var ch = state.current();
	if (isCharacterClassEscape(ch)) {
		state.lastIntValue = -1;
		state.advance();
		return CharSetOk;
	}
	var negate = false;
	if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
		state.lastIntValue = -1;
		state.advance();
		var result;
		if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
			if (negate && result === CharSetString) state.raise("Invalid property name");
			return result;
		}
		state.raise("Invalid property name");
	}
	return CharSetNone;
};
function isCharacterClassEscape(ch) {
	return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
	var start = state.pos;
	if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
		var name = state.lastStringValue;
		if (this.regexp_eatUnicodePropertyValue(state)) {
			var value = state.lastStringValue;
			this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
			return CharSetOk;
		}
	}
	state.pos = start;
	if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
		var nameOrValue = state.lastStringValue;
		return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
	}
	return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
	if (!hasOwn(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
	if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
	if (state.unicodeProperties.binary.test(nameOrValue)) return CharSetOk;
	if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) return CharSetString;
	state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyNameCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
	return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyValueCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
	return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
	return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
	if (state.eat(91)) {
		var negate = state.eat(94);
		var result = this.regexp_classContents(state);
		if (!state.eat(93)) state.raise("Unterminated character class");
		if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
		return true;
	}
	return false;
};
pp$1.regexp_classContents = function(state) {
	if (state.current() === 93) return CharSetOk;
	if (state.switchV) return this.regexp_classSetExpression(state);
	this.regexp_nonEmptyClassRanges(state);
	return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
	while (this.regexp_eatClassAtom(state)) {
		var left = state.lastIntValue;
		if (state.eat(45) && this.regexp_eatClassAtom(state)) {
			var right = state.lastIntValue;
			if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
		}
	}
};
pp$1.regexp_eatClassAtom = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatClassEscape(state)) return true;
		if (state.switchU) {
			var ch$1 = state.current();
			if (ch$1 === 99 || isOctalDigit(ch$1)) state.raise("Invalid class escape");
			state.raise("Invalid escape");
		}
		state.pos = start;
	}
	var ch = state.current();
	if (ch !== 93) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatClassEscape = function(state) {
	var start = state.pos;
	if (state.eat(98)) {
		state.lastIntValue = 8;
		return true;
	}
	if (state.switchU && state.eat(45)) {
		state.lastIntValue = 45;
		return true;
	}
	if (!state.switchU && state.eat(99)) {
		if (this.regexp_eatClassControlLetter(state)) return true;
		state.pos = start;
	}
	return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
	var result = CharSetOk, subResult;
	if (this.regexp_eatClassSetRange(state));
	else if (subResult = this.regexp_eatClassSetOperand(state)) {
		if (subResult === CharSetString) result = CharSetString;
		var start = state.pos;
		while (state.eatChars([38, 38])) {
			if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
				if (subResult !== CharSetString) result = CharSetOk;
				continue;
			}
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
		while (state.eatChars([45, 45])) {
			if (this.regexp_eatClassSetOperand(state)) continue;
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
	} else state.raise("Invalid character in character class");
	for (;;) {
		if (this.regexp_eatClassSetRange(state)) continue;
		subResult = this.regexp_eatClassSetOperand(state);
		if (!subResult) return result;
		if (subResult === CharSetString) result = CharSetString;
	}
};
pp$1.regexp_eatClassSetRange = function(state) {
	var start = state.pos;
	if (this.regexp_eatClassSetCharacter(state)) {
		var left = state.lastIntValue;
		if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
			var right = state.lastIntValue;
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
			return true;
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
	if (this.regexp_eatClassSetCharacter(state)) return CharSetOk;
	return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
	var start = state.pos;
	if (state.eat(91)) {
		var negate = state.eat(94);
		var result = this.regexp_classContents(state);
		if (state.eat(93)) {
			if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
			return result;
		}
		state.pos = start;
	}
	if (state.eat(92)) {
		var result$1 = this.regexp_eatCharacterClassEscape(state);
		if (result$1) return result$1;
		state.pos = start;
	}
	return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
	var start = state.pos;
	if (state.eatChars([92, 113])) {
		if (state.eat(123)) {
			var result = this.regexp_classStringDisjunctionContents(state);
			if (state.eat(125)) return result;
		} else state.raise("Invalid escape");
		state.pos = start;
	}
	return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
	var result = this.regexp_classString(state);
	while (state.eat(124)) if (this.regexp_classString(state) === CharSetString) result = CharSetString;
	return result;
};
pp$1.regexp_classString = function(state) {
	var count = 0;
	while (this.regexp_eatClassSetCharacter(state)) count++;
	return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) return true;
		if (state.eat(98)) {
			state.lastIntValue = 8;
			return true;
		}
		state.pos = start;
		return false;
	}
	var ch = state.current();
	if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) return false;
	if (isClassSetSyntaxCharacter(ch)) return false;
	state.advance();
	state.lastIntValue = ch;
	return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
	return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
	return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
	var ch = state.current();
	if (isClassSetReservedPunctuator(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isClassSetReservedPunctuator(ch) {
	return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
	var ch = state.current();
	if (isDecimalDigit(ch) || ch === 95) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
	var start = state.pos;
	if (state.eat(120)) {
		if (this.regexp_eatFixedHexDigits(state, 2)) return true;
		if (state.switchU) state.raise("Invalid escape");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isDecimalDigit(ch = state.current())) {
		state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
		state.advance();
	}
	return state.pos !== start;
};
function isDecimalDigit(ch) {
	return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isHexDigit(ch = state.current())) {
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return state.pos !== start;
};
function isHexDigit(ch) {
	return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
	if (ch >= 65 && ch <= 70) return 10 + (ch - 65);
	if (ch >= 97 && ch <= 102) return 10 + (ch - 97);
	return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
	if (this.regexp_eatOctalDigit(state)) {
		var n1 = state.lastIntValue;
		if (this.regexp_eatOctalDigit(state)) {
			var n2 = state.lastIntValue;
			if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
			else state.lastIntValue = n1 * 8 + n2;
		} else state.lastIntValue = n1;
		return true;
	}
	return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
	var ch = state.current();
	if (isOctalDigit(ch)) {
		state.lastIntValue = ch - 48;
		state.advance();
		return true;
	}
	state.lastIntValue = 0;
	return false;
};
function isOctalDigit(ch) {
	return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
	var start = state.pos;
	state.lastIntValue = 0;
	for (var i = 0; i < length; ++i) {
		var ch = state.current();
		if (!isHexDigit(ch)) {
			state.pos = start;
			return false;
		}
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return true;
};
var Token = function Token(p) {
	this.type = p.type;
	this.value = p.value;
	this.start = p.start;
	this.end = p.end;
	if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
	if (p.options.ranges) this.range = [p.start, p.end];
};
var pp = Parser$1.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
	if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
	if (this.options.onToken) this.options.onToken(new Token(this));
	this.lastTokEnd = this.end;
	this.lastTokStart = this.start;
	this.lastTokEndLoc = this.endLoc;
	this.lastTokStartLoc = this.startLoc;
	this.nextToken();
};
pp.getToken = function() {
	this.next();
	return new Token(this);
};
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function() {
	var this$1$1 = this;
	return { next: function() {
		var token = this$1$1.getToken();
		return {
			done: token.type === types$1.eof,
			value: token
		};
	} };
};
pp.nextToken = function() {
	var curContext = this.curContext();
	if (!curContext || !curContext.preserveSpace) this.skipSpace();
	this.start = this.pos;
	if (this.options.locations) this.startLoc = this.curPosition();
	if (this.pos >= this.input.length) return this.finishToken(types$1.eof);
	if (curContext.override) return curContext.override(this);
	else this.readToken(this.fullCharCodeAtPos());
};
pp.readToken = function(code) {
	if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) return this.readWord();
	return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
	var code = this.input.charCodeAt(this.pos);
	if (code <= 55295 || code >= 56320) return code;
	var next = this.input.charCodeAt(this.pos + 1);
	return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
	var startLoc = this.options.onComment && this.curPosition();
	var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
	if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	this.pos = end + 2;
	if (this.options.locations) for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
		++this.curLine;
		pos = this.lineStart = nextBreak;
	}
	if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};
pp.skipLineComment = function(startSkip) {
	var start = this.pos;
	var startLoc = this.options.onComment && this.curPosition();
	var ch = this.input.charCodeAt(this.pos += startSkip);
	while (this.pos < this.input.length && !isNewLine(ch)) ch = this.input.charCodeAt(++this.pos);
	if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
pp.skipSpace = function() {
	loop: while (this.pos < this.input.length) {
		var ch = this.input.charCodeAt(this.pos);
		switch (ch) {
			case 32:
			case 160:
				++this.pos;
				break;
			case 13: if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
			case 10:
			case 8232:
			case 8233:
				++this.pos;
				if (this.options.locations) {
					++this.curLine;
					this.lineStart = this.pos;
				}
				break;
			case 47:
				switch (this.input.charCodeAt(this.pos + 1)) {
					case 42:
						this.skipBlockComment();
						break;
					case 47:
						this.skipLineComment(2);
						break;
					default: break loop;
				}
				break;
			default: if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
			else break loop;
		}
	}
};
pp.finishToken = function(type, val) {
	this.end = this.pos;
	if (this.options.locations) this.endLoc = this.curPosition();
	var prevType = this.type;
	this.type = type;
	this.value = val;
	this.updateContext(prevType);
};
pp.readToken_dot = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next >= 48 && next <= 57) return this.readNumber(true);
	var next2 = this.input.charCodeAt(this.pos + 2);
	if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
		this.pos += 3;
		return this.finishToken(types$1.ellipsis);
	} else {
		++this.pos;
		return this.finishToken(types$1.dot);
	}
};
pp.readToken_slash = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (this.exprAllowed) {
		++this.pos;
		return this.readRegexp();
	}
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	var tokentype = code === 42 ? types$1.star : types$1.modulo;
	if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
		++size;
		tokentype = types$1.starstar;
		next = this.input.charCodeAt(this.pos + 2);
	}
	if (next === 61) return this.finishOp(types$1.assign, size + 1);
	return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (this.options.ecmaVersion >= 12) {
			if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1.assign, 3);
		}
		return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
	}
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
	if (this.input.charCodeAt(this.pos + 1) === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
			this.skipLineComment(3);
			this.skipSpace();
			return this.nextToken();
		}
		return this.finishOp(types$1.incDec, 2);
	}
	if (next === 61) return this.finishOp(types$1.assign, 2);
	return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	if (next === code) {
		size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
		if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types$1.assign, size + 1);
		return this.finishOp(types$1.bitShift, size);
	}
	if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
		this.skipLineComment(4);
		this.skipSpace();
		return this.nextToken();
	}
	if (next === 61) size = 2;
	return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === 61) return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
		this.pos += 2;
		return this.finishToken(types$1.arrow);
	}
	return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
	var ecmaVersion = this.options.ecmaVersion;
	if (ecmaVersion >= 11) {
		var next = this.input.charCodeAt(this.pos + 1);
		if (next === 46) {
			var next2 = this.input.charCodeAt(this.pos + 2);
			if (next2 < 48 || next2 > 57) return this.finishOp(types$1.questionDot, 2);
		}
		if (next === 63) {
			if (ecmaVersion >= 12) {
				if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1.assign, 3);
			}
			return this.finishOp(types$1.coalesce, 2);
		}
	}
	return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
	var ecmaVersion = this.options.ecmaVersion;
	var code = 35;
	if (ecmaVersion >= 13) {
		++this.pos;
		code = this.fullCharCodeAtPos();
		if (isIdentifierStart(code, true) || code === 92) return this.finishToken(types$1.privateId, this.readWord1());
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
	switch (code) {
		case 46: return this.readToken_dot();
		case 40:
			++this.pos;
			return this.finishToken(types$1.parenL);
		case 41:
			++this.pos;
			return this.finishToken(types$1.parenR);
		case 59:
			++this.pos;
			return this.finishToken(types$1.semi);
		case 44:
			++this.pos;
			return this.finishToken(types$1.comma);
		case 91:
			++this.pos;
			return this.finishToken(types$1.bracketL);
		case 93:
			++this.pos;
			return this.finishToken(types$1.bracketR);
		case 123:
			++this.pos;
			return this.finishToken(types$1.braceL);
		case 125:
			++this.pos;
			return this.finishToken(types$1.braceR);
		case 58:
			++this.pos;
			return this.finishToken(types$1.colon);
		case 96:
			if (this.options.ecmaVersion < 6) break;
			++this.pos;
			return this.finishToken(types$1.backQuote);
		case 48:
			var next = this.input.charCodeAt(this.pos + 1);
			if (next === 120 || next === 88) return this.readRadixNumber(16);
			if (this.options.ecmaVersion >= 6) {
				if (next === 111 || next === 79) return this.readRadixNumber(8);
				if (next === 98 || next === 66) return this.readRadixNumber(2);
			}
		case 49:
		case 50:
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57: return this.readNumber(false);
		case 34:
		case 39: return this.readString(code);
		case 47: return this.readToken_slash();
		case 37:
		case 42: return this.readToken_mult_modulo_exp(code);
		case 124:
		case 38: return this.readToken_pipe_amp(code);
		case 94: return this.readToken_caret();
		case 43:
		case 45: return this.readToken_plus_min(code);
		case 60:
		case 62: return this.readToken_lt_gt(code);
		case 61:
		case 33: return this.readToken_eq_excl(code);
		case 63: return this.readToken_question();
		case 126: return this.finishOp(types$1.prefix, 1);
		case 35: return this.readToken_numberSign();
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
	var str = this.input.slice(this.pos, this.pos + size);
	this.pos += size;
	return this.finishToken(type, str);
};
pp.readRegexp = function() {
	var escaped, inClass, start = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
		var ch = this.input.charAt(this.pos);
		if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
		if (!escaped) {
			if (ch === "[") inClass = true;
			else if (ch === "]" && inClass) inClass = false;
			else if (ch === "/" && !inClass) break;
			escaped = ch === "\\";
		} else escaped = false;
		++this.pos;
	}
	var pattern = this.input.slice(start, this.pos);
	++this.pos;
	var flagsStart = this.pos;
	var flags = this.readWord1();
	if (this.containsEsc) this.unexpected(flagsStart);
	var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
	state.reset(start, pattern, flags);
	this.validateRegExpFlags(state);
	this.validateRegExpPattern(state);
	var value = null;
	try {
		value = new RegExp(pattern, flags);
	} catch (e) {}
	return this.finishToken(types$1.regexp, {
		pattern,
		flags,
		value
	});
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
	var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
	var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
	var start = this.pos, total = 0, lastCode = 0;
	for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
		var code = this.input.charCodeAt(this.pos), val = void 0;
		if (allowSeparators && code === 95) {
			if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
			if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
			if (i === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
			lastCode = code;
			continue;
		}
		if (code >= 97) val = code - 97 + 10;
		else if (code >= 65) val = code - 65 + 10;
		else if (code >= 48 && code <= 57) val = code - 48;
		else val = Infinity;
		if (val >= radix) break;
		lastCode = code;
		total = total * radix + val;
	}
	if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
	if (this.pos === start || len != null && this.pos - start !== len) return null;
	return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
	if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
	return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
	if (typeof BigInt !== "function") return null;
	return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
	var start = this.pos;
	this.pos += 2;
	var val = this.readInt(radix);
	if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
		val = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
	} else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
	var start = this.pos;
	if (!startsWithDot && this.readInt(10, void 0, true) === null) this.raise(start, "Invalid number");
	var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
	if (octal && this.strict) this.raise(start, "Invalid number");
	var next = this.input.charCodeAt(this.pos);
	if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
		var val$1 = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
		if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
		return this.finishToken(types$1.num, val$1);
	}
	if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
	if (next === 46 && !octal) {
		++this.pos;
		this.readInt(10);
		next = this.input.charCodeAt(this.pos);
	}
	if ((next === 69 || next === 101) && !octal) {
		next = this.input.charCodeAt(++this.pos);
		if (next === 43 || next === 45) ++this.pos;
		if (this.readInt(10) === null) this.raise(start, "Invalid number");
	}
	if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	var val = stringToNumber(this.input.slice(start, this.pos), octal);
	return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
	var ch = this.input.charCodeAt(this.pos), code;
	if (ch === 123) {
		if (this.options.ecmaVersion < 6) this.unexpected();
		var codePos = ++this.pos;
		code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
		++this.pos;
		if (code > 1114111) this.invalidStringToken(codePos, "Code point out of bounds");
	} else code = this.readHexChar(4);
	return code;
};
pp.readString = function(quote) {
	var out = "", chunkStart = ++this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === quote) break;
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(false);
			chunkStart = this.pos;
		} else if (ch === 8232 || ch === 8233) {
			if (this.options.ecmaVersion < 10) this.raise(this.start, "Unterminated string constant");
			++this.pos;
			if (this.options.locations) {
				this.curLine++;
				this.lineStart = this.pos;
			}
		} else {
			if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
			++this.pos;
		}
	}
	out += this.input.slice(chunkStart, this.pos++);
	return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
	this.inTemplateElement = true;
	try {
		this.readTmplToken();
	} catch (err) {
		if (err === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
		else throw err;
	}
	this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
	if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
	else this.raise(position, message);
};
pp.readTmplToken = function() {
	var out = "", chunkStart = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
			if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) if (ch === 36) {
				this.pos += 2;
				return this.finishToken(types$1.dollarBraceL);
			} else {
				++this.pos;
				return this.finishToken(types$1.backQuote);
			}
			out += this.input.slice(chunkStart, this.pos);
			return this.finishToken(types$1.template, out);
		}
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(true);
			chunkStart = this.pos;
		} else if (isNewLine(ch)) {
			out += this.input.slice(chunkStart, this.pos);
			++this.pos;
			switch (ch) {
				case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
				case 10:
					out += "\n";
					break;
				default:
					out += String.fromCharCode(ch);
					break;
			}
			if (this.options.locations) {
				++this.curLine;
				this.lineStart = this.pos;
			}
			chunkStart = this.pos;
		} else ++this.pos;
	}
};
pp.readInvalidTemplateToken = function() {
	for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
		case "\\":
			++this.pos;
			break;
		case "$": if (this.input[this.pos + 1] !== "{") break;
		case "`": return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
		case "\r": if (this.input[this.pos + 1] === "\n") ++this.pos;
		case "\n":
		case "\u2028":
		case "\u2029":
			++this.curLine;
			this.lineStart = this.pos + 1;
			break;
	}
	this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
	var ch = this.input.charCodeAt(++this.pos);
	++this.pos;
	switch (ch) {
		case 110: return "\n";
		case 114: return "\r";
		case 120: return String.fromCharCode(this.readHexChar(2));
		case 117: return codePointToString(this.readCodePoint());
		case 116: return "	";
		case 98: return "\b";
		case 118: return "\v";
		case 102: return "\f";
		case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
		case 10:
			if (this.options.locations) {
				this.lineStart = this.pos;
				++this.curLine;
			}
			return "";
		case 56:
		case 57:
			if (this.strict) this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
			if (inTemplate) {
				var codePos = this.pos - 1;
				this.invalidStringToken(codePos, "Invalid escape sequence in template string");
			}
		default:
			if (ch >= 48 && ch <= 55) {
				var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
				var octal = parseInt(octalStr, 8);
				if (octal > 255) {
					octalStr = octalStr.slice(0, -1);
					octal = parseInt(octalStr, 8);
				}
				this.pos += octalStr.length - 1;
				ch = this.input.charCodeAt(this.pos);
				if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
				return String.fromCharCode(octal);
			}
			if (isNewLine(ch)) {
				if (this.options.locations) {
					this.lineStart = this.pos;
					++this.curLine;
				}
				return "";
			}
			return String.fromCharCode(ch);
	}
};
pp.readHexChar = function(len) {
	var codePos = this.pos;
	var n = this.readInt(16, len);
	if (n === null) this.invalidStringToken(codePos, "Bad character escape sequence");
	return n;
};
pp.readWord1 = function() {
	this.containsEsc = false;
	var word = "", first = true, chunkStart = this.pos;
	var astral = this.options.ecmaVersion >= 6;
	while (this.pos < this.input.length) {
		var ch = this.fullCharCodeAtPos();
		if (isIdentifierChar(ch, astral)) this.pos += ch <= 65535 ? 1 : 2;
		else if (ch === 92) {
			this.containsEsc = true;
			word += this.input.slice(chunkStart, this.pos);
			var escStart = this.pos;
			if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
			++this.pos;
			var esc = this.readCodePoint();
			if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
			word += codePointToString(esc);
			chunkStart = this.pos;
		} else break;
		first = false;
	}
	return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
	var word = this.readWord1();
	var type = types$1.name;
	if (this.keywords.test(word)) type = keywords[word];
	return this.finishToken(type, word);
};
var version = "8.15.0";
Parser$1.acorn = {
	Parser: Parser$1,
	version,
	defaultOptions,
	Position,
	SourceLocation,
	getLineInfo,
	Node,
	TokenType,
	tokTypes: types$1,
	keywordTypes: keywords,
	TokContext,
	tokContexts: types$2,
	isIdentifierChar,
	isIdentifierStart,
	Token,
	isNewLine,
	lineBreak,
	lineBreakG,
	nonASCIIwhitespace
};

//#endregion
//#region ../../node_modules/.pnpm/mlly@1.8.0/node_modules/mlly/dist/index.mjs
const BUILTIN_MODULES = new Set(builtinModules);
function normalizeSlash(path) {
	return path.replace(/\\/g, "/");
}
/**
* @typedef ErrnoExceptionFields
* @property {number | undefined} [errnode]
* @property {string | undefined} [code]
* @property {string | undefined} [path]
* @property {string | undefined} [syscall]
* @property {string | undefined} [url]
*
* @typedef {Error & ErrnoExceptionFields} ErrnoException
*/
const own$1 = {}.hasOwnProperty;
const classRegExp = /^([A-Z][a-z\d]*)+$/;
const kTypes = new Set([
	"string",
	"function",
	"number",
	"object",
	"Function",
	"Object",
	"boolean",
	"bigint",
	"symbol"
]);
const codes = {};
/**
* Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.
* We cannot use Intl.ListFormat because it's not available in
* --without-intl builds.
*
* @param {Array<string>} array
*   An array of strings.
* @param {string} [type]
*   The list type to be inserted before the last element.
* @returns {string}
*/
function formatList(array, type = "and") {
	return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
/** @type {Map<string, MessageFunction | string>} */
const messages = /* @__PURE__ */ new Map();
const nodeInternalPrefix = "__node_internal_";
/** @type {number} */
let userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError(
	"ERR_INVALID_ARG_TYPE",
	/**
	* @param {string} name
	* @param {Array<string> | string} expected
	* @param {unknown} actual
	*/
	(name, expected, actual) => {
		assert(typeof name === "string", "'name' must be a string");
		if (!Array.isArray(expected)) expected = [expected];
		let message = "The ";
		if (name.endsWith(" argument")) message += `${name} `;
		else {
			const type = name.includes(".") ? "property" : "argument";
			message += `"${name}" ${type} `;
		}
		message += "must be ";
		/** @type {Array<string>} */
		const types = [];
		/** @type {Array<string>} */
		const instances = [];
		/** @type {Array<string>} */
		const other = [];
		for (const value of expected) {
			assert(typeof value === "string", "All expected entries have to be of type string");
			if (kTypes.has(value)) types.push(value.toLowerCase());
			else if (classRegExp.exec(value) === null) {
				assert(value !== "object", "The value \"object\" should be written as \"Object\"");
				other.push(value);
			} else instances.push(value);
		}
		if (instances.length > 0) {
			const pos = types.indexOf("object");
			if (pos !== -1) {
				types.slice(pos, 1);
				instances.push("Object");
			}
		}
		if (types.length > 0) {
			message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(types, "or")}`;
			if (instances.length > 0 || other.length > 0) message += " or ";
		}
		if (instances.length > 0) {
			message += `an instance of ${formatList(instances, "or")}`;
			if (other.length > 0) message += " or ";
		}
		if (other.length > 0) if (other.length > 1) message += `one of ${formatList(other, "or")}`;
		else {
			if (other[0].toLowerCase() !== other[0]) message += "an ";
			message += `${other[0]}`;
		}
		message += `. Received ${determineSpecificType(actual)}`;
		return message;
	},
	TypeError
);
codes.ERR_INVALID_MODULE_SPECIFIER = createError(
	"ERR_INVALID_MODULE_SPECIFIER",
	/**
	* @param {string} request
	* @param {string} reason
	* @param {string} [base]
	*/
	(request, reason, base = void 0) => {
		return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
	},
	TypeError
);
codes.ERR_INVALID_PACKAGE_CONFIG = createError(
	"ERR_INVALID_PACKAGE_CONFIG",
	/**
	* @param {string} path
	* @param {string} [base]
	* @param {string} [message]
	*/
	(path, base, message) => {
		return `Invalid package config ${path}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
	},
	Error
);
codes.ERR_INVALID_PACKAGE_TARGET = createError(
	"ERR_INVALID_PACKAGE_TARGET",
	/**
	* @param {string} packagePath
	* @param {string} key
	* @param {unknown} target
	* @param {boolean} [isImport=false]
	* @param {string} [base]
	*/
	(packagePath, key, target, isImport = false, base = void 0) => {
		const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
		if (key === ".") {
			assert(isImport === false);
			return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? "; targets must start with \"./\"" : ""}`;
		}
		return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? "; targets must start with \"./\"" : ""}`;
	},
	Error
);
codes.ERR_MODULE_NOT_FOUND = createError(
	"ERR_MODULE_NOT_FOUND",
	/**
	* @param {string} path
	* @param {string} base
	* @param {boolean} [exactUrl]
	*/
	(path, base, exactUrl = false) => {
		return `Cannot find ${exactUrl ? "module" : "package"} '${path}' imported from ${base}`;
	},
	Error
);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
	"ERR_PACKAGE_IMPORT_NOT_DEFINED",
	/**
	* @param {string} specifier
	* @param {string} packagePath
	* @param {string} base
	*/
	(specifier, packagePath, base) => {
		return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
	},
	TypeError
);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
	"ERR_PACKAGE_PATH_NOT_EXPORTED",
	/**
	* @param {string} packagePath
	* @param {string} subpath
	* @param {string} [base]
	*/
	(packagePath, subpath, base = void 0) => {
		if (subpath === ".") return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
		return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
	},
	Error
);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error);
codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", "Failed to resolve module specifier \"%s\" from \"%s\": Invalid relative URL or base scheme is not hierarchical.", TypeError);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
	"ERR_UNKNOWN_FILE_EXTENSION",
	/**
	* @param {string} extension
	* @param {string} path
	*/
	(extension, path) => {
		return `Unknown file extension "${extension}" for ${path}`;
	},
	TypeError
);
codes.ERR_INVALID_ARG_VALUE = createError(
	"ERR_INVALID_ARG_VALUE",
	/**
	* @param {string} name
	* @param {unknown} value
	* @param {string} [reason='is invalid']
	*/
	(name, value, reason = "is invalid") => {
		let inspected = inspect(value);
		if (inspected.length > 128) inspected = `${inspected.slice(0, 128)}...`;
		return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
	},
	TypeError
);
/**
* Utility function for registering the error codes. Only used here. Exported
* *only* to allow for testing.
* @param {string} sym
* @param {MessageFunction | string} value
* @param {ErrorConstructor} constructor
* @returns {new (...parameters: Array<any>) => Error}
*/
function createError(sym, value, constructor) {
	messages.set(sym, value);
	return makeNodeErrorWithCode(constructor, sym);
}
/**
* @param {ErrorConstructor} Base
* @param {string} key
* @returns {ErrorConstructor}
*/
function makeNodeErrorWithCode(Base, key) {
	return NodeError;
	/**
	* @param {Array<unknown>} parameters
	*/
	function NodeError(...parameters) {
		const limit = Error.stackTraceLimit;
		if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
		const error = new Base();
		if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
		const message = getMessage(key, parameters, error);
		Object.defineProperties(error, {
			message: {
				value: message,
				enumerable: false,
				writable: true,
				configurable: true
			},
			toString: {
				value() {
					return `${this.name} [${key}]: ${this.message}`;
				},
				enumerable: false,
				writable: true,
				configurable: true
			}
		});
		captureLargerStackTrace(error);
		error.code = key;
		return error;
	}
}
/**
* @returns {boolean}
*/
function isErrorStackTraceLimitWritable() {
	try {
		if (v8.startupSnapshot.isBuildingSnapshot()) return false;
	} catch {}
	const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
	if (desc === void 0) return Object.isExtensible(Error);
	return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
/**
* This function removes unnecessary frames from Node.js core errors.
* @template {(...parameters: unknown[]) => unknown} T
* @param {T} wrappedFunction
* @returns {T}
*/
function hideStackFrames(wrappedFunction) {
	const hidden = nodeInternalPrefix + wrappedFunction.name;
	Object.defineProperty(wrappedFunction, "name", { value: hidden });
	return wrappedFunction;
}
const captureLargerStackTrace = hideStackFrames(
	/**
	* @param {Error} error
	* @returns {Error}
	*/
	function(error) {
		const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
		if (stackTraceLimitIsWritable) {
			userStackTraceLimit = Error.stackTraceLimit;
			Error.stackTraceLimit = Number.POSITIVE_INFINITY;
		}
		Error.captureStackTrace(error);
		if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
		return error;
	}
);
/**
* @param {string} key
* @param {Array<unknown>} parameters
* @param {Error} self
* @returns {string}
*/
function getMessage(key, parameters, self) {
	const message = messages.get(key);
	assert(message !== void 0, "expected `message` to be found");
	if (typeof message === "function") {
		assert(message.length <= parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`);
		return Reflect.apply(message, self, parameters);
	}
	const regex = /%[dfijoOs]/g;
	let expectedLength = 0;
	while (regex.exec(message) !== null) expectedLength++;
	assert(expectedLength === parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`);
	if (parameters.length === 0) return message;
	parameters.unshift(message);
	return Reflect.apply(format, null, parameters);
}
/**
* Determine the specific type of a value for type-mismatch errors.
* @param {unknown} value
* @returns {string}
*/
function determineSpecificType(value) {
	if (value === null || value === void 0) return String(value);
	if (typeof value === "function" && value.name) return `function ${value.name}`;
	if (typeof value === "object") {
		if (value.constructor && value.constructor.name) return `an instance of ${value.constructor.name}`;
		return `${inspect(value, { depth: -1 })}`;
	}
	let inspected = inspect(value, { colors: false });
	if (inspected.length > 28) inspected = `${inspected.slice(0, 25)}...`;
	return `type ${typeof value} (${inspected})`;
}
const hasOwnProperty$1 = {}.hasOwnProperty;
const { ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1 } = codes;
/** @type {Map<string, PackageConfig>} */
const cache = /* @__PURE__ */ new Map();
/**
* @param {string} jsonPath
* @param {{specifier: URL | string, base?: URL}} options
* @returns {PackageConfig}
*/
function read(jsonPath, { base, specifier }) {
	const existing = cache.get(jsonPath);
	if (existing) return existing;
	/** @type {string | undefined} */
	let string;
	try {
		string = fs.readFileSync(path.toNamespacedPath(jsonPath), "utf8");
	} catch (error) {
		const exception = error;
		if (exception.code !== "ENOENT") throw exception;
	}
	/** @type {PackageConfig} */
	const result = {
		exists: false,
		pjsonPath: jsonPath,
		main: void 0,
		name: void 0,
		type: "none",
		exports: void 0,
		imports: void 0
	};
	if (string !== void 0) {
		/** @type {Record<string, unknown>} */
		let parsed;
		try {
			parsed = JSON.parse(string);
		} catch (error_) {
			const cause = error_;
			const error = new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath, (base ? `"${specifier}" from ` : "") + fileURLToPath(base || specifier), cause.message);
			error.cause = cause;
			throw error;
		}
		result.exists = true;
		if (hasOwnProperty$1.call(parsed, "name") && typeof parsed.name === "string") result.name = parsed.name;
		if (hasOwnProperty$1.call(parsed, "main") && typeof parsed.main === "string") result.main = parsed.main;
		if (hasOwnProperty$1.call(parsed, "exports")) result.exports = parsed.exports;
		if (hasOwnProperty$1.call(parsed, "imports")) result.imports = parsed.imports;
		if (hasOwnProperty$1.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) result.type = parsed.type;
	}
	cache.set(jsonPath, result);
	return result;
}
/**
* @param {URL | string} resolved
* @returns {PackageConfig}
*/
function getPackageScopeConfig(resolved) {
	let packageJSONUrl = new URL("package.json", resolved);
	while (true) {
		if (packageJSONUrl.pathname.endsWith("node_modules/package.json")) break;
		const packageConfig = read(fileURLToPath(packageJSONUrl), { specifier: resolved });
		if (packageConfig.exists) return packageConfig;
		const lastPackageJSONUrl = packageJSONUrl;
		packageJSONUrl = new URL("../package.json", packageJSONUrl);
		if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;
	}
	return {
		pjsonPath: fileURLToPath(packageJSONUrl),
		exists: false,
		type: "none"
	};
}
/**
* Returns the package type for a given URL.
* @param {URL} url - The URL to get the package type for.
* @returns {PackageType}
*/
function getPackageType(url) {
	return getPackageScopeConfig(url).type;
}
const { ERR_UNKNOWN_FILE_EXTENSION } = codes;
const hasOwnProperty = {}.hasOwnProperty;
/** @type {Record<string, string>} */
const extensionFormatMap = {
	__proto__: null,
	".cjs": "commonjs",
	".js": "module",
	".json": "json",
	".mjs": "module"
};
/**
* @param {string | null} mime
* @returns {string | null}
*/
function mimeToFormat(mime) {
	if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)) return "module";
	if (mime === "application/json") return "json";
	return null;
}
/**
* @callback ProtocolHandler
* @param {URL} parsed
* @param {{parentURL: string, source?: Buffer}} context
* @param {boolean} ignoreErrors
* @returns {string | null | void}
*/
/**
* @type {Record<string, ProtocolHandler>}
*/
const protocolHandlers = {
	__proto__: null,
	"data:": getDataProtocolModuleFormat,
	"file:": getFileProtocolModuleFormat,
	"http:": getHttpProtocolModuleFormat,
	"https:": getHttpProtocolModuleFormat,
	"node:"() {
		return "builtin";
	}
};
/**
* @param {URL} parsed
*/
function getDataProtocolModuleFormat(parsed) {
	const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [
		null,
		null,
		null
	];
	return mimeToFormat(mime);
}
/**
* Returns the file extension from a URL.
*
* Should give similar result to
* `require('node:path').extname(require('node:url').fileURLToPath(url))`
* when used with a `file:` URL.
*
* @param {URL} url
* @returns {string}
*/
function extname$2(url) {
	const pathname = url.pathname;
	let index = pathname.length;
	while (index--) {
		const code = pathname.codePointAt(index);
		if (code === 47) return "";
		if (code === 46) return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
	}
	return "";
}
/**
* @type {ProtocolHandler}
*/
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
	const value = extname$2(url);
	if (value === ".js") {
		const packageType = getPackageType(url);
		if (packageType !== "none") return packageType;
		return "commonjs";
	}
	if (value === "") {
		const packageType = getPackageType(url);
		if (packageType === "none" || packageType === "commonjs") return "commonjs";
		return "module";
	}
	const format = extensionFormatMap[value];
	if (format) return format;
	if (ignoreErrors) return;
	throw new ERR_UNKNOWN_FILE_EXTENSION(value, fileURLToPath(url));
}
function getHttpProtocolModuleFormat() {}
/**
* @param {URL} url
* @param {{parentURL: string}} context
* @returns {string | null}
*/
function defaultGetFormatWithoutErrors(url, context) {
	const protocol = url.protocol;
	if (!hasOwnProperty.call(protocolHandlers, protocol)) return null;
	return protocolHandlers[protocol](url, context, true) || null;
}
const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
const { ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_RESOLVE_REQUEST } = codes;
const own = {}.hasOwnProperty;
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
const deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const invalidPackageNameRegEx = /^\.|%|\\/;
const patternRegEx = /\*/g;
const encodedSeparatorRegEx = /%2f|%5c/i;
/** @type {Set<string>} */
const emittedPackageWarnings = /* @__PURE__ */ new Set();
const doubleSlashRegEx = /[/\\]{2}/;
/**
*
* @param {string} target
* @param {string} request
* @param {string} match
* @param {URL} packageJsonUrl
* @param {boolean} internal
* @param {URL} base
* @param {boolean} isTarget
*/
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
	if (process$1.noDeprecation) return;
	const pjsonPath = fileURLToPath(packageJsonUrl);
	const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
	process$1.emitWarning(`Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}.`, "DeprecationWarning", "DEP0166");
}
/**
* @param {URL} url
* @param {URL} packageJsonUrl
* @param {URL} base
* @param {string} [main]
* @returns {void}
*/
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
	if (process$1.noDeprecation) return;
	if (defaultGetFormatWithoutErrors(url, { parentURL: base.href }) !== "module") return;
	const urlPath = fileURLToPath(url.href);
	const packagePath = fileURLToPath(new URL$1(".", packageJsonUrl));
	const basePath = fileURLToPath(base);
	if (!main) process$1.emitWarning(`No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
	else if (path.resolve(packagePath, main) !== urlPath) process$1.emitWarning(`Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\n Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
}
/**
* @param {string} path
* @returns {Stats | undefined}
*/
function tryStatSync(path) {
	try {
		return statSync(path);
	} catch {}
}
/**
* Legacy CommonJS main resolution:
* 1. let M = pkg_url + (json main field)
* 2. TRY(M, M.js, M.json, M.node)
* 3. TRY(M/index.js, M/index.json, M/index.node)
* 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)
* 5. NOT_FOUND
*
* @param {URL} url
* @returns {boolean}
*/
function fileExists(url) {
	const stats = statSync(url, { throwIfNoEntry: false });
	const isFile = stats ? stats.isFile() : void 0;
	return isFile === null || isFile === void 0 ? false : isFile;
}
/**
* @param {URL} packageJsonUrl
* @param {PackageConfig} packageConfig
* @param {URL} base
* @returns {URL}
*/
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
	/** @type {URL | undefined} */
	let guess;
	if (packageConfig.main !== void 0) {
		guess = new URL$1(packageConfig.main, packageJsonUrl);
		if (fileExists(guess)) return guess;
		const tries = [
			`./${packageConfig.main}.js`,
			`./${packageConfig.main}.json`,
			`./${packageConfig.main}.node`,
			`./${packageConfig.main}/index.js`,
			`./${packageConfig.main}/index.json`,
			`./${packageConfig.main}/index.node`
		];
		let i = -1;
		while (++i < tries.length) {
			guess = new URL$1(tries[i], packageJsonUrl);
			if (fileExists(guess)) break;
			guess = void 0;
		}
		if (guess) {
			emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
			return guess;
		}
	}
	const tries = [
		"./index.js",
		"./index.json",
		"./index.node"
	];
	let i = -1;
	while (++i < tries.length) {
		guess = new URL$1(tries[i], packageJsonUrl);
		if (fileExists(guess)) break;
		guess = void 0;
	}
	if (guess) {
		emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
		return guess;
	}
	throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL$1(".", packageJsonUrl)), fileURLToPath(base));
}
/**
* @param {URL} resolved
* @param {URL} base
* @param {boolean} [preserveSymlinks]
* @returns {URL}
*/
function finalizeResolution(resolved, base, preserveSymlinks) {
	if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, "must not include encoded \"/\" or \"\\\" characters", fileURLToPath(base));
	/** @type {string} */
	let filePath;
	try {
		filePath = fileURLToPath(resolved);
	} catch (error) {
		const cause = error;
		Object.defineProperty(cause, "input", { value: String(resolved) });
		Object.defineProperty(cause, "module", { value: String(base) });
		throw cause;
	}
	const stats = tryStatSync(filePath.endsWith("/") ? filePath.slice(-1) : filePath);
	if (stats && stats.isDirectory()) {
		const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath(base));
		error.url = String(resolved);
		throw error;
	}
	if (!stats || !stats.isFile()) {
		const error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && fileURLToPath(base), true);
		error.url = String(resolved);
		throw error;
	}
	{
		const real = realpathSync(filePath);
		const { search, hash } = resolved;
		resolved = pathToFileURL(real + (filePath.endsWith(path.sep) ? "/" : ""));
		resolved.search = search;
		resolved.hash = hash;
	}
	return resolved;
}
/**
* @param {string} specifier
* @param {URL | undefined} packageJsonUrl
* @param {URL} base
* @returns {Error}
*/
function importNotDefined(specifier, packageJsonUrl, base) {
	return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && fileURLToPath(new URL$1(".", packageJsonUrl)), fileURLToPath(base));
}
/**
* @param {string} subpath
* @param {URL} packageJsonUrl
* @param {URL} base
* @returns {Error}
*/
function exportsNotFound(subpath, packageJsonUrl, base) {
	return new ERR_PACKAGE_PATH_NOT_EXPORTED(fileURLToPath(new URL$1(".", packageJsonUrl)), subpath, base && fileURLToPath(base));
}
/**
* @param {string} request
* @param {string} match
* @param {URL} packageJsonUrl
* @param {boolean} internal
* @param {URL} [base]
* @returns {never}
*/
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
	throw new ERR_INVALID_MODULE_SPECIFIER(request, `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath(packageJsonUrl)}`, base && fileURLToPath(base));
}
/**
* @param {string} subpath
* @param {unknown} target
* @param {URL} packageJsonUrl
* @param {boolean} internal
* @param {URL} [base]
* @returns {Error}
*/
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
	target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
	return new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL$1(".", packageJsonUrl)), subpath, target, internal, base && fileURLToPath(base));
}
/**
* @param {string} target
* @param {string} subpath
* @param {string} match
* @param {URL} packageJsonUrl
* @param {URL} base
* @param {boolean} pattern
* @param {boolean} internal
* @param {boolean} isPathMap
* @param {Set<string> | undefined} conditions
* @returns {URL}
*/
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
	if (subpath !== "" && !pattern && target[target.length - 1] !== "/") throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
	if (!target.startsWith("./")) {
		if (internal && !target.startsWith("../") && !target.startsWith("/")) {
			let isURL = false;
			try {
				new URL$1(target);
				isURL = true;
			} catch {}
			if (!isURL) return packageResolve(pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target + subpath, packageJsonUrl, conditions);
		}
		throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
	}
	if (invalidSegmentRegEx.exec(target.slice(2)) !== null) if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
		if (!isPathMap) {
			const request = pattern ? match.replace("*", () => subpath) : match + subpath;
			emitInvalidSegmentDeprecation(pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target, request, match, packageJsonUrl, internal, base, true);
		}
	} else throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
	const resolved = new URL$1(target, packageJsonUrl);
	const resolvedPath = resolved.pathname;
	const packagePath = new URL$1(".", packageJsonUrl).pathname;
	if (!resolvedPath.startsWith(packagePath)) throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
	if (subpath === "") return resolved;
	if (invalidSegmentRegEx.exec(subpath) !== null) {
		const request = pattern ? match.replace("*", () => subpath) : match + subpath;
		if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
			if (!isPathMap) emitInvalidSegmentDeprecation(pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target, request, match, packageJsonUrl, internal, base, false);
		} else throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
	}
	if (pattern) return new URL$1(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () => subpath));
	return new URL$1(subpath, resolved);
}
/**
* @param {string} key
* @returns {boolean}
*/
function isArrayIndex(key) {
	const keyNumber = Number(key);
	if (`${keyNumber}` !== key) return false;
	return keyNumber >= 0 && keyNumber < 4294967295;
}
/**
* @param {URL} packageJsonUrl
* @param {unknown} target
* @param {string} subpath
* @param {string} packageSubpath
* @param {URL} base
* @param {boolean} pattern
* @param {boolean} internal
* @param {boolean} isPathMap
* @param {Set<string> | undefined} conditions
* @returns {URL | null}
*/
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
	if (typeof target === "string") return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);
	if (Array.isArray(target)) {
		/** @type {Array<unknown>} */
		const targetList = target;
		if (targetList.length === 0) return null;
		/** @type {ErrnoException | null | undefined} */
		let lastException;
		let i = -1;
		while (++i < targetList.length) {
			const targetItem = targetList[i];
			/** @type {URL | null} */
			let resolveResult;
			try {
				resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
			} catch (error) {
				const exception = error;
				lastException = exception;
				if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
				throw error;
			}
			if (resolveResult === void 0) continue;
			if (resolveResult === null) {
				lastException = null;
				continue;
			}
			return resolveResult;
		}
		if (lastException === void 0 || lastException === null) return null;
		throw lastException;
	}
	if (typeof target === "object" && target !== null) {
		const keys = Object.getOwnPropertyNames(target);
		let i = -1;
		while (++i < keys.length) {
			const key = keys[i];
			if (isArrayIndex(key)) throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJsonUrl), base, "\"exports\" cannot contain numeric property keys.");
		}
		i = -1;
		while (++i < keys.length) {
			const key = keys[i];
			if (key === "default" || conditions && conditions.has(key)) {
				const conditionalTarget = target[key];
				const resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
				if (resolveResult === void 0) continue;
				return resolveResult;
			}
		}
		return null;
	}
	if (target === null) return null;
	throw invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
}
/**
* @param {unknown} exports
* @param {URL} packageJsonUrl
* @param {URL} base
* @returns {boolean}
*/
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
	if (typeof exports === "string" || Array.isArray(exports)) return true;
	if (typeof exports !== "object" || exports === null) return false;
	const keys = Object.getOwnPropertyNames(exports);
	let isConditionalSugar = false;
	let i = 0;
	let keyIndex = -1;
	while (++keyIndex < keys.length) {
		const key = keys[keyIndex];
		const currentIsConditionalSugar = key === "" || key[0] !== ".";
		if (i++ === 0) isConditionalSugar = currentIsConditionalSugar;
		else if (isConditionalSugar !== currentIsConditionalSugar) throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJsonUrl), base, "\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.");
	}
	return isConditionalSugar;
}
/**
* @param {string} match
* @param {URL} pjsonUrl
* @param {URL} base
*/
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
	if (process$1.noDeprecation) return;
	const pjsonPath = fileURLToPath(pjsonUrl);
	if (emittedPackageWarnings.has(pjsonPath + "|" + match)) return;
	emittedPackageWarnings.add(pjsonPath + "|" + match);
	process$1.emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155");
}
/**
* @param {URL} packageJsonUrl
* @param {string} packageSubpath
* @param {Record<string, unknown>} packageConfig
* @param {URL} base
* @param {Set<string> | undefined} conditions
* @returns {URL}
*/
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
	let exports = packageConfig.exports;
	if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) exports = { ".": exports };
	if (own.call(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
		const target = exports[packageSubpath];
		const resolveResult = resolvePackageTarget(packageJsonUrl, target, "", packageSubpath, base, false, false, false, conditions);
		if (resolveResult === null || resolveResult === void 0) throw exportsNotFound(packageSubpath, packageJsonUrl, base);
		return resolveResult;
	}
	let bestMatch = "";
	let bestMatchSubpath = "";
	const keys = Object.getOwnPropertyNames(exports);
	let i = -1;
	while (++i < keys.length) {
		const key = keys[i];
		const patternIndex = key.indexOf("*");
		if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
			if (packageSubpath.endsWith("/")) emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
			const patternTrailer = key.slice(patternIndex + 1);
			if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
				bestMatch = key;
				bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
			}
		}
	}
	if (bestMatch) {
		const target = exports[bestMatch];
		const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith("/"), conditions);
		if (resolveResult === null || resolveResult === void 0) throw exportsNotFound(packageSubpath, packageJsonUrl, base);
		return resolveResult;
	}
	throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
/**
* @param {string} a
* @param {string} b
*/
function patternKeyCompare(a, b) {
	const aPatternIndex = a.indexOf("*");
	const bPatternIndex = b.indexOf("*");
	const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
	const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
	if (baseLengthA > baseLengthB) return -1;
	if (baseLengthB > baseLengthA) return 1;
	if (aPatternIndex === -1) return 1;
	if (bPatternIndex === -1) return -1;
	if (a.length > b.length) return -1;
	if (b.length > a.length) return 1;
	return 0;
}
/**
* @param {string} name
* @param {URL} base
* @param {Set<string>} [conditions]
* @returns {URL}
*/
function packageImportsResolve(name, base, conditions) {
	if (name === "#" || name.startsWith("#/") || name.endsWith("/")) throw new ERR_INVALID_MODULE_SPECIFIER(name, "is not a valid internal imports specifier name", fileURLToPath(base));
	/** @type {URL | undefined} */
	let packageJsonUrl;
	const packageConfig = getPackageScopeConfig(base);
	if (packageConfig.exists) {
		packageJsonUrl = pathToFileURL(packageConfig.pjsonPath);
		const imports = packageConfig.imports;
		if (imports) if (own.call(imports, name) && !name.includes("*")) {
			const resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], "", name, base, false, true, false, conditions);
			if (resolveResult !== null && resolveResult !== void 0) return resolveResult;
		} else {
			let bestMatch = "";
			let bestMatchSubpath = "";
			const keys = Object.getOwnPropertyNames(imports);
			let i = -1;
			while (++i < keys.length) {
				const key = keys[i];
				const patternIndex = key.indexOf("*");
				if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
					const patternTrailer = key.slice(patternIndex + 1);
					if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
						bestMatch = key;
						bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
					}
				}
			}
			if (bestMatch) {
				const target = imports[bestMatch];
				const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, true, false, conditions);
				if (resolveResult !== null && resolveResult !== void 0) return resolveResult;
			}
		}
	}
	throw importNotDefined(name, packageJsonUrl, base);
}
/**
* @param {string} specifier
* @param {URL} base
*/
function parsePackageName(specifier, base) {
	let separatorIndex = specifier.indexOf("/");
	let validPackageName = true;
	let isScoped = false;
	if (specifier[0] === "@") {
		isScoped = true;
		if (separatorIndex === -1 || specifier.length === 0) validPackageName = false;
		else separatorIndex = specifier.indexOf("/", separatorIndex + 1);
	}
	const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
	if (invalidPackageNameRegEx.exec(packageName) !== null) validPackageName = false;
	if (!validPackageName) throw new ERR_INVALID_MODULE_SPECIFIER(specifier, "is not a valid package name", fileURLToPath(base));
	return {
		packageName,
		packageSubpath: "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex)),
		isScoped
	};
}
/**
* @param {string} specifier
* @param {URL} base
* @param {Set<string> | undefined} conditions
* @returns {URL}
*/
function packageResolve(specifier, base, conditions) {
	if (builtinModules.includes(specifier)) return new URL$1("node:" + specifier);
	const { packageName, packageSubpath, isScoped } = parsePackageName(specifier, base);
	const packageConfig = getPackageScopeConfig(base);
	/* c8 ignore next 16 */
	if (packageConfig.exists) {
		const packageJsonUrl = pathToFileURL(packageConfig.pjsonPath);
		if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions);
	}
	let packageJsonUrl = new URL$1("./node_modules/" + packageName + "/package.json", base);
	let packageJsonPath = fileURLToPath(packageJsonUrl);
	/** @type {string} */
	let lastPath;
	do {
		const stat = tryStatSync(packageJsonPath.slice(0, -13));
		if (!stat || !stat.isDirectory()) {
			lastPath = packageJsonPath;
			packageJsonUrl = new URL$1((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl);
			packageJsonPath = fileURLToPath(packageJsonUrl);
			continue;
		}
		const packageConfig = read(packageJsonPath, {
			base,
			specifier
		});
		if (packageConfig.exports !== void 0 && packageConfig.exports !== null) return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions);
		if (packageSubpath === ".") return legacyMainResolve(packageJsonUrl, packageConfig, base);
		return new URL$1(packageSubpath, packageJsonUrl);
	} while (packageJsonPath.length !== lastPath.length);
	throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base), false);
}
/**
* @param {string} specifier
* @returns {boolean}
*/
function isRelativeSpecifier(specifier) {
	if (specifier[0] === ".") {
		if (specifier.length === 1 || specifier[1] === "/") return true;
		if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) return true;
	}
	return false;
}
/**
* @param {string} specifier
* @returns {boolean}
*/
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
	if (specifier === "") return false;
	if (specifier[0] === "/") return true;
	return isRelativeSpecifier(specifier);
}
/**
* The “Resolver Algorithm Specification” as detailed in the Node docs (which is
* sync and slightly lower-level than `resolve`).
*
* @param {string} specifier
*   `/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc.
* @param {URL} base
*   Full URL (to a file) that `specifier` is resolved relative from.
* @param {Set<string>} [conditions]
*   Conditions.
* @param {boolean} [preserveSymlinks]
*   Keep symlinks instead of resolving them.
* @returns {URL}
*   A URL object to the found thing.
*/
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
	const protocol = base.protocol;
	const isRemote = protocol === "data:" || protocol === "http:" || protocol === "https:";
	/** @type {URL | undefined} */
	let resolved;
	if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) try {
		resolved = new URL$1(specifier, base);
	} catch (error_) {
		const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
		error.cause = error_;
		throw error;
	}
	else if (protocol === "file:" && specifier[0] === "#") resolved = packageImportsResolve(specifier, base, conditions);
	else try {
		resolved = new URL$1(specifier);
	} catch (error_) {
		if (isRemote && !builtinModules.includes(specifier)) {
			const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
			error.cause = error_;
			throw error;
		}
		resolved = packageResolve(specifier, base, conditions);
	}
	assert(resolved !== void 0, "expected to be defined");
	if (resolved.protocol !== "file:") return resolved;
	return finalizeResolution(resolved, base);
}
function fileURLToPath$2(id) {
	if (typeof id === "string" && !id.startsWith("file://")) return normalizeSlash(id);
	return normalizeSlash(fileURLToPath(id));
}
function pathToFileURL$1(id) {
	return pathToFileURL(fileURLToPath$2(id)).toString();
}
function normalizeid(id) {
	if (typeof id !== "string") id = id.toString();
	if (/(?:node|data|http|https|file):/.test(id)) return id;
	if (BUILTIN_MODULES.has(id)) return "node:" + id;
	return "file://" + encodeURI(normalizeSlash(id));
}
const DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
const DEFAULT_EXTENSIONS = [
	".mjs",
	".cjs",
	".js",
	".json"
];
const NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
	"ERR_MODULE_NOT_FOUND",
	"ERR_UNSUPPORTED_DIR_IMPORT",
	"MODULE_NOT_FOUND",
	"ERR_PACKAGE_PATH_NOT_EXPORTED"
]);
function _tryModuleResolve(id, url, conditions) {
	try {
		return moduleResolve(id, url, conditions);
	} catch (error) {
		if (!NOT_FOUND_ERRORS.has(error?.code)) throw error;
	}
}
function _resolve(id, options = {}) {
	if (typeof id !== "string") if (id instanceof URL) id = fileURLToPath$2(id);
	else throw new TypeError("input must be a `string` or `URL`");
	if (/(?:node|data|http|https):/.test(id)) return id;
	if (BUILTIN_MODULES.has(id)) return "node:" + id;
	if (id.startsWith("file://")) id = fileURLToPath$2(id);
	if (isAbsolute$1(id)) try {
		if (statSync(id).isFile()) return pathToFileURL$1(id);
	} catch (error) {
		if (error?.code !== "ENOENT") throw error;
	}
	const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
	const _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((url) => new URL(normalizeid(url.toString())));
	if (_urls.length === 0) _urls.push(new URL(pathToFileURL$1(process.cwd())));
	const urls = [..._urls];
	for (const url of _urls) if (url.protocol === "file:") urls.push(new URL("./", url), new URL(joinURL(url.pathname, "_index.js"), url), new URL("node_modules", url));
	let resolved;
	for (const url of urls) {
		resolved = _tryModuleResolve(id, url, conditionsSet);
		if (resolved) break;
		for (const prefix of ["", "/index"]) {
			for (const extension of options.extensions || DEFAULT_EXTENSIONS) {
				resolved = _tryModuleResolve(joinURL(id, prefix) + extension, url, conditionsSet);
				if (resolved) break;
			}
			if (resolved) break;
		}
		if (resolved) break;
	}
	if (!resolved) {
		const error = /* @__PURE__ */ new Error(`Cannot find module ${id} imported from ${urls.join(", ")}`);
		error.code = "ERR_MODULE_NOT_FOUND";
		throw error;
	}
	return pathToFileURL$1(resolved);
}
function resolveSync(id, options) {
	return _resolve(id, options);
}
function resolve$1(id, options) {
	try {
		return Promise.resolve(resolveSync(id, options));
	} catch (error) {
		return Promise.reject(error);
	}
}

//#endregion
//#region ../../node_modules/.pnpm/listhen@1.9.0/node_modules/listhen/dist/index.mjs
var import_http_shutdown = /* @__PURE__ */ __toESM(require_http_shutdown(), 1);
var import_lib = /* @__PURE__ */ __toESM(require_lib(), 1);
let isDockerCached;
function isDocker() {
	if (isDockerCached === void 0) isDockerCached = _hasDockerEnvironment() || _hasDockerCGroup();
	return isDockerCached;
}
function _hasDockerEnvironment() {
	try {
		statSync("/.dockerenv");
		return true;
	} catch {
		return false;
	}
}
function _hasDockerCGroup() {
	try {
		return readFileSync("/proc/self/cgroup", "utf8").includes("docker");
	} catch {
		return false;
	}
}
let isWSLCached;
function isWsl() {
	if (isWSLCached === void 0) isWSLCached = _isWsl();
	return isWSLCached;
}
function _isWsl() {
	if (process.platform !== "linux") return false;
	if (os.release().toLowerCase().includes("microsoft")) {
		if (isDocker()) return false;
		return true;
	}
	try {
		return readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
	} catch {
		return false;
	}
}
const defaultMountPoint = "/mnt/";
let _wslMountpoint;
function getWslDrivesMountPoint() {
	if (_wslMountpoint) return _wslMountpoint;
	const configFilePath = "/etc/wsl.conf";
	let isConfigFileExists = false;
	try {
		accessSync(configFilePath, constants.F_OK);
		isConfigFileExists = true;
	} catch {}
	if (!isConfigFileExists) return defaultMountPoint;
	const configContent = readFileSync(configFilePath, { encoding: "utf8" });
	const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
	if (!configMountPoint || !configMountPoint.groups) return defaultMountPoint;
	_wslMountpoint = configMountPoint.groups.mountPoint.trim();
	_wslMountpoint = _wslMountpoint.endsWith("/") ? _wslMountpoint : `${_wslMountpoint}/`;
	return _wslMountpoint;
}
async function open(target, options = {}) {
	let command;
	const cliArguments = [];
	const childProcessOptions = {};
	if (process.platform === "darwin") {
		command = "open";
		if (options.wait) cliArguments.push("--wait-apps");
		if (options.background) cliArguments.push("--background");
		if (options.newInstance) cliArguments.push("--new");
	} else if (process.platform === "win32" || isWsl() && !isDocker()) {
		command = isWsl() ? `${getWslDrivesMountPoint()}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
		cliArguments.push("-NoProfile", "-NonInteractive", "–ExecutionPolicy", "Bypass", "-EncodedCommand");
		if (!isWsl()) childProcessOptions.windowsVerbatimArguments = true;
		const encodedArguments = ["Start"];
		if (options.wait) encodedArguments.push("-Wait");
		encodedArguments.push(target);
		target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
	} else {
		command = "xdg-open";
		if (!(process.versions.electron || process.platform === "android")) {
			command = join(os.tmpdir(), "xdg-open");
			if (!fs.existsSync(command)) try {
				fs.writeFileSync(join(os.tmpdir(), "xdg-open"), await import("./xdg-open-Lg-lvrep.mjs").then((r) => r.xdgOpenScript()), "utf8");
				fs.chmodSync(command, 493);
			} catch {
				command = "xdg-open";
			}
		}
		if (!options.wait) {
			childProcessOptions.stdio = "ignore";
			childProcessOptions.detached = true;
		}
	}
	cliArguments.push(target);
	const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
	if (options.wait) return new Promise((resolve, reject) => {
		subprocess.once("error", reject);
		subprocess.once("close", (exitCode) => {
			if (options.allowNonzeroExitCode && exitCode > 0) {
				reject(/* @__PURE__ */ new Error(`Exited with code ${exitCode}`));
				return;
			}
			resolve(subprocess);
		});
	});
	subprocess.unref();
	return subprocess;
}
function getNetworkInterfaces(includeIPV6) {
	const addrs = /* @__PURE__ */ new Set();
	for (const details of Object.values(networkInterfaces())) if (details) {
		for (const d of details) if (!d.internal && !(d.mac === "00:00:00:00:00:00") && !d.address.startsWith("fe80::") && !(!includeIPV6 && (d.family === "IPv6" || +d.family === 6))) addrs.add(formatAddress(d));
	}
	return [...addrs].sort();
}
function formatAddress(addr) {
	return addr.family === "IPv6" || addr.family === 6 ? `[${addr.address}]` : addr.address;
}
function formatURL(url) {
	return colors$2.cyan(colors$2.underline(decodeURI(url).replace(/:(\d+)\//g, `:${colors$2.bold("$1")}/`)));
}
const _localHosts = /* @__PURE__ */ new Set([
	"127.0.0.1",
	"localhost",
	"::1"
]);
function isLocalhost(hostname) {
	return hostname === void 0 ? false : _localHosts.has(hostname);
}
const _anyHosts = /* @__PURE__ */ new Set([
	"",
	"0.0.0.0",
	"::"
]);
function isAnyhost(hostname) {
	return hostname === void 0 ? false : _anyHosts.has(hostname);
}
function generateURL(hostname, listhenOptions, baseURL) {
	const proto = listhenOptions.https ? "https://" : "http://";
	let port = listhenOptions.port || "";
	if (port === 80 && proto === "http://" || port === 443 && proto === "https://") port = "";
	if (hostname[0] !== "[" && hostname.includes(":")) hostname = `[${hostname}]`;
	return proto + (hostname || "localhost") + ":" + port + (baseURL || listhenOptions.baseURL || "");
}
function getDefaultHost(preferPublic) {
	if (isDocker() || isWsl()) return "";
	return preferPublic ? "" : "localhost";
}
function getPublicURL(listhenOptions, baseURL) {
	if (listhenOptions.publicURL) return listhenOptions.publicURL;
	if (p$2 === "stackblitz") {
		const stackblitzURL = detectStackblitzURL(listhenOptions._entry);
		if (stackblitzURL) return stackblitzURL;
	}
	if (listhenOptions.hostname && !isLocalhost(listhenOptions.hostname) && !isAnyhost(listhenOptions.hostname)) return generateURL(listhenOptions.hostname, listhenOptions, baseURL);
}
function detectStackblitzURL(entry) {
	try {
		const cwd = process.env.PWD || "";
		if (cwd.startsWith("/home/projects")) {
			const projectId = cwd.split("/")[3];
			const relativeEntry = entry && relative(process.cwd(), entry).replace(/^\.\//, "");
			return `https://stackblitz.com/edit/${projectId}${relativeEntry ? `?file=${relativeEntry}` : ""}`;
		}
		if (cwd.startsWith("/home")) return `https://stackblitz.com/edit/~/github.com/${cwd.split("/").slice(2).join("/")}`;
	} catch (error) {
		console.error(error);
	}
}
const HOSTNAME_RE = /^(?!-)[\d.:A-Za-z-]{1,63}(?<!-)$/;
function validateHostname(hostname, _public) {
	if (hostname && !HOSTNAME_RE.test(hostname)) {
		const fallbackHost = _public ? "" : "localhost";
		consola.warn(`[listhen] Invalid hostname \`${hostname}\`. Using \`${fallbackHost}\` as fallback.`);
		return fallbackHost;
	}
	return hostname;
}
const word = "[a-fA-F\\d:]";
const boundry = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
const v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
const v6segment = "[a-fA-F\\d]{1,4}";
const v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
const v4exact = new RegExp(`^${v4}$`);
const v6exact = new RegExp(`^${v6}$`);
const ipRegex = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, "g");
ipRegex.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, "g");
ipRegex.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, "g");
async function resolveCertificate(options) {
	let https;
	if (typeof options === "object" && options.key && options.cert) {
		https = await resolveCert(options);
		if (options.passphrase) https.passphrase = options.passphrase;
	} else if (typeof options === "object" && options.pfx) {
		const pfx = await resolvePfx(options);
		if (!pfx.safeContents || pfx.safeContents.length < 2 || pfx.safeContents[0].safeBags.length === 0 || pfx.safeContents[1].safeBags.length === 0) throw new Error("keystore not containing a cert AND a key");
		const _cert = pfx.safeContents[0].safeBags[0].cert;
		const _key = pfx.safeContents[1].safeBags[0].key;
		https = {
			key: import_lib.default.pki.privateKeyToPem(_key),
			cert: import_lib.default.pki.certificateToPem(_cert)
		};
	} else {
		const { cert } = await generateCertificates(options);
		https = cert;
	}
	return https;
}
async function generateCertificates(options) {
	const defaults = {
		commonName: "localhost",
		countryCode: "US",
		state: "Michigan",
		locality: "Berkley",
		organization: "Testing Corp",
		organizationalUnit: "IT department",
		domains: [
			"localhost",
			"127.0.0.1",
			"::1"
		],
		validityDays: 1,
		bits: 2048
	};
	const caOptions = defu(options, defaults);
	caOptions.passphrase = options.signingKeyPassphrase;
	const ca = await generateCACert(caOptions);
	const domains = Array.isArray(options.domains) ? options.domains : [
		"localhost",
		"127.0.0.1",
		"::1"
	];
	return {
		ca,
		cert: await generateTLSCert({
			...defu(options, defaults),
			signingKeyCert: ca.cert,
			signingKey: ca.key,
			domains
		})
	};
}
async function resolveCert(options) {
	if (options && options.key && options.cert) {
		const isInline = (s = "") => s.startsWith("--");
		const r = (s) => isInline(s) ? s : promises.readFile(s, "utf8");
		return {
			key: await r(options.key),
			cert: await r(options.cert)
		};
	}
	throw new Error("Certificate or Private Key not present");
}
async function resolvePfx(options) {
	if (options && options.pfx) {
		const pfx = await promises.readFile(options.pfx, "binary");
		const p12Asn1 = import_lib.default.asn1.fromDer(pfx);
		if (options.passphrase) return import_lib.default.pkcs12.pkcs12FromAsn1(p12Asn1, options.passphrase);
		return import_lib.default.pkcs12.pkcs12FromAsn1(p12Asn1, "");
	}
	throw new Error("Error resolving the pfx store");
}
function createAttributes(options) {
	return [
		options.commonName && {
			name: "commonName",
			value: options.commonName
		},
		options.countryCode && {
			name: "countryName",
			value: options.countryCode
		},
		options.state && {
			name: "stateOrProvinceName",
			value: options.state
		},
		options.locality && {
			name: "localityName",
			value: options.locality
		},
		options.organization && {
			name: "organizationName",
			value: options.organization
		},
		options.organizationalUnit && {
			name: "organizationalUnitName",
			value: options.organizationalUnit
		},
		options.emailAddress && {
			name: "emailAddress",
			value: options.emailAddress
		}
	].filter(Boolean);
}
function createCertificateInfo(options) {
	if (!options.domains || options.domains && options.domains.length === 0) options.domains = ["localhost.local"];
	options.commonName = options.commonName || options.domains[0];
	return {
		attributes: createAttributes(options),
		extensions: [
			{
				name: "basicConstraints",
				cA: false,
				critical: true
			},
			{
				name: "keyUsage",
				digitalSignature: true,
				keyEncipherment: true,
				critical: true
			},
			{
				name: "extKeyUsage",
				serverAuth: true,
				clientAuth: true
			},
			{
				name: "subjectAltName",
				altNames: options.domains.map((domain) => {
					const types = {
						domain: 2,
						ip: 7
					};
					if (ipRegex({ exact: true }).test(domain)) return {
						type: types.ip,
						ip: domain
					};
					return {
						type: types.domain,
						value: domain
					};
				})
			}
		]
	};
}
function createCaInfo(options) {
	return {
		attributes: createAttributes(options),
		extensions: [{
			name: "basicConstraints",
			cA: true,
			critical: true
		}, {
			name: "keyUsage",
			keyCertSign: true,
			critical: true
		}]
	};
}
async function generateTLSCert(options) {
	const { attributes, extensions } = createCertificateInfo(options);
	const ca = import_lib.default.pki.certificateFromPem(options.signingKeyCert);
	return await generateCert({
		bits: options.bits,
		subject: attributes,
		issuer: ca.subject.attributes,
		extensions,
		validityDays: options.validityDays || 1,
		signingKey: options.signingKey,
		signingKeyPassphrase: options.signingKeyPassphrase,
		passphrase: options.passphrase
	});
}
async function generateCACert(options = {}) {
	const { attributes, extensions } = createCaInfo(options);
	return await generateCert({
		...options,
		bits: options.bits || 2048,
		subject: attributes,
		issuer: attributes,
		extensions,
		validityDays: options.validityDays || 1
	});
}
function signCertificate(options, cert) {
	if (options.signingKey) if (isValidPassphrase(options.signingKeyPassphrase)) {
		const encryptedPrivateKey = import_lib.default.pki.encryptedPrivateKeyFromPem(options.signingKey);
		const decryptedPrivateKey = import_lib.default.pki.decryptPrivateKeyInfo(encryptedPrivateKey, options.signingKeyPassphrase);
		cert.sign(import_lib.default.pki.privateKeyFromAsn1(decryptedPrivateKey), import_lib.default.md.sha256.create());
	} else cert.sign(import_lib.default.pki.privateKeyFromPem(options.signingKey), import_lib.default.md.sha256.create());
	else cert.sign(cert.privateKey, import_lib.default.md.sha256.create());
}
function createCertificateFromKeyPair(keyPair, options) {
	const serial = Math.floor(Math.random() * 95e3 + 5e4).toString();
	const cert = import_lib.default.pki.createCertificate();
	cert.publicKey = keyPair.publicKey;
	cert.privateKey = keyPair.privateKey;
	cert.serialNumber = Buffer.from(serial).toString("hex");
	cert.validity.notBefore = /* @__PURE__ */ new Date();
	cert.validity.notAfter = /* @__PURE__ */ new Date();
	cert.validity.notAfter.setDate(cert.validity.notAfter.getDate() + options.validityDays);
	cert.setSubject(options.subject);
	cert.setIssuer(options.issuer);
	cert.setExtensions(options.extensions);
	return cert;
}
async function generateKeyPair(bits = 2048) {
	return await promisify(import_lib.default.pki.rsa.generateKeyPair.bind(import_lib.default.pki.rsa))({
		bits,
		workers: os.availableParallelism ? os.availableParallelism() : os.cpus().length
	});
}
function isValidPassphrase(passphrase) {
	return typeof passphrase === "string" && passphrase.length < 2e3;
}
async function generateCert(options) {
	const keyPair = await generateKeyPair(options.bits);
	const cert = createCertificateFromKeyPair(keyPair, options);
	if (isValidPassphrase(options.passphrase)) {
		const asn1PrivateKey = import_lib.default.pki.privateKeyToAsn1(keyPair.privateKey);
		const privateKeyInfo = import_lib.default.pki.wrapRsaPrivateKey(asn1PrivateKey);
		const encryptedPrivateKeyInfo = import_lib.default.pki.encryptPrivateKeyInfo(privateKeyInfo, options.passphrase, { algorithm: "aes256" });
		signCertificate({
			signingKey: options.signingKey,
			signingKeyPassphrase: options.signingKeyPassphrase
		}, cert);
		return {
			key: import_lib.default.pki.encryptedPrivateKeyToPem(encryptedPrivateKeyInfo),
			cert: import_lib.default.pki.certificateToPem(cert),
			passphrase: options.passphrase
		};
	} else {
		signCertificate({
			signingKey: options.signingKey,
			signingKeyPassphrase: options.signingKeyPassphrase
		}, cert);
		return {
			key: import_lib.default.pki.privateKeyToPem(keyPair.privateKey),
			cert: import_lib.default.pki.certificateToPem(cert)
		};
	}
}
async function listen(handle, _options = {}) {
	const _isProd = _options.isProd ?? process.env.NODE_ENV === "production";
	const _isTest = _options.isTest ?? process.env.NODE_ENV === "test";
	const _hostname = _options.hostname ?? process.env.HOST;
	const _public = _options.public ?? (isLocalhost(_hostname) ? false : void 0) ?? (isAnyhost(_hostname) ? true : void 0) ?? (process.argv.includes("--host") ? true : void 0) ?? _isProd;
	const listhenOptions = defu(_options, {
		name: "",
		https: false,
		port: process.env.PORT || 3e3,
		hostname: _hostname ?? getDefaultHost(_public),
		showURL: true,
		baseURL: "/",
		open: false,
		clipboard: false,
		isTest: _isTest,
		isProd: _isProd,
		public: _public,
		autoClose: true
	});
	listhenOptions.hostname = validateHostname(listhenOptions.hostname, listhenOptions.public);
	const _localhost = isLocalhost(listhenOptions.hostname);
	const _anyhost = isAnyhost(listhenOptions.hostname);
	if (listhenOptions.public && _localhost) {
		consola.warn(`[listhen] Trying to listhen on private host ${JSON.stringify(listhenOptions.hostname)} with public option enabled.`);
		listhenOptions.public = false;
	} else if (!listhenOptions.public && _anyhost && !(isWsl() || isDocker())) {
		consola.warn(`[listhen] Trying to listhen on public host ${JSON.stringify(listhenOptions.hostname)} with public option disabled. Using "localhost".`);
		listhenOptions.public = false;
		listhenOptions.hostname = "localhost";
	}
	if (listhenOptions.isTest) listhenOptions.showURL = false;
	if (listhenOptions.isProd || listhenOptions.isTest) {
		listhenOptions.open = false;
		listhenOptions.clipboard = false;
	}
	const port = listhenOptions.port = await getPort({
		port: Number(listhenOptions.port),
		verbose: !listhenOptions.isTest,
		host: listhenOptions.hostname,
		alternativePortRange: [3e3, 3100],
		public: listhenOptions.public,
		...typeof listhenOptions.port === "object" && listhenOptions.port
	});
	let server;
	let https = false;
	const httpsOptions = listhenOptions.https;
	let _addr;
	if (httpsOptions) {
		https = await resolveCertificate(httpsOptions);
		server = createServer$1(https, handle);
		(0, import_http_shutdown.default)(server);
		await promisify(server.listen.bind(server))(port, listhenOptions.hostname);
		_addr = server.address();
		listhenOptions.port = _addr.port;
	} else {
		server = createServer(handle);
		(0, import_http_shutdown.default)(server);
		await promisify(server.listen.bind(server))(port, listhenOptions.hostname);
		_addr = server.address();
		listhenOptions.port = _addr.port;
	}
	if (listhenOptions.ws) if (typeof listhenOptions.ws === "function") server.on("upgrade", listhenOptions.ws);
	else {
		consola.warn("[listhen] Using experimental websocket API. Learn more: `https://crossws.unjs.io`");
		const { handleUpgrade } = (await import("./node-B8hx0aQL.mjs").then((r) => r.default || r))({ ...listhenOptions.ws });
		server.on("upgrade", handleUpgrade);
	}
	const getURL = (host = listhenOptions.hostname, baseURL) => generateURL(host, listhenOptions, baseURL);
	let tunnel;
	if (listhenOptions.tunnel) {
		const { startTunnel } = await import("./dist-CY14gLxj.mjs");
		tunnel = await startTunnel({ url: getURL() });
	}
	let _closed = false;
	const close = async () => {
		if (_closed) return;
		_closed = true;
		await promisify(server.shutdown)().catch(() => {});
		await tunnel?.close().catch(() => {});
	};
	if (listhenOptions.clipboard) await (await import("./clipboardy-C3_imYwm.mjs").then((r) => r.default || r)).write(getURL()).catch(() => {
		listhenOptions.clipboard = false;
	});
	const getURLs = async (getURLOptions = {}) => {
		const urls = [];
		const _addURL = (type, url) => {
			if (!urls.some((u) => u.url === url)) urls.push({
				url,
				type
			});
		};
		const publicURL = getURLOptions.publicURL || getPublicURL(listhenOptions, getURLOptions.baseURL);
		if (publicURL) _addURL("network", publicURL);
		if (_localhost || _anyhost) _addURL("local", getURL(listhenOptions.hostname, getURLOptions.baseURL));
		if (tunnel) _addURL("tunnel", await tunnel.getURL());
		if (listhenOptions.public) {
			const _ipv6Host = listhenOptions.hostname.includes(":");
			for (const addr of getNetworkInterfaces(_ipv6Host)) {
				if (addr === publicURL) continue;
				_addURL("network", getURL(addr, getURLOptions.baseURL));
			}
		}
		return urls;
	};
	const showURL = async (showURLOptions = {}) => {
		const lines = [];
		const nameSuffix = showURLOptions.name || listhenOptions.name ? ` (${showURLOptions.name || listhenOptions.name})` : "";
		const urls = await getURLs(showURLOptions);
		const firstLocalUrl = urls.find((u) => u.type === "local");
		const firstPublicUrl = urls.find((u) => u.type !== "local");
		const showQR = (showURLOptions.qr ?? listhenOptions.qr) !== false;
		if (firstPublicUrl && showQR) {
			const space = " ".repeat(14);
			lines.push(" ");
			lines.push(...renderUnicodeCompact(firstPublicUrl.url).split("\n").map((line) => space + line));
			lines.push(" ");
		}
		const typeMap = {
			local: ["Local", "green"],
			tunnel: ["Tunnel", "yellow"],
			network: ["Network", "magenta"]
		};
		for (const url of urls) {
			const type = typeMap[url.type];
			const label = getColor(type[1])(`  \u279C ${(type[0] + ":").padEnd(8, " ")}${nameSuffix} `);
			let suffix = "";
			if (url === firstLocalUrl && listhenOptions.clipboard) suffix += colors$2.gray(" [copied to clipboard]");
			if (url === firstPublicUrl && showQR) suffix += colors$2.gray(" [QR code]");
			lines.push(`${label} ${formatURL(url.url)}${suffix}`);
		}
		if (!firstPublicUrl) lines.push(colors$2.gray(`  \u279C Network:  use ${colors$2.white("--host")} to expose`));
		console.log("\n" + lines.join("\n") + "\n");
	};
	if (listhenOptions.showURL) showURL();
	const _open = async () => {
		await open(getURL()).catch(() => {});
	};
	if (listhenOptions.open) await _open();
	if (listhenOptions.autoClose) {
		process.setMaxListeners(0);
		process.once("exit", () => close());
		process.once("SIGINT", () => process.exit(0));
		process.once("SIGTERM", () => process.exit(0));
		process.once("SIGHUP", () => process.exit(0));
	}
	return {
		url: getURL(),
		https,
		server,
		address: _addr,
		open: _open,
		showURL,
		getURLs,
		close
	};
}
async function createResolver() {
	const { createJiti } = await import("./jiti-CJ4dNg12.mjs").then((n) => n.t);
	const jiti = createJiti(join$2(process.cwd(), "_"), {
		cache: true,
		requireCache: false,
		interopDefault: true
	});
	return {
		relative: (path) => relative(process.cwd(), path),
		formatRelative: (path) => `\`./${relative(process.cwd(), path)}\``,
		import: jiti.import,
		resolve: (id) => jiti.esmResolve(id),
		tryResolve: (id) => jiti.esmResolve(id, { try: true })
	};
}
async function createDevServer(entry, options) {
	const logger = options.logger || consola.withTag("listhen");
	const { createApp, fromNodeMiddleware, serveStatic, eventHandler, dynamicEventHandler, toNodeListener } = await import(await resolve$1("h3", { url: [
		options.cwd,
		process.cwd(),
		import.meta.url
	].filter(Boolean) }));
	const resolver = await createResolver();
	const resolveEntry = () => {
		for (const suffix of [
			"",
			"/server/src",
			"/server",
			"/src"
		]) {
			const resolved = resolver.tryResolve(entry + suffix);
			if (resolved) return fileURLToPath$2(resolved);
		}
	};
	let cwd = options.cwd || "";
	if (!cwd) {
		const resolvedEntry = resolveEntry() || resolve$3(process.cwd(), entry);
		cwd = statSync(resolvedEntry, { throwIfNoEntry: false })?.isDirectory() ? resolvedEntry : dirname$2(resolvedEntry);
	}
	const app = createApp();
	const dynamicWS = /* @__PURE__ */ Object.create(null);
	let _ws = options.ws;
	if (_ws && typeof _ws !== "function") _ws = {
		...options.ws,
		async resolve(info) {
			return {
				...await options.ws?.resolve?.(info),
				...dynamicWS.hooks,
				...await dynamicWS.resolve?.(info)
			};
		}
	};
	const staticDirs = (options.staticDirs || ["public"]).filter(Boolean).map((d) => resolve$3(cwd, d)).filter((d) => existsSync(d) && statSync(d).isDirectory());
	for (const dir of staticDirs) app.use(eventHandler(async (event) => {
		await serveStatic(event, {
			fallthrough: true,
			getContents: (id) => readFile(join$2(dir, id)),
			getMeta: async (id) => {
				const stats = await stat(join$2(dir, id)).catch(() => {});
				if (!stats || !stats.isFile()) return;
				return {
					size: stats.size,
					mtime: stats.mtimeMs
				};
			}
		});
	}));
	let error;
	app.use(eventHandler(() => {
		if (error) return errorTemplate(String(error), error.stack);
	}));
	const dynamicHandler = dynamicEventHandler(() => {
		return `<!DOCTYPE html><html lang="en-US"><meta http-equiv="refresh" content="1"></head><body><p>Server is loading...</p>`;
	});
	app.use(dynamicHandler);
	let loadTime = 0;
	const loadHandle = async (initial) => {
		if (initial) for (const dir of staticDirs) logger.log(`\u{1F4C1} Serving static files from ${resolver.formatRelative(dir)}`);
		const start = Date.now();
		try {
			const _entry = resolveEntry();
			if (!_entry) {
				const message = `Cannot find a server entry in ${entry}`;
				logger.warn(message);
				error = new Error(message);
				error.stack = "";
				return;
			}
			if (initial) logger.log(`\u{1F680} Loading server entry ${resolver.formatRelative(_entry)}`);
			const _loadedEntry = await resolver.import(_entry);
			let _handler = _loadedEntry.handler || _loadedEntry.handle || _loadedEntry.app || _loadedEntry.default || _loadedEntry;
			if (options.ws) Object.assign(dynamicWS, _loadedEntry.webSocket || _loadedEntry.websocket || _handler.webSocket || _handler.websocket || {});
			if (_handler.handler) _handler = _handler.handler;
			if (typeof _handler !== "function") throw new TypeError("Make sure your server entrypoint exports a compatible `handler`, `handle`, `app` or `default` function export.");
			dynamicHandler.set(fromNodeMiddleware(_handler));
			error = void 0;
		} catch (_error) {
			error = normalizeErrorStack(_error);
		}
		loadTime = Date.now() - start;
		if (error) logger.error(error);
		else logger.log(`\u2705 Server ${initial ? "initialized" : "reloaded"} in ${loadTime}ms`);
	};
	return {
		cwd,
		resolver,
		nodeListener: toNodeListener(app),
		reload: (_initial) => loadHandle(_initial),
		_ws,
		_entry: resolveEntry()
	};
}
const InternalStackRe = /jiti|node:internal|citty|listhen|listenAndWatch/;
function normalizeErrorStack(error) {
	if (process.env.DEBUG) return error;
	try {
		const cwd = process.cwd();
		error.stack = error.stack.split("\n").slice(1).map((l) => l.replace(cwd, ".")).filter((l) => !InternalStackRe.test(l)).join("\n");
	} catch {}
	return error;
}
function errorTemplate(message, stack = "") {
	return `<!DOCTYPE html>
  <html>
  <head>
  <title>Server Error</title>
  <meta charset="utf-8">
  <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name=viewport>
  <style>
  .error-page {
    padding: 1rem;
    background: #222;
    color: #fff;
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    font-family: sans-serif;
    font-weight: 100 !important;
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }

  .error-page .error {
    max-width: 450px;
  }

  .error-page .title {
    font-size: 1rem;
    margin-top: 15px;
    color: #fff;
    margin-bottom: 8px;
  }

  .error-page .description {
    color: #ccc;
    line-height: 1.2;
    margin-bottom: 10px;
    text-align: left;
  }

  .error-page a {
    color: #ccc !important;
    text-decoration: none;
  }
  </style>
  </head>
  <body>
    <div class="error-page">
      <div class="error">
          <svg xmlns="http://www.w3.org/2000/svg" width="90" height="90" fill="#DBE1EC" viewBox="0 0 48 48"><path d="M22 30h4v4h-4zm0-16h4v12h-4zm1.99-10C12.94 4 4 12.95 4 24s8.94 20 19.99 20S44 35.05 44 24 35.04 4 23.99 4zM24 40c-8.84 0-16-7.16-16-16S15.16 8 24 8s16 7.16 16 16-7.16 16-16 16z"/></svg>
          <div class="title">Server Error</div>
          <div class="description">${message}<pre>${stack}</pre></div>
      </div>
    </div>
  </body>
  </html>`;
}
async function listenAndWatch(entry, options) {
	const logger = options.logger || consola.withTag("listhen");
	let watcher;
	const devServer = await createDevServer(entry, {
		...options,
		logger
	});
	const listener = await listen(devServer.nodeListener, {
		...options,
		_entry: devServer._entry,
		ws: options.ws ? devServer._ws : void 0
	});
	await devServer.reload(true);
	const _close = listener.close;
	listener.close = async () => {
		if (watcher) await watcher.unsubscribe().catch((error) => {
			logger.error(error);
		});
		await _close();
	};
	try {
		const subscribe = await import("./watcher-Esax0QEF.mjs").then((m) => /* @__PURE__ */ __toESM(m.default, 1)).then((r) => r.subscribe).catch(() => import("./watcher-wasm-TiCEH-gK.mjs").then((r) => r.subscribe));
		const jsExts = /* @__PURE__ */ new Set([
			".js",
			".mjs",
			".cjs",
			".ts",
			".mts",
			".cts"
		]);
		watcher = await subscribe(devServer.cwd, (_error, events) => {
			const filteredEvents = events.filter((e) => jsExts.has(extname(e.path)));
			if (filteredEvents.length === 0) return;
			const eventsString = filteredEvents.map((e) => `${devServer.resolver.formatRelative(e.path)} ${e.type}d`).join(", ");
			logger.log(`\u{1F504} Reloading server (${eventsString})`);
			devServer.reload();
		}, { ignore: options.ignore || [
			"**/.git/**",
			"**/node_modules/**",
			"**/dist/**"
		] });
		logger.log(`\u{1F440} Watching ${devServer.resolver.formatRelative(devServer.cwd)} for changes`);
	} catch (error) {
		logger.warn("Cannot start the watcher!\n", error, "\n\n✔️ Your dev server is still running, but it won't reload automatically after changes. You need to restart it manually.");
	}
	return listener;
}

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/chunk-PE3GG3TN.js
var BaseComponent = class {
	#cachedStyles;
	#cachedScript;
	/**
	* A flag to know if we are in dev mode or not. In dev mode,
	* the styles and scripts are refetched from the disk.
	* Otherwise they are cached.
	*/
	#inDevMode;
	/**
	* Absolute path to the frontend JavaScript that should be
	* injected within the HTML head. The JavaScript does not
	* get transpiled, hence it should work cross browser by
	* default.
	*/
	scriptFile;
	/**
	* Absolute path to the CSS file that should be injected
	* within the HTML head.
	*/
	cssFile;
	constructor(devMode) {
		this.#inDevMode = devMode;
	}
	/**
	* Returns the styles for the component. The null value
	* is not returned if no styles are associated with
	* the component
	*/
	async getStyles() {
		if (!this.cssFile) return null;
		if (this.#inDevMode) return await readFile$1(this.cssFile, "utf-8");
		this.#cachedStyles = this.#cachedStyles ?? await readFile$1(this.cssFile, "utf-8");
		return this.#cachedStyles;
	}
	/**
	* Returns the frontend script for the component. The null
	* value is not returned if no styles are associated
	* with the component
	*/
	async getScript() {
		if (!this.scriptFile) return null;
		if (this.#inDevMode) return await readFile$1(this.scriptFile, "utf-8");
		this.#cachedScript = this.#cachedScript ?? await readFile$1(this.scriptFile, "utf-8");
		return this.#cachedScript;
	}
};
var publicDirURL = new URL("./public/", import.meta.url);

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/chunk-CM7DWJNZ.js
var Layout = class extends BaseComponent {
	cssFile = new URL("./layout/style.css", publicDirURL);
	scriptFile = new URL("./layout/script.js", publicDirURL);
	/**
	* The toHTML method is used to output the HTML for the
	* web view
	*/
	async toHTML(props) {
		return `<!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>${props.title}</title>
        <!-- STYLES -->
        <!-- GLOBAL SCRIPT -->
      </head>
      <body>
        <div id="layout">
          ${await props.children()}
        </div>
        <!-- SCRIPTS -->
      </body>
    </html>`;
	}
	/**
	* The toANSI method is used to output the text for the console
	*/
	async toANSI(props) {
		return `
${await props.children()}
`;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/index.mjs
let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY = true;
if (typeof process !== "undefined") {
	({FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM} = process.env || {});
	isTTY = process.stdout && process.stdout.isTTY;
}
const $$2 = {
	enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY),
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};
function run(arr, str) {
	let i = 0, tmp, beg = "", end = "";
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (!!~str.indexOf(tmp.close)) str = str.replace(tmp.rgx, tmp.close + tmp.open);
	}
	return beg + str + end;
}
function chain(has, keys) {
	let ctx = {
		has,
		keys
	};
	ctx.reset = $$2.reset.bind(ctx);
	ctx.bold = $$2.bold.bind(ctx);
	ctx.dim = $$2.dim.bind(ctx);
	ctx.italic = $$2.italic.bind(ctx);
	ctx.underline = $$2.underline.bind(ctx);
	ctx.inverse = $$2.inverse.bind(ctx);
	ctx.hidden = $$2.hidden.bind(ctx);
	ctx.strikethrough = $$2.strikethrough.bind(ctx);
	ctx.black = $$2.black.bind(ctx);
	ctx.red = $$2.red.bind(ctx);
	ctx.green = $$2.green.bind(ctx);
	ctx.yellow = $$2.yellow.bind(ctx);
	ctx.blue = $$2.blue.bind(ctx);
	ctx.magenta = $$2.magenta.bind(ctx);
	ctx.cyan = $$2.cyan.bind(ctx);
	ctx.white = $$2.white.bind(ctx);
	ctx.gray = $$2.gray.bind(ctx);
	ctx.grey = $$2.grey.bind(ctx);
	ctx.bgBlack = $$2.bgBlack.bind(ctx);
	ctx.bgRed = $$2.bgRed.bind(ctx);
	ctx.bgGreen = $$2.bgGreen.bind(ctx);
	ctx.bgYellow = $$2.bgYellow.bind(ctx);
	ctx.bgBlue = $$2.bgBlue.bind(ctx);
	ctx.bgMagenta = $$2.bgMagenta.bind(ctx);
	ctx.bgCyan = $$2.bgCyan.bind(ctx);
	ctx.bgWhite = $$2.bgWhite.bind(ctx);
	return ctx;
}
function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, "g")
	};
	return function(txt) {
		if (this !== void 0 && this.has !== void 0) {
			~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
			return txt === void 0 ? this : $$2.enabled ? run(this.keys, txt + "") : txt + "";
		}
		return txt === void 0 ? chain([open], [blk]) : $$2.enabled ? run([blk], txt + "") : txt + "";
	};
}

//#endregion
//#region ../../node_modules/.pnpm/@poppinss+colors@4.1.6/node_modules/@poppinss/colors/build/index.js
var Colors = class {
	black(text) {
		return this.transform("black", text);
	}
	red(text) {
		return this.transform("red", text);
	}
	green(text) {
		return this.transform("green", text);
	}
	yellow(text) {
		return this.transform("yellow", text);
	}
	blue(text) {
		return this.transform("blue", text);
	}
	magenta(text) {
		return this.transform("magenta", text);
	}
	cyan(text) {
		return this.transform("cyan", text);
	}
	white(text) {
		return this.transform("white", text);
	}
	gray(text) {
		return this.transform("gray", text);
	}
	grey(text) {
		return this.transform("grey", text);
	}
	bgBlack(text) {
		return this.transform("bgBlack", text);
	}
	bgRed(text) {
		return this.transform("bgRed", text);
	}
	bgGreen(text) {
		return this.transform("bgGreen", text);
	}
	bgYellow(text) {
		return this.transform("bgYellow", text);
	}
	bgBlue(text) {
		return this.transform("bgBlue", text);
	}
	bgMagenta(text) {
		return this.transform("bgMagenta", text);
	}
	bgCyan(text) {
		return this.transform("bgCyan", text);
	}
	bgWhite(text) {
		return this.transform("bgWhite", text);
	}
	reset(text) {
		return this.transform("reset", text);
	}
	bold(text) {
		return this.transform("bold", text);
	}
	dim(text) {
		return this.transform("dim", text);
	}
	italic(text) {
		return this.transform("italic", text);
	}
	underline(text) {
		return this.transform("underline", text);
	}
	inverse(text) {
		return this.transform("inverse", text);
	}
	hidden(text) {
		return this.transform("hidden", text);
	}
	strikethrough(text) {
		return this.transform("strikethrough", text);
	}
};
var Raw = class extends Colors {
	#transformations = [];
	#dispose(value, callback) {
		callback();
		return value;
	}
	transform(transformation, text) {
		this.#transformations.push(transformation);
		if (text !== void 0) {
			const transformations = this.#transformations.concat([text]).join("(");
			const closingWrapping = new Array(this.#transformations.length + 1).join(")");
			return this.#dispose(`${transformations}${closingWrapping}`, () => {
				this.#transformations = [];
			});
		}
		return this;
	}
};
var Kleur = class extends Colors {
	#chain;
	constructor() {
		super();
		$$2.enabled = true;
	}
	#dispose(value, callback) {
		callback();
		return value;
	}
	transform(transformation, text) {
		if (text !== void 0) {
			if (this.#chain) return this.#dispose(this.#chain[transformation](text), () => {
				this.#chain = void 0;
			});
			return $$2[transformation](text);
		}
		if (this.#chain) this.#chain = this.#chain[transformation]();
		else this.#chain = $$2[transformation]();
		return this;
	}
};
var Silent = class extends Colors {
	transform(_, text) {
		if (text !== void 0) return String(text);
		return this;
	}
};
var colors_default = {
	ansi() {
		return new Kleur();
	},
	silent() {
		return new Silent();
	},
	raw() {
		return new Raw();
	}
};

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/chunk-4L7RY2JA.js
var ANSI_REGEX = new RegExp([`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))`, "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|"), "g");
function htmlEscape$1(value) {
	return value.replace(/&/g, "&amp;").replace(/\\"/g, "&bsol;&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function wordWrap$1(value, options) {
	const width = options.width;
	const indent = options.indent;
	const newLine = `${options.newLine}${indent}`;
	if (!width) return options.escape ? options.escape(value) : htmlEscape$1(value);
	let regexString = ".{1," + width + "}";
	regexString += "([\\s​]+|$)|[^\\s​]+?([\\s​]+|$)";
	const re = new RegExp(regexString, "g");
	return (value.match(re) || []).map(function(line) {
		if (line.slice(-1) === "\n") line = line.slice(0, line.length - 1);
		return options.escape ? options.escape(line) : htmlEscape$1(line);
	}).join(newLine);
}
function stripAnsi(value) {
	return value.replace(ANSI_REGEX, "");
}
var colors$1 = colors_default.ansi();

//#endregion
//#region ../../node_modules/.pnpm/@sindresorhus+is@7.2.0/node_modules/@sindresorhus/is/distribution/utilities.js
function keysOf(value) {
	return Object.keys(value);
}

//#endregion
//#region ../../node_modules/.pnpm/@sindresorhus+is@7.2.0/node_modules/@sindresorhus/is/distribution/index.js
const typedArrayTypeNames = [
	"Int8Array",
	"Uint8Array",
	"Uint8ClampedArray",
	"Int16Array",
	"Uint16Array",
	"Int32Array",
	"Uint32Array",
	"Float32Array",
	"Float64Array",
	"BigInt64Array",
	"BigUint64Array"
];
function isTypedArrayName(name) {
	return typedArrayTypeNames.includes(name);
}
const objectTypeNames = [
	"Function",
	"Generator",
	"AsyncGenerator",
	"GeneratorFunction",
	"AsyncGeneratorFunction",
	"AsyncFunction",
	"Observable",
	"Array",
	"Buffer",
	"Blob",
	"Object",
	"RegExp",
	"Date",
	"Error",
	"Map",
	"Set",
	"WeakMap",
	"WeakSet",
	"WeakRef",
	"ArrayBuffer",
	"SharedArrayBuffer",
	"DataView",
	"Promise",
	"URL",
	"FormData",
	"URLSearchParams",
	"HTMLElement",
	"NaN",
	...typedArrayTypeNames
];
function isObjectTypeName(name) {
	return objectTypeNames.includes(name);
}
const primitiveTypeNames = [
	"null",
	"undefined",
	"string",
	"number",
	"bigint",
	"boolean",
	"symbol"
];
function isPrimitiveTypeName(name) {
	return primitiveTypeNames.includes(name);
}
[...objectTypeNames, ...primitiveTypeNames];
const getObjectType = (value) => {
	const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
	if (/HTML\w+Element/.test(objectTypeName) && isHtmlElement(value)) return "HTMLElement";
	if (isObjectTypeName(objectTypeName)) return objectTypeName;
};
function detect(value) {
	if (value === null) return "null";
	switch (typeof value) {
		case "undefined": return "undefined";
		case "string": return "string";
		case "number": return Number.isNaN(value) ? "NaN" : "number";
		case "boolean": return "boolean";
		case "function": return "Function";
		case "bigint": return "bigint";
		case "symbol": return "symbol";
		default:
	}
	if (isObservable(value)) return "Observable";
	if (isArray(value)) return "Array";
	if (isBuffer(value)) return "Buffer";
	const tagType = getObjectType(value);
	if (tagType && tagType !== "Object") return tagType;
	if (hasPromiseApi(value)) return "Promise";
	if (value instanceof String || value instanceof Boolean || value instanceof Number) throw new TypeError("Please don't use object wrappers for primitive types");
	return "Object";
}
function hasPromiseApi(value) {
	return isFunction(value?.then) && isFunction(value?.catch);
}
const is = Object.assign(detect, {
	all: isAll,
	any: isAny,
	array: isArray,
	arrayBuffer: isArrayBuffer,
	arrayLike: isArrayLike,
	asyncFunction: isAsyncFunction,
	asyncGenerator: isAsyncGenerator,
	asyncGeneratorFunction: isAsyncGeneratorFunction,
	asyncIterable: isAsyncIterable,
	bigint: isBigint,
	bigInt64Array: isBigInt64Array,
	bigUint64Array: isBigUint64Array,
	blob: isBlob,
	boolean: isBoolean,
	boundFunction: isBoundFunction,
	buffer: isBuffer,
	class: isClass,
	dataView: isDataView,
	date: isDate,
	detect,
	directInstanceOf: isDirectInstanceOf,
	emptyArray: isEmptyArray,
	emptyMap: isEmptyMap,
	emptyObject: isEmptyObject,
	emptySet: isEmptySet,
	emptyString: isEmptyString,
	emptyStringOrWhitespace: isEmptyStringOrWhitespace,
	enumCase: isEnumCase,
	error: isError,
	evenInteger: isEvenInteger,
	falsy: isFalsy,
	float32Array: isFloat32Array,
	float64Array: isFloat64Array,
	formData: isFormData,
	function: isFunction,
	generator: isGenerator,
	generatorFunction: isGeneratorFunction,
	htmlElement: isHtmlElement,
	infinite: isInfinite,
	inRange: isInRange,
	int16Array: isInt16Array,
	int32Array: isInt32Array,
	int8Array: isInt8Array,
	integer: isInteger,
	iterable: isIterable,
	map: isMap,
	nan: isNan,
	nativePromise: isNativePromise,
	negativeNumber: isNegativeNumber,
	nodeStream: isNodeStream,
	nonEmptyArray: isNonEmptyArray,
	nonEmptyMap: isNonEmptyMap,
	nonEmptyObject: isNonEmptyObject,
	nonEmptySet: isNonEmptySet,
	nonEmptyString: isNonEmptyString,
	nonEmptyStringAndNotWhitespace: isNonEmptyStringAndNotWhitespace,
	null: isNull,
	nullOrUndefined: isNullOrUndefined,
	number: isNumber,
	numericString: isNumericString,
	object: isObject,
	observable: isObservable,
	oddInteger: isOddInteger,
	plainObject: isPlainObject,
	positiveNumber: isPositiveNumber,
	primitive: isPrimitive,
	promise: isPromise,
	propertyKey: isPropertyKey,
	regExp: isRegExp,
	safeInteger: isSafeInteger,
	set: isSet,
	sharedArrayBuffer: isSharedArrayBuffer,
	string: isString,
	symbol: isSymbol,
	truthy: isTruthy,
	tupleLike: isTupleLike,
	typedArray: isTypedArray,
	uint16Array: isUint16Array,
	uint32Array: isUint32Array,
	uint8Array: isUint8Array,
	uint8ClampedArray: isUint8ClampedArray,
	undefined: isUndefined,
	urlInstance: isUrlInstance,
	urlSearchParams: isUrlSearchParams,
	urlString: isUrlString,
	optional: isOptional,
	validDate: isValidDate,
	validLength: isValidLength,
	weakMap: isWeakMap,
	weakRef: isWeakRef,
	weakSet: isWeakSet,
	whitespaceString: isWhitespaceString
});
function isAbsoluteModule2(remainder) {
	return (value) => isInteger(value) && Math.abs(value % 2) === remainder;
}
function validatePredicateArray(predicateArray, allowEmpty) {
	if (predicateArray.length === 0) {
		if (allowEmpty) {} else throw new TypeError("Invalid predicate array");
		return;
	}
	for (const predicate of predicateArray) if (!isFunction(predicate)) throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
}
function isAll(predicate, ...values) {
	if (Array.isArray(predicate)) {
		const predicateArray = predicate;
		validatePredicateArray(predicateArray, values.length === 0);
		const combinedPredicate = (value) => predicateArray.every((singlePredicate) => singlePredicate(value));
		if (values.length === 0) return combinedPredicate;
		return predicateOnArray(Array.prototype.every, combinedPredicate, values);
	}
	return predicateOnArray(Array.prototype.every, predicate, values);
}
function isAny(predicate, ...values) {
	if (Array.isArray(predicate)) {
		const predicateArray = predicate;
		validatePredicateArray(predicateArray, values.length === 0);
		const combinedPredicate = (value) => predicateArray.some((singlePredicate) => singlePredicate(value));
		if (values.length === 0) return combinedPredicate;
		return predicateOnArray(Array.prototype.some, combinedPredicate, values);
	}
	return predicateOnArray(Array.prototype.some, predicate, values);
}
function isOptional(value, predicate) {
	return isUndefined(value) || predicate(value);
}
function isArray(value, assertion) {
	if (!Array.isArray(value)) return false;
	if (!isFunction(assertion)) return true;
	return value.every((element) => assertion(element));
}
function isArrayBuffer(value) {
	return getObjectType(value) === "ArrayBuffer";
}
function isArrayLike(value) {
	return !isNullOrUndefined(value) && !isFunction(value) && isValidLength(value.length);
}
function isAsyncFunction(value) {
	return getObjectType(value) === "AsyncFunction";
}
function isAsyncGenerator(value) {
	return isAsyncIterable(value) && isFunction(value.next) && isFunction(value.throw);
}
function isAsyncGeneratorFunction(value) {
	return getObjectType(value) === "AsyncGeneratorFunction";
}
function isAsyncIterable(value) {
	return isFunction(value?.[Symbol.asyncIterator]);
}
function isBigint(value) {
	return typeof value === "bigint";
}
function isBigInt64Array(value) {
	return getObjectType(value) === "BigInt64Array";
}
function isBigUint64Array(value) {
	return getObjectType(value) === "BigUint64Array";
}
function isBlob(value) {
	return getObjectType(value) === "Blob";
}
function isBoolean(value) {
	return value === true || value === false;
}
function isBoundFunction(value) {
	return isFunction(value) && !Object.hasOwn(value, "prototype");
}
/**
Note: [Prefer using `Uint8Array` instead of `Buffer`.](https://sindresorhus.com/blog/goodbye-nodejs-buffer)
*/
function isBuffer(value) {
	return value?.constructor?.isBuffer?.(value) ?? false;
}
function isClass(value) {
	return isFunction(value) && /^class(\s+|{)/.test(value.toString());
}
function isDataView(value) {
	return getObjectType(value) === "DataView";
}
function isDate(value) {
	return getObjectType(value) === "Date";
}
function isDirectInstanceOf(instance, class_) {
	if (instance === void 0 || instance === null) return false;
	return Object.getPrototypeOf(instance) === class_.prototype;
}
function isEmptyArray(value) {
	return isArray(value) && value.length === 0;
}
function isEmptyMap(value) {
	return isMap(value) && value.size === 0;
}
function isEmptyObject(value) {
	return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length === 0;
}
function isEmptySet(value) {
	return isSet(value) && value.size === 0;
}
function isEmptyString(value) {
	return isString(value) && value.length === 0;
}
function isEmptyStringOrWhitespace(value) {
	return isEmptyString(value) || isWhitespaceString(value);
}
function isEnumCase(value, targetEnum) {
	return Object.values(targetEnum).includes(value);
}
function isError(value) {
	return getObjectType(value) === "Error";
}
function isEvenInteger(value) {
	return isAbsoluteModule2(0)(value);
}
function isFalsy(value) {
	return !value;
}
function isFloat32Array(value) {
	return getObjectType(value) === "Float32Array";
}
function isFloat64Array(value) {
	return getObjectType(value) === "Float64Array";
}
function isFormData(value) {
	return getObjectType(value) === "FormData";
}
function isFunction(value) {
	return typeof value === "function";
}
function isGenerator(value) {
	return isIterable(value) && isFunction(value?.next) && isFunction(value?.throw);
}
function isGeneratorFunction(value) {
	return getObjectType(value) === "GeneratorFunction";
}
const NODE_TYPE_ELEMENT = 1;
const DOM_PROPERTIES_TO_CHECK = [
	"innerHTML",
	"ownerDocument",
	"style",
	"attributes",
	"nodeValue"
];
function isHtmlElement(value) {
	return isObject(value) && value.nodeType === NODE_TYPE_ELEMENT && isString(value.nodeName) && !isPlainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
}
function isInfinite(value) {
	return value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
}
function isInRange(value, range) {
	if (isNumber(range)) return value >= Math.min(0, range) && value <= Math.max(range, 0);
	if (isArray(range) && range.length === 2) return value >= Math.min(...range) && value <= Math.max(...range);
	throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
}
function isInt16Array(value) {
	return getObjectType(value) === "Int16Array";
}
function isInt32Array(value) {
	return getObjectType(value) === "Int32Array";
}
function isInt8Array(value) {
	return getObjectType(value) === "Int8Array";
}
function isInteger(value) {
	return Number.isInteger(value);
}
function isIterable(value) {
	return isFunction(value?.[Symbol.iterator]);
}
function isMap(value) {
	return getObjectType(value) === "Map";
}
function isNan(value) {
	return Number.isNaN(value);
}
function isNativePromise(value) {
	return getObjectType(value) === "Promise";
}
function isNegativeNumber(value) {
	return isNumber(value) && value < 0;
}
function isNodeStream(value) {
	return isObject(value) && isFunction(value.pipe) && !isObservable(value);
}
function isNonEmptyArray(value) {
	return isArray(value) && value.length > 0;
}
function isNonEmptyMap(value) {
	return isMap(value) && value.size > 0;
}
function isNonEmptyObject(value) {
	return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length > 0;
}
function isNonEmptySet(value) {
	return isSet(value) && value.size > 0;
}
function isNonEmptyString(value) {
	return isString(value) && value.length > 0;
}
function isNonEmptyStringAndNotWhitespace(value) {
	return isString(value) && !isEmptyStringOrWhitespace(value);
}
function isNull(value) {
	return value === null;
}
function isNullOrUndefined(value) {
	return isNull(value) || isUndefined(value);
}
function isNumber(value) {
	return typeof value === "number" && !Number.isNaN(value);
}
function isNumericString(value) {
	return isString(value) && !isEmptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
}
function isObject(value) {
	return !isNull(value) && (typeof value === "object" || isFunction(value));
}
function isObservable(value) {
	if (!value) return false;
	if (Symbol.observable !== void 0 && value === value[Symbol.observable]?.()) return true;
	if (value === value["@@observable"]?.()) return true;
	return false;
}
function isOddInteger(value) {
	return isAbsoluteModule2(1)(value);
}
function isPlainObject(value) {
	if (typeof value !== "object" || value === null) return false;
	const prototype = Object.getPrototypeOf(value);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function isPositiveNumber(value) {
	return isNumber(value) && value > 0;
}
function isPrimitive(value) {
	return isNull(value) || isPrimitiveTypeName(typeof value);
}
function isPromise(value) {
	return isNativePromise(value) || hasPromiseApi(value);
}
function isPropertyKey(value) {
	return isAny([
		isString,
		isNumber,
		isSymbol
	], value);
}
function isRegExp(value) {
	return getObjectType(value) === "RegExp";
}
function isSafeInteger(value) {
	return Number.isSafeInteger(value);
}
function isSet(value) {
	return getObjectType(value) === "Set";
}
function isSharedArrayBuffer(value) {
	return getObjectType(value) === "SharedArrayBuffer";
}
function isString(value) {
	return typeof value === "string";
}
function isSymbol(value) {
	return typeof value === "symbol";
}
function isTruthy(value) {
	return Boolean(value);
}
function isTupleLike(value, guards) {
	if (isArray(guards) && isArray(value) && guards.length === value.length) return guards.every((guard, index) => guard(value[index]));
	return false;
}
function isTypedArray(value) {
	return isTypedArrayName(getObjectType(value));
}
function isUint16Array(value) {
	return getObjectType(value) === "Uint16Array";
}
function isUint32Array(value) {
	return getObjectType(value) === "Uint32Array";
}
function isUint8Array(value) {
	return getObjectType(value) === "Uint8Array";
}
function isUint8ClampedArray(value) {
	return getObjectType(value) === "Uint8ClampedArray";
}
function isUndefined(value) {
	return value === void 0;
}
function isUrlInstance(value) {
	return getObjectType(value) === "URL";
}
function isUrlSearchParams(value) {
	return getObjectType(value) === "URLSearchParams";
}
function isUrlString(value) {
	if (!isString(value)) return false;
	try {
		new URL(value);
		return true;
	} catch {
		return false;
	}
}
function isValidDate(value) {
	return isDate(value) && !isNan(Number(value));
}
function isValidLength(value) {
	return isSafeInteger(value) && value >= 0;
}
function isWeakMap(value) {
	return getObjectType(value) === "WeakMap";
}
function isWeakRef(value) {
	return getObjectType(value) === "WeakRef";
}
function isWeakSet(value) {
	return getObjectType(value) === "WeakSet";
}
function isWhitespaceString(value) {
	return isString(value) && /^\s+$/.test(value);
}
function predicateOnArray(method, predicate, values) {
	if (!isFunction(predicate)) throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
	if (values.length === 0) throw new TypeError("Invalid number of values");
	return method.call(values, predicate);
}
const andFormatter = new Intl.ListFormat("en", {
	style: "long",
	type: "conjunction"
});
const orFormatter = new Intl.ListFormat("en", {
	style: "long",
	type: "disjunction"
});
const methodTypeMap = {
	isArray: "Array",
	isArrayBuffer: "ArrayBuffer",
	isArrayLike: "array-like",
	isAsyncFunction: "AsyncFunction",
	isAsyncGenerator: "AsyncGenerator",
	isAsyncGeneratorFunction: "AsyncGeneratorFunction",
	isAsyncIterable: "AsyncIterable",
	isBigint: "bigint",
	isBigInt64Array: "BigInt64Array",
	isBigUint64Array: "BigUint64Array",
	isBlob: "Blob",
	isBoolean: "boolean",
	isBoundFunction: "Function",
	isBuffer: "Buffer",
	isClass: "Class",
	isDataView: "DataView",
	isDate: "Date",
	isDirectInstanceOf: "T",
	isEmptyArray: "empty array",
	isEmptyMap: "empty map",
	isEmptyObject: "empty object",
	isEmptySet: "empty set",
	isEmptyString: "empty string",
	isEmptyStringOrWhitespace: "empty string or whitespace",
	isEnumCase: "EnumCase",
	isError: "Error",
	isEvenInteger: "even integer",
	isFalsy: "falsy",
	isFloat32Array: "Float32Array",
	isFloat64Array: "Float64Array",
	isFormData: "FormData",
	isFunction: "Function",
	isGenerator: "Generator",
	isGeneratorFunction: "GeneratorFunction",
	isHtmlElement: "HTMLElement",
	isInfinite: "infinite number",
	isInRange: "in range",
	isInt16Array: "Int16Array",
	isInt32Array: "Int32Array",
	isInt8Array: "Int8Array",
	isInteger: "integer",
	isIterable: "Iterable",
	isMap: "Map",
	isNan: "NaN",
	isNativePromise: "native Promise",
	isNegativeNumber: "negative number",
	isNodeStream: "Node.js Stream",
	isNonEmptyArray: "non-empty array",
	isNonEmptyMap: "non-empty map",
	isNonEmptyObject: "non-empty object",
	isNonEmptySet: "non-empty set",
	isNonEmptyString: "non-empty string",
	isNonEmptyStringAndNotWhitespace: "non-empty string and not whitespace",
	isNull: "null",
	isNullOrUndefined: "null or undefined",
	isNumber: "number",
	isNumericString: "string with a number",
	isObject: "Object",
	isObservable: "Observable",
	isOddInteger: "odd integer",
	isPlainObject: "plain object",
	isPositiveNumber: "positive number",
	isPrimitive: "primitive",
	isPromise: "Promise",
	isPropertyKey: "PropertyKey",
	isRegExp: "RegExp",
	isSafeInteger: "integer",
	isSet: "Set",
	isSharedArrayBuffer: "SharedArrayBuffer",
	isString: "string",
	isSymbol: "symbol",
	isTruthy: "truthy",
	isTupleLike: "tuple-like",
	isTypedArray: "TypedArray",
	isUint16Array: "Uint16Array",
	isUint32Array: "Uint32Array",
	isUint8Array: "Uint8Array",
	isUint8ClampedArray: "Uint8ClampedArray",
	isUndefined: "undefined",
	isUrlInstance: "URL",
	isUrlSearchParams: "URLSearchParams",
	isUrlString: "string with a URL",
	isValidDate: "valid Date",
	isValidLength: "valid length",
	isWeakMap: "WeakMap",
	isWeakRef: "WeakRef",
	isWeakSet: "WeakSet",
	isWhitespaceString: "whitespace string"
};
const isMethodNames = keysOf(methodTypeMap);

//#endregion
//#region ../../node_modules/.pnpm/@poppinss+dumper@0.6.5/node_modules/@poppinss/dumper/build/chunk-26HALFTP.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
};
var helpers_exports = {};
__export(helpers_exports, {
	htmlEscape: () => htmlEscape,
	tokenizeArray: () => tokenizeArray,
	tokenizeObject: () => tokenizeObject,
	tokenizePrototype: () => tokenizePrototype,
	wordWrap: () => wordWrap
});
var ObjectPrototype = Object.prototype;
var ArrayPrototype = Array.prototype;
var ObjectPrototypeKeys = Reflect.ownKeys(ObjectPrototype);
var ArrayPrototypeKeys = Reflect.ownKeys(ArrayPrototype);
function tokenizeObject(value, parser, config) {
	parser.context.objectsSeen = parser.context.objectsSeen ?? /* @__PURE__ */ new Set();
	parser.context.depth = parser.context.depth ?? 0;
	if (parser.context.objectsSeen.has(value)) {
		parser.collect({ type: "object-circular-ref" });
		return;
	}
	if (parser.context.depth >= parser.config.depth) {
		parser.collect({ type: "object-max-depth-ref" });
		return;
	}
	const showHidden = config.showHidden;
	const name = config.constructorName ?? Object.getPrototypeOf(value)?.constructor.name ?? null;
	if (config.collapse.includes(name)) {
		parser.collect({
			type: "collapse",
			name,
			token: {
				type: "object-start",
				constructorName: name
			}
		});
		return;
	}
	const ownKeys = Reflect.ownKeys(value);
	const eagerGetters = config.eagerGetters ?? [];
	parser.context.depth++;
	parser.context.objectsSeen.add(value);
	let keys = [];
	if (config.membersToIgnore) {
		const keysSet = /* @__PURE__ */ new Set([...ownKeys]);
		config.membersToIgnore.forEach((m) => keysSet.delete(m));
		keys = Array.from(keysSet);
	} else keys = ownKeys;
	parser.collect({
		type: "object-start",
		constructorName: name
	});
	for (let key of keys) {
		const descriptor = Object.getOwnPropertyDescriptor(value, key);
		if (!descriptor) continue;
		if (!descriptor.enumerable && !showHidden) continue;
		const isSymbol = typeof key === "symbol";
		const isWritable = !!descriptor.set || !!descriptor.writable;
		parser.collect({
			type: "object-key",
			isSymbol,
			isWritable,
			value: String(key)
		});
		if ("get" in descriptor && !eagerGetters.includes(key)) {
			parser.collect({ type: "object-value-getter" });
			continue;
		}
		parser.collect({ type: "object-value-start" });
		parser.parse(value[key]);
		parser.collect({ type: "object-value-end" });
	}
	if (config.inspectObjectPrototype === true) tokenizePrototype(value, parser, { membersToIgnore: ObjectPrototypeKeys });
	else if (config.inspectObjectPrototype === "unless-plain-object" && !is.plainObject(value)) tokenizePrototype(value, parser, {
		membersToIgnore: ObjectPrototypeKeys,
		prototypeToIgnore: ObjectPrototype
	});
	parser.collect({ type: "object-end" });
	parser.context.depth--;
	parser.context.objectsSeen.delete(value);
}
function tokenizePrototype(value, parser, config) {
	const prototypeChain = [];
	for (let proto = Object.getPrototypeOf(value); proto && (!config.prototypeToIgnore || proto !== config.prototypeToIgnore); proto = Object.getPrototypeOf(proto)) {
		let keys = Reflect.ownKeys(proto);
		if (config.membersToIgnore) {
			const keysSet = /* @__PURE__ */ new Set([...keys]);
			config.membersToIgnore.forEach((m) => keysSet.delete(m));
			keys = Array.from(keysSet);
		}
		prototypeChain.push({
			proto,
			keys
		});
	}
	if (!prototypeChain.length) return;
	const eagerGetters = config.eagerGetters ?? [];
	parser.collect({ type: "prototype-start" });
	for (let proto of prototypeChain) for (let key of proto.keys) {
		if (key === "constructor") continue;
		const descriptor = Object.getOwnPropertyDescriptor(proto.proto, key);
		if (!descriptor) continue;
		const isSymbol = typeof key === "symbol";
		const isWritable = !!descriptor.set || !!descriptor.writable;
		parser.collect({
			type: "object-key",
			isSymbol,
			isWritable,
			value: String(key)
		});
		if ("get" in descriptor && !eagerGetters.includes(key)) {
			parser.collect({ type: "object-value-getter" });
			continue;
		}
		parser.collect({ type: "object-value-start" });
		parser.parse(value[key]);
		parser.collect({ type: "object-value-end" });
	}
	parser.collect({ type: "prototype-end" });
}
function tokenizeArray(values, parser, config) {
	parser.context.arraysSeen = parser.context.arraysSeen ?? /* @__PURE__ */ new Set();
	parser.context.depth = parser.context.depth ?? 0;
	if (parser.context.arraysSeen.has(values)) {
		parser.collect({ type: "array-circular-ref" });
		return;
	}
	if (parser.context.depth >= config.depth) {
		parser.collect({ type: "array-max-depth-ref" });
		return;
	}
	const limit = config.maxArrayLength;
	const size = values.length;
	const name = config.name || values.constructor.name;
	if (config.collapse.includes(name)) {
		parser.collect({
			type: "collapse",
			name,
			token: {
				type: "array-start",
				name,
				size
			}
		});
		return;
	}
	parser.context.depth++;
	parser.context.arraysSeen.add(values);
	parser.collect({
		type: "array-start",
		name,
		size
	});
	for (let index = 0; index < size; index++) {
		if (index >= limit) {
			parser.collect({
				type: "array-max-length-ref",
				limit,
				size
			});
			break;
		}
		const value = values[index];
		if (Object.hasOwn(values, index)) {
			parser.collect({
				type: "array-value-start",
				index
			});
			parser.parse(value);
			parser.collect({
				type: "array-value-end",
				index
			});
		} else parser.collect({
			type: "array-value-hole",
			index
		});
	}
	if (config.inspectArrayPrototype) tokenizePrototype(values, parser, {
		membersToIgnore: ArrayPrototypeKeys,
		prototypeToIgnore: ArrayPrototype
	});
	parser.collect({
		type: "array-end",
		size
	});
	parser.context.depth--;
	parser.context.arraysSeen.delete(values);
}
function htmlEscape(value) {
	return value.replace(/&/g, "&amp;").replace(/\\"/g, "&bsol;&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function wordWrap(value, options) {
	const width = options.width;
	const indent = options.indent;
	const newLine = `${options.newLine}${indent}`;
	let regexString = ".{1," + width + "}";
	regexString += "([\\s​]+|$)|[^\\s​]+?([\\s​]+|$)";
	const re = new RegExp(regexString, "g");
	return (value.match(re) || []).map(function(line) {
		if (line.slice(-1) === "\n") line = line.slice(0, line.length - 1);
		return options.escape ? options.escape(line) : htmlEscape(line);
	}).join(newLine);
}
var tokenizers = {
	Object: (value, parser) => {
		tokenizeObject(value, parser, parser.config);
	},
	Array: (values, parser) => {
		tokenizeArray(values, parser, parser.config);
	},
	Map: (values, parser) => {
		parser.context.mapsSeen = parser.context.mapsSeen ?? /* @__PURE__ */ new Set();
		parser.context.depth = parser.context.depth ?? 0;
		if (parser.context.mapsSeen.has(values)) {
			parser.collect({ type: "map-circular-ref" });
			return;
		}
		if (parser.context.depth >= parser.config.depth) {
			parser.collect({ type: "map-max-depth-ref" });
			return;
		}
		parser.context.depth++;
		parser.context.mapsSeen.add(values);
		let index = 0;
		const size = values.size;
		const limit = parser.config.maxArrayLength;
		parser.collect({
			type: "map-start",
			size
		});
		for (let [key, value] of values) {
			if (index >= limit) {
				parser.collect({
					type: "map-max-length-ref",
					limit,
					size
				});
				break;
			}
			parser.collect({
				type: "map-row-start",
				index
			});
			parser.collect({
				type: "map-key-start",
				index
			});
			parser.parse(key);
			parser.collect({
				type: "map-key-end",
				index
			});
			parser.collect({
				type: "map-value-start",
				index
			});
			parser.parse(value);
			parser.collect({
				type: "map-value-end",
				index
			});
			parser.collect({
				type: "map-row-end",
				index
			});
			index++;
		}
		parser.collect({
			type: "map-end",
			size
		});
		parser.context.depth--;
		parser.context.mapsSeen.delete(values);
	},
	Set: (values, parser) => {
		parser.context.setsSeen = parser.context.setsSeen ?? /* @__PURE__ */ new Set();
		parser.context.depth = parser.context.depth ?? 0;
		if (parser.context.setsSeen.has(values)) {
			parser.collect({ type: "set-circular-ref" });
			return;
		}
		if (parser.context.depth >= parser.config.depth) {
			parser.collect({ type: "set-max-depth-ref" });
			return;
		}
		parser.context.depth++;
		parser.context.setsSeen.add(values);
		let index = 0;
		const size = values.size;
		const limit = parser.config.maxArrayLength;
		parser.collect({
			type: "set-start",
			size
		});
		for (let value of values) {
			if (index >= limit) {
				parser.collect({
					type: "set-max-length-ref",
					limit,
					size
				});
				break;
			}
			parser.collect({
				type: "set-value-start",
				index
			});
			parser.parse(value);
			parser.collect({
				type: "set-value-end",
				index
			});
			index++;
		}
		parser.collect({
			type: "set-end",
			size
		});
		parser.context.depth--;
		parser.context.setsSeen.delete(values);
	},
	Function: (value, parser) => {
		const ConstructorName = value.constructor.name;
		if (ConstructorName === "GeneratorFunction") return tokenizers.GeneratorFunction(value, parser);
		if (ConstructorName === "AsyncGeneratorFunction") return tokenizers.AsyncGeneratorFunction(value, parser);
		if (ConstructorName === "AsyncFunction") return tokenizers.AsyncFunction(value, parser);
		const isClass = is.class(value);
		parser.collect({
			type: "function",
			isClass,
			isAsync: false,
			isGenerator: false,
			name: value.name || "anonymous"
		});
		if (parser.config.inspectStaticMembers && isClass) {
			parser.collect({ type: "static-members-start" });
			tokenizeObject(value, parser, {
				showHidden: true,
				depth: parser.config.depth,
				inspectObjectPrototype: false,
				collapse: parser.config.collapse,
				membersToIgnore: [
					"prototype",
					"name",
					"length"
				]
			});
			parser.collect({ type: "static-members-end" });
		}
	},
	string: (value, parser) => {
		const formatted = inspect$1(value, {
			maxStringLength: parser.config.maxStringLength,
			customInspect: false
		});
		parser.collect({
			type: "string",
			value: formatted
		});
	},
	URL: (value, parser) => {
		tokenizeObject({
			hash: value.hash,
			host: value.host,
			hostname: value.hostname,
			href: value.href,
			origin: value.origin,
			password: value.password,
			pathname: value.pathname,
			port: value.port,
			protocol: value.protocol,
			search: value.search,
			searchParams: value.searchParams,
			username: value.username
		}, parser, {
			constructorName: "URL",
			...parser.config
		});
	},
	URLSearchParams: (value, parser) => {
		tokenizeObject(Object.fromEntries(value), parser, {
			constructorName: "URLSearchParams",
			...parser.config
		});
	},
	Error: function(value, parser) {
		tokenizeObject(value, parser, {
			eagerGetters: ["message", "stack"],
			...parser.config,
			inspectObjectPrototype: parser.config.inspectObjectPrototype === true ? true : false,
			showHidden: true
		});
	},
	FormData: function(value, parser) {
		tokenizeObject(Object.fromEntries(value.entries()), parser, {
			constructorName: "FormData",
			...parser.config
		});
	},
	undefined: (_, parser) => {
		parser.collect({ type: "undefined" });
	},
	null: (_, parser) => {
		parser.collect({ type: "null" });
	},
	symbol: (value, parser) => {
		parser.collect({
			type: "symbol",
			value: String(value)
		});
	},
	number: (value, parser) => {
		parser.collect({
			type: "number",
			value
		});
	},
	boolean: (value, parser) => {
		parser.collect({
			type: "boolean",
			value
		});
	},
	bigint: (value, parser) => {
		parser.collect({
			type: "bigInt",
			value: `${value.toString()}n`
		});
	},
	Date: (value, parser) => {
		parser.collect({
			type: "date",
			value: value.toISOString()
		});
	},
	RegExp: (value, parser) => {
		parser.collect({
			type: "regexp",
			value: String(value)
		});
	},
	Buffer: (value, parser) => {
		parser.collect({
			type: "buffer",
			value: inspect$1(value)
		});
	},
	WeakSet: (_, parser) => {
		parser.collect({ type: "weak-set" });
	},
	WeakMap: (_, parser) => {
		parser.collect({ type: "weak-map" });
	},
	WeakRef: function(_, parser) {
		parser.collect({ type: "weak-ref" });
	},
	Generator: function(_, parser) {
		parser.collect({
			type: "generator",
			isAsync: false
		});
	},
	AsyncGenerator: function(_, parser) {
		parser.collect({
			type: "generator",
			isAsync: true
		});
	},
	GeneratorFunction: function(value, parser) {
		parser.collect({
			type: "function",
			isGenerator: true,
			isClass: false,
			isAsync: false,
			name: value.name || "anonymous"
		});
	},
	AsyncGeneratorFunction: function(value, parser) {
		parser.collect({
			type: "function",
			isGenerator: true,
			isClass: false,
			isAsync: true,
			name: value.name || "anonymous"
		});
	},
	AsyncFunction: function(value, parser) {
		parser.collect({
			type: "function",
			isGenerator: false,
			isClass: false,
			isAsync: true,
			name: value.name || "anonymous"
		});
	},
	Observable: function(_, parser) {
		parser.collect({ type: "observable" });
	},
	Blob: function(value, parser) {
		parser.collect({
			type: "blob",
			size: value.size,
			contentType: value.type
		});
	},
	Promise: function(value, parser) {
		parser.collect({
			type: "promise",
			isFulfilled: !inspect$1(value).includes("pending")
		});
	},
	NaN: function(_, parser) {
		parser.collect({
			type: "number",
			value: NaN
		});
	},
	Int8Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	},
	Uint8Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	},
	Int16Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	},
	Uint16Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	},
	Int32Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	},
	Uint32Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	},
	Float32Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	},
	Float64Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	},
	BigInt64Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	},
	BigUint64Array: function(value, parser) {
		tokenizeArray(value, parser, parser.config);
	}
};
var Parser = class {
	#tokens = [];
	/**
	* Config shared with tokenizers
	*/
	config;
	/**
	* Context maintained through out the parsing phase.
	* Each instance of Parser has its own context
	* that gets mutated internally.
	*/
	context;
	constructor(config, context) {
		this.context = context || {};
		this.config = Object.freeze({
			showHidden: false,
			depth: 5,
			inspectObjectPrototype: "unless-plain-object",
			inspectArrayPrototype: false,
			inspectStaticMembers: false,
			maxArrayLength: 100,
			maxStringLength: 1e3,
			collapse: [],
			...config
		});
	}
	/**
	* Normalizes the type name of a property using additional
	* bit of checks. For example, the "is" module does not
	* use instanceOf checks and hence misses out on many
	* potentional improvements.
	*/
	#normalizeTypeName(name, value) {
		if (name === "Object" && value instanceof Error) return "Error";
		return name;
	}
	/**
	* Collect a token inside the list of tokens. The order
	* of tokens matter during printing therefore you must
	* collect tokens in the right order.
	*/
	collect(token) {
		this.#tokens.push(token);
	}
	/**
	* Parses a value using the tokenizers. Under the hood the
	* tokenizers will call "parser.collect" to collect
	* tokens inside an array.
	*
	* You can use "parser.flush" method to get the list of
	* tokens.
	*/
	parse(value) {
		const typeName = this.#normalizeTypeName(is.detect(value), value);
		const tokenizer = tokenizers[typeName];
		if (tokenizer) tokenizer(value, this);
		else this.collect({
			type: "unknown",
			jsType: typeName,
			value
		});
	}
	/**
	* Returns collected tokens and resets the internal state.
	*/
	flush() {
		const tokens = this.#tokens;
		this.#tokens = [];
		this.context = {};
		return tokens;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@poppinss+dumper@0.6.5/node_modules/@poppinss/dumper/build/formatters/html/main.js
var themes$1 = {
	nightOwl: {
		pre: "background-color: #061626; color: #c792ea;",
		toggle: "color: #4f5357; background: none; border: none;",
		braces: "color: #ffd700;",
		brackets: "color: #ffd700;",
		number: "color: #f78c6c;",
		bigInt: "color: #f78c6c; font-weight: bold;",
		boolean: "color: #ff5874; font-style: italic;",
		string: "color: #ecc48d;",
		null: "color: #637777;",
		undefined: "color: #637777;",
		prototypeLabel: "color: #637777;",
		symbol: "color: #82aaff;",
		regex: "color: #ff5874;",
		date: "color: #7fdbca;",
		buffer: "color: #7fdbca;",
		functionLabel: "color: #89b4fa;",
		arrayLabel: "color: #82aaff;",
		objectLabel: "color: #82aaff;",
		mapLabel: "color: #82aaff;",
		setLabel: "color: #82aaff;",
		objectKey: "color: #c792ea;",
		objectKeyPrefix: "color: #637777; font-style: italic; font-weight: bold",
		classLabel: "color: #82aaff;",
		collapseLabel: "color: #7fdbca; font-style: italic;",
		getterLabel: "color: #7fdbca;",
		circularLabel: "color: #7fdbca;",
		weakSetLabel: "color: #7fdbca;",
		weakRefLabel: "color: #7fdbca;",
		weakMapLabel: "color: #7fdbca;",
		observableLabel: "color: #7fdbca;",
		promiseLabel: "color: #7fdbca;",
		generatorLabel: "color: #7fdbca;",
		blobLabel: "color: #7fdbca;",
		unknownLabel: "color: #7fdbca;"
	},
	minLight: {
		pre: "background-color: #fff; color: #212121;",
		toggle: "color: #989999; background: none; border: none;",
		braces: "color: #0431fa;",
		brackets: "color: #0431fa;",
		number: "color: #1976d2;",
		bigInt: "color: #1976d2; font-weight: bold;",
		boolean: "color: #1976d2; font-style: italic;",
		string: "color: #22863a;",
		null: "color: #9c9c9d;",
		undefined: "color: #9c9c9d;",
		prototypeLabel: "color: #9c9c9d;",
		symbol: "color: #d32f2f;",
		regex: "color: #1976d2;",
		date: "color: #7b3814;",
		buffer: "color: #7b3814;",
		functionLabel: "color: #6f42c1;",
		arrayLabel: "color: #d32f2f;",
		objectLabel: "color: #d32f2f;",
		mapLabel: "color: #d32f2f;",
		setLabel: "color: #d32f2f;",
		objectKey: "color: #212121;",
		objectKeyPrefix: "color: #9c9c9d; font-style: italic; font-weight: bold",
		classLabel: "color: #6f42c1;",
		collapseLabel: "color: #9c9c9d; font-style: italic;",
		getterLabel: "color: #7b3814;",
		circularLabel: "color: #7b3814;",
		weakSetLabel: "color: #7b3814;",
		weakRefLabel: "color: #7b3814;",
		weakMapLabel: "color: #7b3814;",
		observableLabel: "color: #7b3814;",
		promiseLabel: "color: #7b3814;",
		generatorLabel: "color: #7b3814;",
		blobLabel: "color: #7b3814;",
		unknownLabel: "color: #7b3814;"
	},
	catppuccin: {
		pre: "background-color: #1e1e2e; color: #94e2d5;",
		toggle: "color: #7c7c8c; background: none; border: none;",
		braces: "color: #f38ba8;",
		brackets: "color: #f38ba8;",
		number: "color: #fab387;",
		bigInt: "color: #fab387; font-weight: bold;",
		boolean: "color: #cba6f7; font-style: italic;",
		string: "color: #a6e3a1;",
		null: "color: #6c7086;",
		undefined: "color: #6c7086;",
		prototypeLabel: "color: #6c7086;",
		symbol: "color: #f9e2af;",
		regex: "color: #cba6f7;",
		date: "color: #94e2d5;",
		buffer: "color: #94e2d5;",
		functionLabel: "color: #cba6f7;",
		arrayLabel: "color: #f9e2af;",
		objectLabel: "color: #f9e2af;",
		mapLabel: "color: #f9e2af;",
		setLabel: "color: #f9e2af;",
		objectKey: "color: #89b4fa;",
		objectKeyPrefix: "color: #6c7086; font-style: italic; font-weight: bold",
		classLabel: "color: #cba6f7;",
		collapseLabel: "color: #6c7086; font-style: italic;",
		getterLabel: "color: #94e2d5;",
		circularLabel: "color: #94e2d5;",
		weakSetLabel: "color: #94e2d5;",
		weakRefLabel: "color: #94e2d5;",
		weakMapLabel: "color: #94e2d5;",
		observableLabel: "color: #94e2d5;",
		promiseLabel: "color: #94e2d5;",
		generatorLabel: "color: #94e2d5;",
		blobLabel: "color: #94e2d5;",
		unknownLabel: "color: #94e2d5;"
	},
	cssVariables: {
		pre: "background-color: var(--pre-bg-color); color: var(--pre-fg-color);",
		toggle: "color: var(--toggle-fg-color); background: none; border: none;",
		braces: "color: var(--braces-fg-color);",
		brackets: "color: var(--brackets-fg-color);",
		number: "color: var(--dt-number-fg-color);",
		bigInt: "color: var(--dt-bigint-fg-color); font-weight: bold;",
		boolean: "color: var(--dt-boolean-fg-color); font-style: italic;",
		string: "color: var(--dt-string-fg-color);",
		null: "color: var(--dt-null-fg-color);",
		undefined: "color: var(--dt-undefined-fg-color);",
		prototypeLabel: "color: var(--prototype-label-fg-color);",
		symbol: "color: var(--dt-symbol-fg-color);",
		regex: "color: var(--dt-regex-fg-color);",
		date: "color: var(--dt-date-fg-color);",
		buffer: "color: var(--dt-buffer-fg-color);",
		functionLabel: "color: var(--function-label-fg-color);",
		arrayLabel: "color: var(--array-label-fg-color);",
		objectLabel: "color: var(--object-label-fg-color);",
		mapLabel: "color: var(--map-label-fg-color);",
		setLabel: "color: var(--set-label-fg-color);",
		objectKey: "color: var(--object-key-fg-color);",
		objectKeyPrefix: "color: var(--object-key-prefix-fg-color); font-style: italic; font-weight: bold",
		classLabel: "color: var(--class-label-fg-color);",
		collapseLabel: "color: var(--collpase-label-fg-color); font-style: italic;",
		getterLabel: "color: var(--getter-label-fg-color);",
		circularLabel: "color: var(--circular-label-fg-color);",
		weakSetLabel: "color: var(--weakset-label-fg-color);",
		weakRefLabel: "color: var(--weakref-label-fg-color);",
		weakMapLabel: "color: var(--weakmap-label-fg-color);",
		observableLabel: "color: var(--observable-label-fg-color);",
		promiseLabel: "color: var(--promise-label-fg-color);",
		generatorLabel: "color: var(--generator-label-fg-color);",
		blobLabel: "color: var(--blob-label-fg-color);",
		unknownLabel: "color: var(--unknown-label-fg-color);"
	}
};
var dropdownIcon = "&#9660;";
function openingBrace$1(formatter) {
	return `<span style="${formatter.styles.braces}">{</span>`;
}
function closingBrace$1(formatter) {
	return `<span style="${formatter.styles.braces}">}</span>`;
}
function openingBrackets$1(formatter) {
	return `<span style="${formatter.styles.brackets}">[</span>`;
}
function closingBrackets$1(formatter) {
	return `<span style="${formatter.styles.brackets}">]</span>`;
}
var HTMLPrinters = {
	"collapse": (token, formatter) => {
		const styles = token.token.type === "object-start" ? formatter.styles.objectLabel : formatter.styles.arrayLabel;
		const collpaseStyles = formatter.styles.collapseLabel;
		return `<span style="${styles}">${token.name}</span> ` + (token.token.type === "object-start" ? openingBrace$1(formatter) : openingBrackets$1(formatter)) + ` <span style="${collpaseStyles}">collapsed</span> ` + (token.token.type === "object-start" ? closingBrace$1(formatter) : closingBrackets$1(formatter));
	},
	"object-start": (token, formatter) => {
		formatter.indentation.increment();
		const styles = formatter.styles.objectLabel;
		const toggleStyles = formatter.styles.toggle;
		return `<span class="dumper-group dumper-object-group"><span style="${styles}">${formatter.context.isStaticMember && formatter.context.staticDepth === 0 ? " " : `${token.constructorName || "Object [null]"} `}</span>` + openingBrace$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
	},
	"object-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}</samp>` + closingBrace$1(formatter) + "</span>";
	},
	"object-key": (token, formatter) => {
		formatter.context.isStack = token.value === "stack";
		const styles = formatter.styles.objectKey;
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		let value = token.value;
		if (token.isSymbol) value = `[${value}]`;
		else if (!/^[a-z$_][$\w]*$/i.test(value)) value = `"${htmlEscape(value.replace(/"/g, "\\\""))}"`;
		let prefix = "";
		if (formatter.context.isStaticMember) {
			formatter.context.staticDepth++;
			if (formatter.context.staticDepth === 1) prefix = `<span class="dumper-object-prefix" style="${formatter.styles.objectKeyPrefix}">static </span>`;
		}
		return indent + prefix + `<span class="dumper-object-key" style="${styles}">${value}</span>: `;
	},
	"object-circular-ref": (_, formatter) => {
		return `<span style="${formatter.styles.circularLabel}">[*Circular]</span>`;
	},
	"object-max-depth-ref": (_, formatter) => {
		return `<span style="${formatter.styles.objectLabel}">[Object]</span>`;
	},
	"object-value-getter": (_, formatter) => {
		return `<span style="${formatter.styles.getterLabel}">[Getter]</span>`;
	},
	"object-value-start": () => {
		return "";
	},
	"object-value-end": (_, formatter) => {
		if (formatter.context.isStaticMember) formatter.context.staticDepth--;
		return `,`;
	},
	"array-start": (token, formatter) => {
		formatter.indentation.increment();
		const toggleStyles = formatter.styles.toggle;
		return `<span class="dumper-group dumper-array-group"><span style="${formatter.styles.arrayLabel}">${`${token.name}:${token.size} `}</span>` + openingBrackets$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
	},
	"array-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}</samp>` + closingBrackets$1(formatter) + "</span>";
	},
	"array-value-start": (_, formatter) => {
		return `${formatter.newLine}${formatter.indentation.getSpaces()}`;
	},
	"array-value-hole": (_, formatter) => {
		return `${formatter.newLine}${formatter.indentation.getSpaces()}<span class="dumper-undefined" style="${formatter.styles.undefined}">${htmlEscape("<hole>")},</span>`;
	},
	"array-value-end": () => {
		return `,`;
	},
	"array-circular-ref": (_, formatter) => {
		return `<span style="${formatter.styles.circularLabel}">[*Circular]</span>`;
	},
	"array-max-depth-ref": (_, formatter) => {
		return `<span style="${formatter.styles.arrayLabel}">[Array]</span>`;
	},
	"array-max-length-ref": (token, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		const styles = formatter.styles.arrayLabel;
		const itemsLeft = token.size - token.limit;
		if (itemsLeft <= 0) return "";
		return `${indent}<span style="${styles}">[...${itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`}]</span>`;
	},
	"prototype-start": (_, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		formatter.indentation.increment();
		const styles = formatter.styles.prototypeLabel;
		const toggleStyles = formatter.styles.toggle;
		return indent + `<span class="dumper-group dumper-prototype-group"><span style="${styles}">[[Prototype]] </span>` + openingBrace$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
	},
	"prototype-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}</samp>` + closingBrace$1(formatter) + "</span>";
	},
	"map-start": (token, formatter) => {
		formatter.indentation.increment();
		const toggleStyles = formatter.styles.toggle;
		return `<span class="dumper-group dumper-map-group"><span style="${formatter.styles.mapLabel}">${`Map:${token.size} `}</span>` + openingBrace$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
	},
	"map-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}</samp>` + closingBrace$1(formatter) + "</span>";
	},
	"map-row-start": (_, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		formatter.indentation.increment();
		return indent + openingBrackets$1(formatter);
	},
	"map-row-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}` + closingBrackets$1(formatter) + `,`;
	},
	"map-key-start": (_, formatter) => {
		const styles = formatter.styles.objectKey;
		return `${formatter.newLine}${formatter.indentation.getSpaces()}<span style="${styles}">key</span>: `;
	},
	"map-key-end": function() {
		return "";
	},
	"map-value-start": (_, formatter) => {
		const styles = formatter.styles.objectKey;
		return `${formatter.newLine}${formatter.indentation.getSpaces()}<span style="${styles}">value</span>: `;
	},
	"map-value-end": function() {
		return "";
	},
	"map-circular-ref": (_, formatter) => {
		return `${`${formatter.newLine}${formatter.indentation.getSpaces()}`}<span style="${formatter.styles.circularLabel}">[*Circular]</span>`;
	},
	"map-max-depth-ref": (_, formatter) => {
		return `<span style="${formatter.styles.mapLabel}">[Map]</span>`;
	},
	"map-max-length-ref": (token, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		const styles = formatter.styles.mapLabel;
		const itemsLeft = token.size - token.limit;
		if (itemsLeft <= 0) return "";
		return `${indent}<span style="${styles}">[...${itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`}]</span>`;
	},
	"set-start": (token, formatter) => {
		formatter.indentation.increment();
		const toggleStyles = formatter.styles.toggle;
		return `<span class="dumper-group dumper-set-group"><span class="dumper-set-label" style="${formatter.styles.setLabel}">${`Set:${token.size} `}</span>` + openingBrackets$1(formatter) + `<button class="dumper-toggle" style="${toggleStyles}"><span>${dropdownIcon}</span></button><samp hidden="true">`;
	},
	"set-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}</samp>` + closingBrackets$1(formatter) + "</span>";
	},
	"set-value-start": (_, formatter) => {
		return `${formatter.newLine}${formatter.indentation.getSpaces()}`;
	},
	"set-value-end": () => {
		return `,`;
	},
	"set-circular-ref": (_, formatter) => {
		return `<span style="${formatter.styles.circularLabel}">[*Circular]</span>`;
	},
	"set-max-depth-ref": (_, formatter) => {
		return `<span style="${formatter.styles.setLabel}">[Set]</span>`;
	},
	"set-max-length-ref": (token, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		const styles = formatter.styles.setLabel;
		const itemsLeft = token.size - token.limit;
		if (itemsLeft <= 0) return "";
		return `${indent}<span style="${styles}">[...${itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`}]</span>`;
	},
	"string": (token, formatter) => {
		let value = token.value;
		const indent = formatter.indentation.getSpaces();
		if (formatter.context.isStack) value = token.value.split("\n").map((row, index) => {
			let rowValue = `<span>${htmlEscape(row.trim())}</span>`;
			if (index > 0) rowValue = `${indent}${rowValue}`;
			return rowValue;
		}).join("\n");
		else value = wordWrap(token.value, {
			newLine: formatter.newLine,
			indent: formatter.indentation.getSpaces(),
			width: 70
		});
		return `<span class="dumper-string" style="${formatter.styles.string}">${value}</span>`;
	},
	"boolean": (token, formatter) => {
		return `<span class="dumper-boolean" style="${formatter.styles.boolean}">` + token.value + "</span>";
	},
	"number": (token, formatter) => {
		return `<span class="dumper-number" style="${formatter.styles.number}">` + token.value + "</span>";
	},
	"bigInt": (token, formatter) => {
		return `<span class="dumper-big-int" style="${formatter.styles.bigInt}">` + token.value + "</span>";
	},
	"undefined": (_, formatter) => {
		return `<span class="dumper-undefined" style="${formatter.styles.undefined}">undefined</span>`;
	},
	"null": (_, formatter) => {
		return `<span class="dumper-null" style="${formatter.styles.null}">null</span>`;
	},
	"symbol": (token, formatter) => {
		return `<span class="dumper-symbol" style="${formatter.styles.symbol}">` + token.value + "</span>";
	},
	"function": (token, formatter) => {
		const className = token.isClass ? "dumper-class" : "dumper-function";
		const styles = token.isClass ? formatter.styles.classLabel : formatter.styles.functionLabel;
		const async = token.isAsync ? `async ` : "";
		const generator = token.isGenerator ? `*` : "";
		const label = token.isClass ? `[class ${token.name}]` : `[${async}${generator}function ${token.name}]`;
		return `<span class="${className}" style="${styles}">` + label + "</span>";
	},
	"date": function(token, formatter) {
		return `<span class="dumper-date" style="${formatter.styles.date}">` + token.value + "</span>";
	},
	"buffer": function(token, formatter) {
		return `<span class="dumper-buffer" style="${formatter.styles.buffer}">` + htmlEscape(token.value) + "</span>";
	},
	"regexp": function(token, formatter) {
		return `<span class="dumper-regex" style="${formatter.styles.regex}">` + token.value + "</span>";
	},
	"unknown": function(token, formatter) {
		return `<span class="dumper-value-unknown" style="${formatter.styles.unknownLabel}">` + String(token.value) + "</span>";
	},
	"weak-set": function(_, formatter) {
		return `<span class="dumper-weak-set" style="${formatter.styles.weakSetLabel}">[WeakSet]</span>`;
	},
	"weak-ref": function(_, formatter) {
		return `<span class="dumper-weak-ref" style="${formatter.styles.weakRefLabel}">[WeakRef]</span>`;
	},
	"weak-map": function(_, formatter) {
		return `<span class="dumper-weak-map" style="${formatter.styles.weakMapLabel}">[WeakMap]</span>`;
	},
	"observable": function(_, formatter) {
		return `<span class="dumper-observable" style="${formatter.styles.observableLabel}">[Observable]</span>`;
	},
	"blob": function(token, formatter) {
		const styles = formatter.styles.objectLabel;
		const propertiesStart = `<span styles="${formatter.styles.braces}">{ `;
		const propertiesEnd = `<span styles="${formatter.styles.braces}"> }</span></span>`;
		const sizeProp = `<span styles="${formatter.styles.objectKey}">size: </span>`;
		const sizeValue = `<span styles="${formatter.styles.number}">${token.size}</span>,`;
		const typeProp = `<span styles="${formatter.styles.objectKey}">type: </span>`;
		const typeValue = `<span styles="${formatter.styles.string}">${token.contentType}</span>`;
		return `<span class="dumper-blob" style="${styles}">[Blob]` + propertiesStart + `${sizeProp}${sizeValue} ${typeProp}${typeValue}` + propertiesEnd + "</span>";
	},
	"promise": function(token, formatter) {
		return `<span class="dumper-promise" style="${formatter.styles.promiseLabel}">[Promise${htmlEscape(`<${token.isFulfilled ? "resolved" : "pending"}>`)}]</span>`;
	},
	"generator": function(token, formatter) {
		const styles = formatter.styles.generatorLabel;
		const label = token.isAsync ? "[AsyncGenerator] {}" : "[Generator] {}";
		return `<span class="dumper-generator" style="${styles}">` + label + "</span>";
	},
	"static-members-start": function(_, formatter) {
		formatter.context.isStaticMember = true;
		formatter.context.staticDepth = 0;
		return "";
	},
	"static-members-end": function(_, formatter) {
		formatter.context.isStaticMember = false;
		formatter.context.staticDepth = 0;
		return "";
	}
};
var seed = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var nanoid = (length = 15) => {
	let output = "";
	let random = new Uint8Array(length);
	if (globalThis.crypto) crypto.getRandomValues(random);
	else for (let i = 0; i < length; i++) random[i] = Math.floor(Math.random() * 256);
	for (let n = 0; n < length; n++) output += seed[63 & random[n]];
	return output;
};
var HTMLFormatter = class {
	#config;
	/**
	* Styles for output elements
	*/
	styles;
	/**
	* Context maintained through out the printing
	* phase. Each instance has its own context
	* that gets mutated internally.
	*/
	context;
	/**
	* Value for the newline character
	*/
	newLine = "\n";
	/**
	* Utility to manage indentation
	*/
	indentation = {
		counter: 0,
		increment() {
			this.counter++;
		},
		decrement() {
			this.counter--;
		},
		getSpaces() {
			return new Array(this.counter * 2 + 1).join("&nbsp;");
		}
	};
	constructor(config, context) {
		this.context = context || {};
		this.#config = config || {};
		this.styles = Object.freeze({
			...themes$1.nightOwl,
			...config?.styles
		});
	}
	/**
	* Wraps the final output inside pre tags and add the script
	* to activate the frontend iteractions.
	*/
	#wrapOutput(code) {
		const id = `dump-${nanoid()}`;
		const expand = this.#config.expand === "all" ? `'all'` : this.#config.expand;
		const nonce = this.#config.cspNonce ? ` nonce="${this.#config.cspNonce}"` : "";
		return `<div id="${id}" class="dumper-dump"><pre style="${this.styles.pre}"><code>${code}</code></pre><script${nonce}>dumperActivate('${id}', ${expand})<\/script></div>`;
	}
	/**
	* Format a collection of tokens to HTML output wrapped
	* inside the `pre` tag.
	*/
	format(tokens) {
		return this.#wrapOutput(tokens.map((token) => {
			const formatter = HTMLPrinters[token.type];
			return formatter(token, this) || "";
		}).join(""));
	}
};
function createStyleSheet() {
	return `.dumper-dump, .dumper-dump pre, .dumper-dump code, .dumper-dump samp {
  font-family: JetBrains Mono, monaspace argon, Menlo, Monaco, Consolas, monospace;
}
.dumper-dump pre {
  line-height: 24px;
  font-size: 15px;
  overflow-x: auto;
  position:relative;
  z-index:99999;
  padding: 10px 15px;
  margin: 0;
}
.dumper-dump pre samp {
  position: relative;
}
.dumper-dump pre samp[hidden="true"] {
  display: none;
}
.dumper-dump .dumper-prototype-group {
  opacity: 0.5;
}

.dumper-dump .dumper-toggle {
   transform: rotate(270deg);
}

.dumper-dump .dumper-toggle span {
  display: inline-block;
  position: relative;
  top: 1px;
  margin: 0 5px;
  font-size: 14px;
}
.dumper-dump .dumper-toggle[aria-expanded="true"] {
  transform: none;
}`;
}
function createScript() {
	return `function expandGroup(group) {
  const trigger = group.querySelector('button')
  trigger.setAttribute('aria-expanded', 'true')

  const samp = group.querySelector('samp')
  samp.removeAttribute('hidden')
}

function collapseGroup(group) {
  const trigger = group.querySelector('button')
  trigger.removeAttribute('aria-expanded', 'true')

  const samp = group.querySelector('samp')
  samp.setAttribute('hidden', 'true')
}

function dumperActivate(dumpId, expand) {
  if (expand === true) {
    expandGroup(document.querySelector(\`#\${dumpId} .dumper-group\`))
  } else if (expand === 'all') {
    document.querySelectorAll(\`#\${dumpId} .dumper-group\`).forEach((c) => expandGroup(c))
  }

  document.querySelectorAll(\`#\${dumpId} .dumper-toggle\`).forEach((trigger) => {
    trigger.addEventListener('click', function (event) {
      const target = event.currentTarget
      const parent = target.parentElement
      const isExpanded = !!target.getAttribute('aria-expanded')

      if (isExpanded) {
        collapseGroup(parent)
        if (event.metaKey) {
          parent.querySelectorAll('.dumper-group').forEach((c) => collapseGroup(c))
        }
      } else {
        expandGroup(parent)
        if (event.metaKey) {
          parent.querySelectorAll('.dumper-group').forEach((c) => expandGroup(c))
        }
      }
    })
  })
}`;
}
function dump$1(value, config) {
	const parser = new Parser(config);
	parser.parse(value);
	return new HTMLFormatter(config).format(parser.flush());
}

//#endregion
//#region ../../node_modules/.pnpm/@poppinss+dumper@0.6.5/node_modules/@poppinss/dumper/build/formatters/console/main.js
init_supports_color();
var colors = supportsColor.stdout ? colors_default.ansi() : colors_default.silent();
var themes = { default: {
	braces: (value) => colors.yellow(value),
	brackets: (value) => colors.yellow(value),
	number: (value) => colors.yellow(value),
	bigInt: (value) => colors.yellow().bold(value),
	boolean: (value) => colors.yellow().italic(value),
	string: (value) => colors.green(value),
	null: (value) => colors.dim(value),
	undefined: (value) => colors.dim(value),
	prototypeLabel: (value) => colors.dim(value),
	symbol: (value) => colors.magenta(value),
	regex: (value) => colors.red(value),
	date: (value) => colors.magenta(value),
	buffer: (value) => colors.magenta(value),
	functionLabel: (value) => colors.cyan().italic(value),
	arrayLabel: (value) => colors.cyan(value),
	objectLabel: (value) => colors.cyan(value),
	mapLabel: (value) => colors.cyan(value),
	setLabel: (value) => colors.cyan(value),
	objectKey: (value) => colors.blue(value),
	objectKeyPrefix: (value) => colors.dim(value),
	classLabel: (value) => colors.cyan(value),
	weakSetLabel: (value) => colors.cyan(value),
	weakRefLabel: (value) => colors.cyan(value),
	collapseLabel: (value) => colors.dim(value),
	circularLabel: (value) => colors.cyan(value),
	getterLabel: (value) => colors.cyan(value),
	weakMapLabel: (value) => colors.cyan(value),
	observableLabel: (value) => colors.cyan(value),
	promiseLabel: (value) => colors.blue(value),
	generatorLabel: (value) => colors.cyan(value),
	blobLabel: (value) => colors.magenta(value),
	unknownLabel: (value) => colors.magenta(value)
} };
function openingBrace(formatter) {
	return formatter.styles.braces("{");
}
function closingBrace(formatter) {
	return formatter.styles.braces("}");
}
function openingBrackets(formatter) {
	return formatter.styles.brackets("[");
}
function closingBrackets(formatter) {
	return formatter.styles.brackets("]");
}
var ConsolePrinters = {
	"collapse": (token, formatter) => {
		const styles = token.token.type === "object-start" ? formatter.styles.objectLabel : formatter.styles.arrayLabel;
		const collpaseStyles = formatter.styles.collapseLabel;
		return `${styles(token.name)} ` + (token.token.type === "object-start" ? openingBrace(formatter) : openingBrackets(formatter)) + ` ${collpaseStyles("collpased")} ` + (token.token.type === "object-start" ? closingBrace(formatter) : closingBrackets(formatter));
	},
	"object-start": (token, formatter) => {
		formatter.indentation.increment();
		const styles = formatter.styles.objectLabel;
		return (formatter.context.isStaticMember && formatter.context.staticDepth === 0 || token.constructorName === "Object" ? "" : styles(`${token.constructorName || "Object [null]"}`) + " ") + openingBrace(formatter);
	},
	"object-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}` + closingBrace(formatter);
	},
	"object-key": (token, formatter) => {
		formatter.context.isStack = token.value === "stack";
		const styles = formatter.styles.objectKey;
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		let value = token.value;
		if (token.isSymbol) value = `[${value}]`;
		let prefix = "";
		if (formatter.context.isStaticMember) {
			formatter.context.staticDepth++;
			if (formatter.context.staticDepth === 1) {
				const prefixStyles = formatter.styles.objectKeyPrefix;
				prefix = `${prefixStyles("static")} `;
			}
		}
		return indent + prefix + styles(value) + ": ";
	},
	"object-circular-ref": (_, formatter) => {
		const styles = formatter.styles.circularLabel;
		return styles("[*Circular]");
	},
	"object-max-depth-ref": (_, formatter) => {
		const styles = formatter.styles.objectLabel;
		return styles("[Object]");
	},
	"object-value-getter": (_, formatter) => {
		const styles = formatter.styles.getterLabel;
		return styles("[Getter]");
	},
	"object-value-start": () => {
		return "";
	},
	"object-value-end": (_, formatter) => {
		if (formatter.context.isStaticMember) formatter.context.staticDepth--;
		return `,`;
	},
	"array-start": (token, formatter) => {
		formatter.indentation.increment();
		const styles = formatter.styles.arrayLabel;
		return (token.name !== "Array" ? styles(`${token.name}`) + " " : "") + openingBrackets(formatter);
	},
	"array-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}` + closingBrackets(formatter);
	},
	"array-value-start": (_, formatter) => {
		return `${formatter.newLine}${formatter.indentation.getSpaces()}`;
	},
	"array-value-hole": (_, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		const styles = formatter.styles.undefined;
		return indent + styles("<hole>") + ",";
	},
	"array-value-end": () => {
		return `,`;
	},
	"array-circular-ref": (_, formatter) => {
		const styles = formatter.styles.circularLabel;
		return styles("[*Circular]");
	},
	"array-max-depth-ref": (_, formatter) => {
		const styles = formatter.styles.arrayLabel;
		return styles("[Array]");
	},
	"array-max-length-ref": (token, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		const styles = formatter.styles.arrayLabel;
		const itemsLeft = token.size - token.limit;
		if (itemsLeft <= 0) return "";
		return indent + styles(`[...${itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`}]`);
	},
	"prototype-start": (_, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		formatter.indentation.increment();
		const styles = formatter.styles.prototypeLabel;
		return indent + styles("[[Prototype]] ") + openingBrace(formatter);
	},
	"prototype-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}` + closingBrace(formatter);
	},
	"map-start": (token, formatter) => {
		formatter.indentation.increment();
		const styles = formatter.styles.mapLabel;
		return styles(`Map(${token.size}) `) + openingBrace(formatter);
	},
	"map-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}` + closingBrace(formatter);
	},
	"map-row-start": (_, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		formatter.indentation.increment();
		return indent + openingBrackets(formatter);
	},
	"map-row-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}` + closingBrackets(formatter) + `,`;
	},
	"map-key-start": (_, formatter) => {
		const styles = formatter.styles.objectKey;
		return `${formatter.newLine}${formatter.indentation.getSpaces()}` + styles("key") + ": ";
	},
	"map-key-end": function() {
		return ",";
	},
	"map-value-start": (_, formatter) => {
		const styles = formatter.styles.objectKey;
		return `${formatter.newLine}${formatter.indentation.getSpaces()}` + styles("value") + ": ";
	},
	"map-value-end": function() {
		return ",";
	},
	"map-circular-ref": (_, formatter) => {
		const styles = formatter.styles.circularLabel;
		return styles("[*Circular]");
	},
	"map-max-depth-ref": (_, formatter) => {
		const styles = formatter.styles.mapLabel;
		return styles("[Map]");
	},
	"map-max-length-ref": (token, formatter) => {
		const styles = formatter.styles.mapLabel;
		const itemsLeft = token.size - token.limit;
		if (itemsLeft <= 0) return "";
		return styles(`[...${itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`}]`);
	},
	"set-start": (token, formatter) => {
		formatter.indentation.increment();
		const styles = formatter.styles.setLabel;
		return styles(`Set(${token.size}) `) + openingBrackets(formatter);
	},
	"set-end": (_, formatter) => {
		formatter.indentation.decrement();
		return `${formatter.newLine}${formatter.indentation.getSpaces()}` + closingBrackets(formatter);
	},
	"set-value-start": (_, formatter) => {
		return `${formatter.newLine}${formatter.indentation.getSpaces()}`;
	},
	"set-value-end": () => {
		return `,`;
	},
	"set-circular-ref": (_, formatter) => {
		const styles = formatter.styles.circularLabel;
		return styles("[*Circular]");
	},
	"set-max-depth-ref": (_, formatter) => {
		const styles = formatter.styles.setLabel;
		return styles("[Set]");
	},
	"set-max-length-ref": (token, formatter) => {
		const indent = `${formatter.newLine}${formatter.indentation.getSpaces()}`;
		const styles = formatter.styles.setLabel;
		const itemsLeft = token.size - token.limit;
		if (itemsLeft <= 0) return "";
		return indent + styles(`[...${itemsLeft === 1 ? `1 more item` : `${itemsLeft} more items`}]`);
	},
	"string": (token, formatter) => {
		let value = token.value;
		const indent = formatter.indentation.getSpaces();
		if (formatter.context.isStack) value = token.value.split("\n").map((row, index) => {
			let rowValue = row.trim();
			if (index > 0) rowValue = `${indent}${rowValue}`;
			return rowValue;
		}).join("\n");
		else value = wordWrap(token.value, {
			newLine: formatter.newLine,
			indent: formatter.indentation.getSpaces(),
			width: 70,
			escape: (line) => line
		});
		const styles = formatter.styles.string;
		return styles(value);
	},
	"boolean": (token, formatter) => {
		const styles = formatter.styles.boolean;
		return styles(String(token.value));
	},
	"number": (token, formatter) => {
		const styles = formatter.styles.number;
		return styles(String(token.value));
	},
	"bigInt": (token, formatter) => {
		const styles = formatter.styles.bigInt;
		return styles(token.value);
	},
	"undefined": (_, formatter) => {
		const styles = formatter.styles.undefined;
		return styles("undefined");
	},
	"null": (_, formatter) => {
		const styles = formatter.styles.null;
		return styles("null");
	},
	"symbol": (token, formatter) => {
		const styles = formatter.styles.symbol;
		return styles(token.value);
	},
	"function": (token, formatter) => {
		const styles = token.isClass ? formatter.styles.classLabel : formatter.styles.functionLabel;
		const async = token.isAsync ? `async ` : "";
		const generator = token.isGenerator ? `*` : "";
		return styles(token.isClass ? `[class ${token.name}]` : `[${async}${generator}function ${token.name}]`);
	},
	"date": function(token, formatter) {
		const styles = formatter.styles.date;
		return styles(token.value);
	},
	"buffer": function(token, formatter) {
		const styles = formatter.styles.buffer;
		return styles(token.value);
	},
	"regexp": function(token, formatter) {
		const styles = formatter.styles.regex;
		return styles(token.value);
	},
	"unknown": function(token, formatter) {
		const styles = formatter.styles.unknownLabel;
		return styles(String(token.value));
	},
	"weak-set": function(_, formatter) {
		const styles = formatter.styles.weakSetLabel;
		return styles("[WeakSet]");
	},
	"weak-ref": function(_, formatter) {
		const styles = formatter.styles.weakRefLabel;
		return styles("[WeakRef]");
	},
	"weak-map": function(_, formatter) {
		const styles = formatter.styles.weakMapLabel;
		return styles("[WeakMap]");
	},
	"observable": function(_, formatter) {
		const styles = formatter.styles.observableLabel;
		return styles("[Observable]");
	},
	"blob": function(token, formatter) {
		const styles = formatter.styles.objectLabel;
		const sizeProp = formatter.styles.objectKey("size: ");
		const sizeValue = formatter.styles.number(`${token.size}`);
		const typeProp = token.contentType ? `, ${formatter.styles.objectKey("type: ")}` : "";
		const typeValue = token.contentType ? formatter.styles.string(`${token.contentType}`) : "";
		return styles("[Blob]") + " " + openingBrace(formatter) + `${sizeProp}${sizeValue}${typeProp}${typeValue}` + closingBrace(formatter);
	},
	"promise": function(token, formatter) {
		const styles = formatter.styles.promiseLabel;
		return styles(`[Promise${`<${token.isFulfilled ? "resolved" : "pending"}>`}]`);
	},
	"generator": function(token, formatter) {
		const styles = formatter.styles.generatorLabel;
		return styles(token.isAsync ? "[AsyncGenerator] {}" : "[Generator] {}");
	},
	"static-members-start": function(_, formatter) {
		formatter.context.isStaticMember = true;
		formatter.context.staticDepth = 0;
		return " ";
	},
	"static-members-end": function(_, formatter) {
		formatter.context.isStaticMember = false;
		formatter.context.staticDepth = 0;
		return "";
	}
};
var ConsoleFormatter = class {
	/**
	* Styles for output elements
	*/
	styles;
	/**
	* Context maintained through out the printing
	* phase. Each instance has its own context
	* that gets mutated internally.
	*/
	context;
	/**
	* Value for the newline character
	*/
	newLine = "\n";
	/**
	* Utility to manage indentation
	*/
	indentation = {
		counter: 0,
		increment() {
			this.counter++;
		},
		decrement() {
			this.counter--;
		},
		getSpaces() {
			return new Array(this.counter * 2 + 1).join(" ");
		}
	};
	constructor(config, context) {
		this.context = context || {};
		this.styles = Object.freeze({
			...themes.default,
			...config?.styles
		});
	}
	/**
	* Format a collection of tokens to ANSI output
	*/
	format(tokens) {
		return tokens.map((token) => {
			const formatter = ConsolePrinters[token.type];
			return formatter(token, this) || "";
		}).join("");
	}
};
function dump(value, config) {
	const parser = new Parser(config);
	parser.parse(value);
	return new ConsoleFormatter(config).format(parser.flush());
}

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/chunk-X53OIOJH.js
var ErrorCause = class extends BaseComponent {
	cssFile = new URL("./error_cause/style.css", publicDirURL);
	/**
	* The toHTML method is used to output the HTML for the
	* web view
	*/
	async toHTML(props) {
		if (!props.error.cause) return "";
		return `<section>
      <div class="card">
        <div class="card-heading">
          <div>
            <h3 class="card-title">
              Error Cause
            </h3>
          </div>
        </div>
        <div class="card-body">
          <div id="error-cause">
            ${dump$1(props.error.cause, {
			cspNonce: props.cspNonce,
			styles: themes$1.cssVariables,
			inspectObjectPrototype: false,
			inspectStaticMembers: false,
			inspectArrayPrototype: false
		})}
          </div>
        </div>
      </div>
    </section>`;
	}
	/**
	* The toANSI method is used to output the text for the console
	*/
	async toANSI(props) {
		if (!props.error.cause) return "";
		let depth = process.env.YOUCH_CAUSE ? Number(process.env.YOUCH_CAUSE) : 2;
		if (Number.isNaN(depth)) depth = 2;
		return `

${colors$1.red("[CAUSE]")}
${dump(props.error.cause, {
			depth,
			inspectObjectPrototype: false,
			inspectStaticMembers: false,
			inspectArrayPrototype: false
		})}`;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/chunk-OIJ3WD7L.js
var ERROR_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="24" height="24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 7v6m0 4.01.01-.011M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10Z"/></svg>`;
var HINT_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="24" height="24" fill="none"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m21 2-1 1M3 2l1 1m17 13-1-1M3 16l1-1m5 3h6m-5 3h4M12 3C8 3 5.952 4.95 6 8c.023 1.487.5 2.5 1.5 3.5S9 13 9 15h6c0-2 .5-2.5 1.5-3.5h0c1-1 1.477-2.013 1.5-3.5.048-3.05-2-5-6-5Z"/></svg>`;
var COPY_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"  stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg>`;
function htmlAttributeEscape(value) {
	return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var ErrorInfo = class extends BaseComponent {
	cssFile = new URL("./error_info/style.css", publicDirURL);
	scriptFile = new URL("./error_info/script.js", publicDirURL);
	/**
	* The toHTML method is used to output the HTML for the
	* web view
	*/
	async toHTML(props) {
		return `<section>
      <h4 id="error-name">${props.error.name}</h4>
      <h1 id="error-title">${props.title}</h1>
    </section>
    <section>
      <div class="card">
        <div class="card-body">
          <h2 id="error-message">
            <span>${ERROR_ICON_SVG}</span>
            <span>${props.error.message}</span>
            <button
              id="copy-error-btn"
              data-error-text="${htmlAttributeEscape(`${props.error.name}: ${props.error.message}`)}"
              onclick="copyErrorMessage(this)"
              title="Copy error message"
              aria-label="Copy error message to clipboard"
            >
              ${COPY_ICON_SVG}
            </button>
          </h2>
          ${props.error.hint ? `<div id="error-hint">
                <span>${HINT_ICON_SVG}</span>
                <span>${props.error.hint}</span>
              </div>` : ""}
        </div>
      </div>
    </section>`;
	}
	/**
	* The toANSI method is used to output the text for the console
	*/
	async toANSI(props) {
		return `${colors$1.red(`\u2139 ${wordWrap$1(`${props.error.name}: ${props.error.message}`, {
			width: process.stdout.columns,
			indent: "  ",
			newLine: "\n",
			escape: (value) => value
		})}`)}${props.error.hint ? `

${colors$1.blue("◉")} ${colors$1.dim().italic(wordWrap$1(props.error.hint.replace(/(<([^>]+)>)/gi, ""), {
			width: process.stdout.columns,
			indent: "  ",
			newLine: "\n",
			escape: (value) => value
		}))}` : ""}`;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/chunk-P36L72PL.js
var ErrorMetadata = class extends BaseComponent {
	cssFile = new URL("./error_metadata/style.css", publicDirURL);
	#primitives = [
		"string",
		"boolean",
		"number",
		"undefined"
	];
	/**
	* Formats the error row value
	*/
	#formatRowValue(value, dumpValue, cspNonce) {
		if (dumpValue === true) return dump$1(value, {
			styles: themes$1.cssVariables,
			cspNonce
		});
		if (this.#primitives.includes(typeof value) || value === null) return value;
		return dump$1(value, {
			styles: themes$1.cssVariables,
			cspNonce
		});
	}
	/**
	* Returns HTML fragment with HTML table containing rows
	* metadata section rows
	*/
	#renderRows(rows, cspNonce) {
		return `<table class="card-table">
      <tbody>
        ${rows.map((row) => {
			return `<tr>
              <td class="table-key">${row.key}</td>
              <td class="table-value">
                ${this.#formatRowValue(row.value, row.dump, cspNonce)}
              </td>
            </tr>`;
		}).join("\n")}
      </tbody>
    </table>`;
	}
	/**
	* Renders each section with its rows inside a table
	*/
	#renderSection(section, rows, cspNonce) {
		return `<div>
      <h4 class="card-subtitle">${section}</h4>
      ${Array.isArray(rows) ? this.#renderRows(rows, cspNonce) : `<span>${this.#formatRowValue(rows.value, rows.dump, cspNonce)}</span>`}
    </div>`;
	}
	/**
	* Renders each group as a card
	*/
	#renderGroup(group, sections, cspNonce) {
		return `<section class="metadata-group">
      <div class="card">
        <div class="card-heading">
          <h3 class="card-title">${group}</h3>
        </div>
        <div class="card-body">
          ${Object.keys(sections).map((section) => this.#renderSection(section, sections[section], cspNonce)).join("\n")}
        </div>
      </div>
    </section>`;
	}
	/**
	* The toHTML method is used to output the HTML for the
	* web view
	*/
	async toHTML(props) {
		const groups = props.metadata.toJSON();
		const groupsNames = Object.keys(groups);
		if (!groupsNames.length) return "";
		return groupsNames.map((group) => this.#renderGroup(group, groups[group], props.cspNonce)).join("\n");
	}
	/**
	* The toANSI method is used to output the text for the console
	*/
	async toANSI() {
		return "";
	}
};

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/chunk-EJH674NB.js
var CHEVIRON = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2">
  <path d="M6 9l6 6l6 -6"></path>
</svg>`;
var EDITORS = {
	textmate: "txmt://open?url=file://%f&line=%l",
	macvim: "mvim://open?url=file://%f&line=%l",
	emacs: "emacs://open?url=file://%f&line=%l",
	sublime: "subl://open?url=file://%f&line=%l",
	phpstorm: "phpstorm://open?file=%f&line=%l",
	atom: "atom://core/open/file?filename=%f&line=%l",
	vscode: "vscode://file/%f:%l"
};
var ErrorStack = class extends BaseComponent {
	cssFile = new URL("./error_stack/style.css", publicDirURL);
	scriptFile = new URL("./error_stack/script.js", publicDirURL);
	/**
	* Returns the file's relative name from the CWD
	*/
	#getRelativeFileName(filePath) {
		return filePath.replace(`${process.cwd()}/`, "");
	}
	/**
	* Returns the index of the frame that should be expanded by
	* default
	*/
	#getFirstExpandedFrameIndex(frames) {
		let expandAtIndex = frames.findIndex((frame) => frame.type === "app");
		if (expandAtIndex === -1) expandAtIndex = frames.findIndex((frame) => frame.type === "module");
		return expandAtIndex;
	}
	/**
	* Returns the link to open the file within known code
	* editors
	*/
	#getEditorLink(ide, frame) {
		const editorURL = EDITORS[ide] || ide;
		if (!editorURL || frame.type === "native") return { text: this.#getRelativeFileName(frame.fileName) };
		return {
			href: editorURL.replace("%f", frame.fileName).replace("%l", String(frame.lineNumber)),
			text: this.#getRelativeFileName(frame.fileName)
		};
	}
	/**
	* Returns the HTML fragment for the frame location
	*/
	#renderFrameLocation(frame, ide) {
		const { text, href } = this.#getEditorLink(ide, frame);
		const fileName = `<a${href ? ` href="${href}"` : ""} class="stack-frame-filepath" title="${text}">
      ${htmlEscape$1(text)}
    </a>`;
		const functionName = frame.functionName ? `<span>in <code title="${frame.functionName}">
        ${htmlEscape$1(frame.functionName)}
      </code></span>` : "";
		const loc = `<span>at line <code>${frame.lineNumber}:${frame.columnNumber}</code></span>`;
		if (frame.type !== "native" && frame.source) return `<button class="stack-frame-location">
        ${fileName} ${functionName} ${loc}
      </button>`;
		return `<div class="stack-frame-location">
      ${fileName} ${functionName} ${loc}
    </div>`;
	}
	/**
	* Returns HTML fragment for the stack frame
	*/
	async #renderStackFrame(frame, index, expandAtIndex, props) {
		const label = frame.type === "app" ? "<span class=\"frame-label\">In App</span>" : "";
		const expandedClass = expandAtIndex === index ? " expanded" : "";
		const toggleButton = frame.type !== "native" && frame.source ? `<button class="stack-frame-toggle-indicator">${CHEVIRON}</button>` : "";
		return `<li class="stack-frame stack-frame-${frame.type}${expandedClass}">
      <div class="stack-frame-contents">
        ${this.#renderFrameLocation(frame, props.ide)}
        <div class="stack-frame-extras">
          ${label}
          ${toggleButton}
        </div>
      </div>
      <div class="stack-frame-source">
        ${await props.sourceCodeRenderer(props.error, frame)}
      </div>
    </li>`;
	}
	/**
	* Returns the ANSI output to print the stack frame on the
	* terminal
	*/
	async #printStackFrame(frame, index, expandAtIndex, props) {
		const loc = `${this.#getRelativeFileName(frame.fileName)}:${frame.lineNumber}:${frame.columnNumber}`;
		if (index === expandAtIndex) {
			const functionName2 = frame.functionName ? `at ${frame.functionName} ` : "";
			const codeSnippet = await props.sourceCodeRenderer(props.error, frame);
			return ` \u2043 ${functionName2}${colors$1.yellow(`(${loc})`)}${codeSnippet}`;
		}
		if (frame.type === "native") {
			const functionName2 = frame.functionName ? `at ${colors$1.italic(frame.functionName)} ` : "";
			return colors$1.dim(` \u2043 ${functionName2}(${colors$1.italic(loc)})`);
		}
		return ` \u2043 ${frame.functionName ? `at ${frame.functionName} ` : ""}${colors$1.yellow(`(${loc})`)}`;
	}
	/**
	* The toHTML method is used to output the HTML for the
	* web view
	*/
	async toHTML(props) {
		return `<section>
      <div class="card">
        <div class="card-heading">
          <div>
            <h3 class="card-title">
              Stack Trace
            </h3>
          </div>
        </div>
        <div class="card-body">
          <div id="stack-frames-wrapper">
            <div id="stack-frames-header">
              <div id="all-frames-toggle-wrapper">
                <label id="all-frames-toggle">
                  <input type="checkbox" />
                  <span> View All Frames </span>
                </label>
              </div>

              <div>
                <div class="toggle-switch">
                  <button id="formatted-frames-toggle" class="active"> Pretty </button>
                  <button id="raw-frames-toggle"> Raw </button>
                </div>
              </div>
            </div>

            <div id="stack-frames-body">
              <div id="stack-frames-formatted" class="visible">
                <ul id="stack-frames">
                  ${(await Promise.all(props.error.frames.map((frame, index) => {
			return this.#renderStackFrame(frame, index, this.#getFirstExpandedFrameIndex(props.error.frames), props);
		}))).join("\n")}
                </ul>
              </div>
              <div id="stack-frames-raw">
                ${dump$1(props.error.raw, {
			styles: themes$1.cssVariables,
			expand: true,
			cspNonce: props.cspNonce,
			inspectObjectPrototype: false,
			inspectStaticMembers: false,
			inspectArrayPrototype: false
		})}
              </div>
            </div>
          <div>
        </div>
      </div>
    </section>`;
	}
	/**
	* The toANSI method is used to output the text for the console
	*/
	async toANSI(props) {
		const displayRaw = process.env.YOUCH_RAW;
		if (displayRaw) {
			const depth = Number.isNaN(Number(displayRaw)) ? 2 : Number(displayRaw);
			return `

${colors$1.red("[RAW]")}
${dump(props.error.raw, {
				depth,
				inspectObjectPrototype: false,
				inspectStaticMembers: false,
				inspectArrayPrototype: false
			})}`;
		}
		const frames = await Promise.all(props.error.frames.map((frame, index) => {
			return this.#printStackFrame(frame, index, this.#getFirstExpandedFrameIndex(props.error.frames), props);
		}));
		if (frames.length) return `

${frames.join("\n")}`;
		return "";
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@speed-highlight+core@1.2.14/node_modules/@speed-highlight/core/dist/index.js
var Xt$1 = Object.defineProperty;
var w$1 = (t) => (e) => {
	var s = t[e];
	if (s) return s();
	throw new Error("Module not found in bundle: " + e);
};
var a$1 = (t, e) => () => (t && (e = t(t = 0)), e);
var p$1 = (t, e) => {
	for (var s in e) Xt$1(t, s, {
		get: e[s],
		enumerable: !0
	});
};
var P$1 = {};
p$1(P$1, { default: () => Wt$1 });
var Wt$1, F$1 = a$1(() => {
	Wt$1 = [
		{
			type: "cmnt",
			match: /(;|#).*/gm
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "num",
			match: /\$[\da-fA-F]*\b/g
		},
		{
			type: "kwd",
			match: /^[a-z]+\s+[a-z.]+\b/gm,
			sub: [{
				type: "func",
				match: /^[a-z]+/g
			}]
		},
		{
			type: "kwd",
			match: /^\t*[a-z][a-z\d]*\b/gm
		},
		{
			match: /%|\$/g,
			type: "oper"
		}
	];
});
var $$1 = {};
p$1($$1, { default: () => T });
var M$1, T, f = a$1(() => {
	M$1 = {
		type: "var",
		match: /\$\w+|\${[^}]*}|\$\([^)]*\)/g
	}, T = [
		{
			sub: "todo",
			match: /#.*/g
		},
		{
			type: "str",
			match: /(["'])((?!\1)[^\r\n\\]|\\[^])*\1?/g,
			sub: [M$1]
		},
		{
			type: "oper",
			match: /(?<=\s|^)\.*\/[a-z/_.-]+/gi
		},
		{
			type: "kwd",
			match: /\s-[a-zA-Z]+|$<|[&|;]+|\b(unset|readonly|shift|export|if|fi|else|elif|while|do|done|for|until|case|esac|break|continue|exit|return|trap|wait|eval|exec|then|declare|enable|local|select|typeset|time|add|remove|install|update|delete)(?=\s|$)/g
		},
		{ expand: "num" },
		{
			type: "func",
			match: /(?<=(^|\||\&\&|\;)\s*)[a-z_.-]+(?=\s|$)/gim
		},
		{
			type: "bool",
			match: /(?<=\s|^)(true|false)(?=\s|$)/g
		},
		{
			type: "oper",
			match: /[=(){}<>!]+/g
		},
		{
			type: "var",
			match: /(?<=\s|^)[\w_]+(?=\s*=)/g
		},
		M$1
	];
});
var v$1 = {};
p$1(v$1, { default: () => jt$1 });
var jt$1, B$1 = a$1(() => {
	jt$1 = [
		{
			match: /[^\[\->+.<\]\s].*/g,
			sub: "todo"
		},
		{
			type: "func",
			match: /\.+/g
		},
		{
			type: "kwd",
			match: /[<>]+/g
		},
		{
			type: "oper",
			match: /[+-]+/g
		}
	];
});
var G$1 = {};
p$1(G$1, { default: () => Kt$1 });
var Kt$1, H$1 = a$1(() => {
	Kt$1 = [
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "kwd",
			match: /#\s*include (<.*>|".*")/g,
			sub: [{
				type: "str",
				match: /(<|").*/g
			}]
		},
		{
			match: /asm\s*{[^}]*}/g,
			sub: [{
				type: "kwd",
				match: /^asm/g
			}, {
				match: /[^{}]*(?=}$)/g,
				sub: "asm"
			}]
		},
		{
			type: "kwd",
			match: /\*|&|#[a-z]+\b|\b(asm|auto|double|int|struct|break|else|long|switch|case|enum|register|typedef|char|extern|return|union|const|float|short|unsigned|continue|for|signed|void|default|goto|sizeof|volatile|do|if|static|while)\b/g
		},
		{
			type: "oper",
			match: /[/*+:?&|%^~=!,<>.^-]+/g
		},
		{
			type: "func",
			match: /[a-zA-Z_][\w_]*(?=\s*\()/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		}
	];
});
var k$1 = {};
p$1(k$1, { default: () => Vt$1 });
var Vt$1, z$1 = a$1(() => {
	Vt$1 = [
		{
			match: /\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "kwd",
			match: /@\w+\b|\b(and|not|only|or)\b|\b[a-z-]+(?=[^{}]*{)/g
		},
		{
			type: "var",
			match: /\b[\w-]+(?=\s*:)|(::?|\.)[\w-]+(?=[^{}]*{)/g
		},
		{
			type: "func",
			match: /#[\w-]+(?=[^{}]*{)/g
		},
		{
			type: "num",
			match: /#[\da-f]{3,8}/g
		},
		{
			type: "num",
			match: /\d+(\.\d+)?(cm|mm|in|px|pt|pc|em|ex|ch|rem|vm|vh|vmin|vmax|%)?/g,
			sub: [{
				type: "var",
				match: /[a-z]+|%/g
			}]
		},
		{
			match: /url\([^)]*\)/g,
			sub: [{
				type: "func",
				match: /url(?=\()/g
			}, {
				type: "str",
				match: /[^()]+/g
			}]
		},
		{
			type: "func",
			match: /\b[a-zA-Z]\w*(?=\s*\()/g
		},
		{
			type: "num",
			match: /\b[a-z-]+\b/g
		}
	];
});
var _$1 = {};
p$1(_$1, { default: () => qt$1 });
var qt$1, Y$1 = a$1(() => {
	qt$1 = [{ expand: "strDouble" }, {
		type: "oper",
		match: /,/g
	}];
});
var Z$1 = {};
p$1(Z$1, { default: () => I$1 });
var I$1, N$1 = a$1(() => {
	I$1 = [
		{
			type: "deleted",
			match: /^[-<].*/gm
		},
		{
			type: "insert",
			match: /^[+>].*/gm
		},
		{
			type: "kwd",
			match: /!.*/gm
		},
		{
			type: "section",
			match: /^@@.*@@$|^\d.*|^([*-+])\1\1.*/gm
		}
	];
});
var X$1 = {};
p$1(X$1, { default: () => Qt$1 });
var Qt$1, W$1 = a$1(() => {
	f();
	Qt$1 = [{
		type: "kwd",
		match: /^(FROM|RUN|CMD|LABEL|MAINTAINER|EXPOSE|ENV|ADD|COPY|ENTRYPOINT|VOLUME|USER|WORKDIR|ARG|ONBUILD|STOPSIGNAL|HEALTHCHECK|SHELL)\b/gim
	}, ...T];
});
var j$1 = {};
p$1(j$1, { default: () => Jt$1 });
var Jt$1, K$1 = a$1(() => {
	N$1();
	Jt$1 = [
		{
			match: /^#.*/gm,
			sub: "todo"
		},
		{ expand: "str" },
		...I$1,
		{
			type: "func",
			match: /^(\$ )?git(\s.*)?$/gm
		},
		{
			type: "kwd",
			match: /^commit \w+$/gm
		}
	];
});
var V$1 = {};
p$1(V$1, { default: () => te$1 });
var te$1, q$1 = a$1(() => {
	te$1 = [
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "kwd",
			match: /\*|&|\b(break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go|goto|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/g
		},
		{
			type: "func",
			match: /[a-zA-Z_][\w_]*(?=\s*\()/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		},
		{
			type: "oper",
			match: /[+\-*\/%&|^~=!<>.^-]+/g
		}
	];
});
var J$1 = {};
p$1(J$1, {
	default: () => A$1,
	name: () => E$1,
	properties: () => l$1,
	xmlElement: () => o
});
var Q$1, ee$1, E$1, l$1, o, A$1, R$1 = a$1(() => {
	Q$1 = ":A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�", ee$1 = Q$1 + "\\-\\.0-9·̀-ͯ‿-⁀", E$1 = `[${Q$1}][${ee$1}]*`, l$1 = `\\s*(\\s+${E$1}\\s*(=\\s*([^"']\\S*|("|')(\\\\[^]|(?!\\4)[^])*\\4?)?)?\\s*)*`, o = {
		match: RegExp(`<[/!?]?${E$1}${l$1}[/!?]?>`, "g"),
		sub: [
			{
				type: "var",
				match: RegExp(`^<[/!?]?${E$1}`, "g"),
				sub: [{
					type: "oper",
					match: /^<[\/!?]?/g
				}]
			},
			{
				type: "str",
				match: /=\s*([^"']\S*|("|')(\\[^]|(?!\2)[^])*\2?)/g,
				sub: [{
					type: "oper",
					match: /^=/g
				}]
			},
			{
				type: "oper",
				match: /[\/!?]?>/g
			},
			{
				type: "class",
				match: RegExp(E$1, "g")
			}
		]
	}, A$1 = [
		{
			match: /<!--((?!-->)[^])*-->/g,
			sub: "todo"
		},
		{
			type: "class",
			match: /<!\[CDATA\[[\s\S]*?\]\]>/gi
		},
		o,
		{
			type: "str",
			match: RegExp(`<\\?${E$1}([^?]|\\?[^?>])*\\?+>`, "g"),
			sub: [{
				type: "var",
				match: RegExp(`^<\\?${E$1}`, "g"),
				sub: [{
					type: "oper",
					match: /^<\?/g
				}]
			}, {
				type: "oper",
				match: /\?+>$/g
			}]
		},
		{
			type: "var",
			match: /&(#x?)?[\da-z]{1,8};/gi
		}
	];
});
var tt$1 = {};
p$1(tt$1, { default: () => ae$1 });
var ae$1, et$1 = a$1(() => {
	R$1();
	ae$1 = [
		{
			type: "class",
			match: /<!DOCTYPE("[^"]*"|'[^']*'|[^"'>])*>/gi,
			sub: [
				{
					type: "str",
					match: /"[^"]*"|'[^']*'/g
				},
				{
					type: "oper",
					match: /^<!|>$/g
				},
				{
					type: "var",
					match: /DOCTYPE/gi
				}
			]
		},
		{
			match: RegExp(`<style${l$1}>((?!</style>)[^])*</style\\s*>`, "g"),
			sub: [
				{
					match: RegExp(`^<style${l$1}>`, "g"),
					sub: o.sub
				},
				{
					match: RegExp(`${o.match}|[^]*(?=</style\\s*>$)`, "g"),
					sub: "css"
				},
				o
			]
		},
		{
			match: RegExp(`<script${l$1}>((?!<\/script>)[^])*<\/script\\s*>`, "g"),
			sub: [
				{
					match: RegExp(`^<script${l$1}>`, "g"),
					sub: o.sub
				},
				{
					match: RegExp(`${o.match}|[^]*(?=<\/script\\s*>$)`, "g"),
					sub: "js"
				},
				o
			]
		},
		...A$1
	];
});
var pe$1, u$1, d$1 = a$1(() => {
	pe$1 = [
		[
			"bash",
			[/#!(\/usr)?\/bin\/bash/g, 500],
			[/\b(if|elif|then|fi|echo)\b|\$/g, 10]
		],
		[
			"html",
			[/<\/?[a-z-]+[^\n>]*>/g, 10],
			[/^\s+<!DOCTYPE\s+html/g, 500]
		],
		["http", [/^(GET|HEAD|POST|PUT|DELETE|PATCH|HTTP)\b/g, 500]],
		["js", [/\b(console|await|async|function|export|import|this|class|for|let|const|map|join|require)\b/g, 10]],
		["ts", [/\b(console|await|async|function|export|import|this|class|for|let|const|map|join|require|implements|interface|namespace)\b/g, 10]],
		["py", [/\b(def|print|class|and|or|lambda)\b/g, 10]],
		["sql", [/\b(SELECT|INSERT|FROM)\b/g, 50]],
		[
			"pl",
			[/#!(\/usr)?\/bin\/perl/g, 500],
			[/\b(use|print)\b|\$/g, 10]
		],
		["lua", [/#!(\/usr)?\/bin\/lua/g, 500]],
		["make", [/\b(ifneq|endif|if|elif|then|fi|echo|.PHONY|^[a-z]+ ?:$)\b|\$/gm, 10]],
		["uri", [/https?:|mailto:|tel:|ftp:/g, 30]],
		["css", [/^(@import|@page|@media|(\.|#)[a-z]+)/gm, 20]],
		[
			"diff",
			[/^[+><-]/gm, 10],
			[/^@@ ?[-+,0-9 ]+ ?@@/gm, 25]
		],
		[
			"md",
			[/^(>|\t\*|\t\d+.)/gm, 10],
			[/\[.*\](.*)/g, 10]
		],
		["docker", [/^(FROM|ENTRYPOINT|RUN)/gm, 500]],
		[
			"xml",
			[/<\/?[a-z-]+[^\n>]*>/g, 10],
			[/^<\?xml/g, 500]
		],
		["c", [/#include\b|\bprintf\s+\(/g, 100]],
		["rs", [/^\s+(use|fn|mut|match)\b/gm, 100]],
		["go", [/\b(func|fmt|package)\b/g, 100]],
		["java", [/^import\s+java/gm, 500]],
		["asm", [/^(section|global main|extern|\t(call|mov|ret))/gm, 100]],
		["css", [/^(@import|@page|@media|(\.|#)[a-z]+)/gm, 20]],
		["json", [/\b(true|false|null|\{})\b|\"[^"]+\":/g, 10]],
		["yaml", [/^(\s+)?[a-z][a-z0-9]*:/gim, 10]]
	], u$1 = (t) => pe$1.map(([e, ...s]) => [e, s.reduce((c, [m, n]) => c + [...t.matchAll(m)].length * n, 0)]).filter(([e, s]) => s > 20).sort((e, s) => s[1] - e[1])[0]?.[0] || "plain";
});
var at$1 = {};
p$1(at$1, { default: () => se$1 });
var se$1, pt$1 = a$1(() => {
	d$1();
	se$1 = [
		{
			type: "kwd",
			match: /^(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|PRI|SEARCH)\b/gm
		},
		{ expand: "str" },
		{
			type: "section",
			match: /\bHTTP\/[\d.]+\b/g
		},
		{ expand: "num" },
		{
			type: "oper",
			match: /[,;:=]/g
		},
		{
			type: "var",
			match: /[a-zA-Z][\w-]*(?=:)/g
		},
		{
			match: /\n\n[^]*/g,
			sub: u$1
		}
	];
});
var st$1 = {};
p$1(st$1, { default: () => ce$1 });
var ce$1, ct$1 = a$1(() => {
	ce$1 = [
		{
			match: /(^[ \f\t\v]*)[#;].*/gm,
			sub: "todo"
		},
		{
			type: "str",
			match: /.*/g
		},
		{
			type: "var",
			match: /.*(?==)/g
		},
		{
			type: "section",
			match: /^\s*\[.+\]\s*$/gm
		},
		{
			type: "oper",
			match: /=/g
		}
	];
});
var nt$1 = {};
p$1(nt$1, { default: () => ne$1 });
var ne$1, mt$1 = a$1(() => {
	ne$1 = [
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "kwd",
			match: /\b(abstract|assert|boolean|break|byte|case|catch|char|class|continue|const|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|package|private|protected|public|requires|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|transient|try|var|void|volatile|while)\b/g
		},
		{
			type: "oper",
			match: /[/*+:?&|%^~=!,<>.^-]+/g
		},
		{
			type: "func",
			match: /[a-zA-Z_][\w_]*(?=\s*\()/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		}
	];
});
var rt$1 = {};
p$1(rt$1, { default: () => O$1 });
var O$1, L$1 = a$1(() => {
	O$1 = [
		{
			match: /\/\*\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "jsdoc"
		},
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			match: /`((?!`)[^]|\\[^])*`?/g,
			sub: "js_template_literals"
		},
		{
			type: "kwd",
			match: /=>|\b(this|set|get|as|async|await|break|case|catch|class|const|constructor|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|if|implements|import|in|instanceof|interface|let|var|of|new|package|private|protected|public|return|static|super|switch|throw|throws|try|typeof|void|while|with|yield)\b/g
		},
		{
			match: /\/((?!\/)[^\r\n\\]|\\.)+\/[dgimsuy]*/g,
			sub: "regex"
		},
		{ expand: "num" },
		{
			type: "num",
			match: /\b(NaN|null|undefined|[A-Z][A-Z_]*)\b/g
		},
		{
			type: "bool",
			match: /\b(true|false)\b/g
		},
		{
			type: "oper",
			match: /[/*+:?&|%^~=!,<>.^-]+/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		},
		{
			type: "func",
			match: /[a-zA-Z$_][\w$_]*(?=\s*((\?\.)?\s*\(|=\s*(\(?[\w,{}\[\])]+\)? =>|function\b)))/g
		}
	];
});
var ot$1 = {};
p$1(ot$1, {
	default: () => me$1,
	type: () => re$1
});
var me$1, re$1, Et$1 = a$1(() => {
	me$1 = [{
		match: new class {
			exec(t) {
				let e = this.lastIndex, s, c = (m) => {
					for (; ++e < t.length - 2;) if (t[e] == "{") c();
					else if (t[e] == "}") return;
				};
				for (; e < t.length; ++e) if (t[e - 1] != "\\" && t[e] == "$" && t[e + 1] == "{") return s = e++, c(e), this.lastIndex = e + 1, {
					index: s,
					0: t.slice(s, e + 1)
				};
				return null;
			}
		}(),
		sub: [{
			type: "kwd",
			match: /^\${|}$/g
		}, {
			match: /(?!^\$|{)[^]+(?=}$)/g,
			sub: "js"
		}]
	}], re$1 = "str";
});
var lt$1 = {};
p$1(lt$1, {
	default: () => x$1,
	type: () => oe$1
});
var x$1, oe$1, S$1 = a$1(() => {
	x$1 = [
		{
			type: "err",
			match: /\b(TODO|FIXME|DEBUG|OPTIMIZE|WARNING|XXX|BUG)\b/g
		},
		{
			type: "class",
			match: /\bIDEA\b/g
		},
		{
			type: "insert",
			match: /\b(CHANGED|FIX|CHANGE)\b/g
		},
		{
			type: "oper",
			match: /\bQUESTION\b/g
		}
	], oe$1 = "cmnt";
});
var ut$1 = {};
p$1(ut$1, {
	default: () => Ee$1,
	type: () => le$1
});
var Ee$1, le$1, ht$1 = a$1(() => {
	S$1();
	Ee$1 = [
		{
			type: "kwd",
			match: /@\w+/g
		},
		{
			type: "class",
			match: /{[\w\s|<>,.@\[\]]+}/g
		},
		{
			type: "var",
			match: /\[[\w\s="']+\]/g
		},
		...x$1
	], le$1 = "cmnt";
});
var it$1 = {};
p$1(it$1, { default: () => ue$1 });
var ue$1, gt$1 = a$1(() => {
	ue$1 = [
		{
			type: "var",
			match: /(("|')((?!\2)[^\r\n\\]|\\[^])*\2|[a-zA-Z]\w*)(?=\s*:)/g
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "num",
			match: /\bnull\b/g
		},
		{
			type: "bool",
			match: /\b(true|false)\b/g
		}
	];
});
var dt$1 = {};
p$1(dt$1, { default: () => C$1 });
var C$1, D$1 = a$1(() => {
	d$1();
	C$1 = [
		{
			type: "cmnt",
			match: /^>.*|(=|-)\1+/gm
		},
		{
			type: "class",
			match: /\*\*((?!\*\*).)*\*\*/g
		},
		{
			match: /```((?!```)[^])*\n```/g,
			sub: (t) => ({
				type: "kwd",
				sub: [{
					match: /\n[^]*(?=```)/g,
					sub: t.split(`
`)[0].slice(3) || u$1(t)
				}]
			})
		},
		{
			type: "str",
			match: /`[^`]*`/g
		},
		{
			type: "var",
			match: /~~((?!~~).)*~~/g
		},
		{
			type: "kwd",
			match: /\b_\S([^\n]*?\S)?_\b|\*\S([^\n]*?\S)?\*/g
		},
		{
			type: "kwd",
			match: /^\s*(\*|\d+\.)\s/gm
		},
		{
			type: "func",
			match: /\[[^\]]*]\([^)]*\)|<[^>]*>/g,
			sub: [{
				type: "oper",
				match: /^\[[^\]]*]/g
			}]
		}
	];
});
var bt$1 = {};
p$1(bt$1, { default: () => he$1 });
var he$1, yt$1 = a$1(() => {
	D$1();
	d$1();
	he$1 = [
		{
			type: "insert",
			match: /(leanpub-start-insert)((?!leanpub-end-insert)[^])*(leanpub-end-insert)?/g,
			sub: [{
				type: "insert",
				match: /leanpub-(start|end)-insert/g
			}, {
				match: /(?!leanpub-start-insert)((?!leanpub-end-insert)[^])*/g,
				sub: u$1
			}]
		},
		{
			type: "deleted",
			match: /(leanpub-start-delete)((?!leanpub-end-delete)[^])*(leanpub-end-delete)?/g,
			sub: [{
				type: "deleted",
				match: /leanpub-(start|end)-delete/g
			}, {
				match: /(?!leanpub-start-delete)((?!leanpub-end-delete)[^])*/g,
				sub: u$1
			}]
		},
		...C$1
	];
});
var Tt$1 = {};
p$1(Tt$1, { default: () => ie$1 });
var ie$1, ft$1 = a$1(() => {
	ie$1 = [
		{
			type: "cmnt",
			match: /^#.*/gm
		},
		{ expand: "strDouble" },
		{ expand: "num" },
		{
			type: "err",
			match: /\b(err(or)?|[a-z_-]*exception|warn|warning|failed|ko|invalid|not ?found|alert|fatal)\b/gi
		},
		{
			type: "num",
			match: /\b(null|undefined)\b/gi
		},
		{
			type: "bool",
			match: /\b(false|true|yes|no)\b/gi
		},
		{
			type: "oper",
			match: /\.|,/g
		}
	];
});
var It$1 = {};
p$1(It$1, { default: () => ge$1 });
var ge$1, Nt$1 = a$1(() => {
	ge$1 = [
		{
			match: /^#!.*|--(\[(=*)\[((?!--\]\2\])[^])*--\]\2\]|.*)/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "kwd",
			match: /\b(and|break|do|else|elseif|end|for|function|if|in|local|not|or|repeat|return|then|until|while)\b/g
		},
		{
			type: "bool",
			match: /\b(true|false|nil)\b/g
		},
		{
			type: "oper",
			match: /[+*/%^#=~<>:,.-]+/g
		},
		{ expand: "num" },
		{
			type: "func",
			match: /[a-z_]+(?=\s*[({])/g
		}
	];
});
var At$1 = {};
p$1(At$1, { default: () => de$1 });
var de$1, Rt$1 = a$1(() => {
	de$1 = [
		{
			match: /^\s*#.*/gm,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "oper",
			match: /[${}()]+/g
		},
		{
			type: "class",
			match: /.PHONY:/gm
		},
		{
			type: "section",
			match: /^[\w.]+:/gm
		},
		{
			type: "kwd",
			match: /\b(ifneq|endif)\b/g
		},
		{ expand: "num" },
		{
			type: "var",
			match: /[A-Z_]+(?=\s*=)/g
		},
		{
			match: /^.*$/gm,
			sub: "bash"
		}
	];
});
var Ot$1 = {};
p$1(Ot$1, { default: () => be$1 });
var be$1, Lt$1 = a$1(() => {
	be$1 = [
		{
			match: /#.*/g,
			sub: "todo"
		},
		{
			type: "str",
			match: /(["'])(\\[^]|(?!\1)[^])*\1?/g
		},
		{ expand: "num" },
		{
			type: "kwd",
			match: /\b(any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while|not|and|or|xor)\b/g
		},
		{
			type: "oper",
			match: /[-+*/%~!&<>|=?,]+/g
		},
		{
			type: "func",
			match: /[a-z_]+(?=\s*\()/g
		}
	];
});
var xt$1 = {};
p$1(xt$1, { default: () => ye$1 });
var ye$1, St$1 = a$1(() => {
	ye$1 = [{ expand: "strDouble" }];
});
var Ct$1 = {};
p$1(Ct$1, { default: () => Te$1 });
var Te$1, Dt$1 = a$1(() => {
	Te$1 = [
		{
			match: /#.*/g,
			sub: "todo"
		},
		{
			type: "str",
			match: /f("""|''')(\\[^]|(?!\1)[^])*\1?|f("|')(\\[^]|(?!\3).)*\3?/gi,
			sub: [{
				type: "var",
				match: /{[^{}]*}/g,
				sub: [{
					match: /(?!^{)[^]*(?=}$)/g,
					sub: "py"
				}]
			}]
		},
		{
			match: /("""|''')(\\[^]|(?!\1)[^])*\1?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "kwd",
			match: /\b(and|as|assert|break|class|continue|def|del|elif|else|except|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|raise|return|try|while|with|yield)\b/g
		},
		{
			type: "bool",
			match: /\b(False|True|None)\b/g
		},
		{ expand: "num" },
		{
			type: "func",
			match: /[a-z_]\w*(?=\s*\()/gi
		},
		{
			type: "oper",
			match: /[-/*+<>,=!&|^%]+/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		}
	];
});
var wt$1 = {};
p$1(wt$1, {
	default: () => fe$1,
	type: () => Ie$1
});
var fe$1, Ie$1, Ut$1 = a$1(() => {
	fe$1 = [
		{
			match: /^(?!\/).*/gm,
			sub: "todo"
		},
		{
			type: "num",
			match: /\[((?!\])[^\\]|\\.)*\]/g
		},
		{
			type: "kwd",
			match: /\||\^|\$|\\.|\w+($|\r|\n)/g
		},
		{
			type: "var",
			match: /\*|\+|\{\d+,\d+\}/g
		}
	], Ie$1 = "oper";
});
var Pt$1 = {};
p$1(Pt$1, { default: () => Ne$1 });
var Ne$1, Ft$1 = a$1(() => {
	Ne$1 = [
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "kwd",
			match: /\b(as|break|const|continue|crate|else|enum|extern|false|fn|for|if|impl|in|let|loop|match|mod|move|mut|pub|ref|return|self|Self|static|struct|super|trait|true|type|unsafe|use|where|while|async|await|dyn|abstract|become|box|do|final|macro|override|priv|typeof|unsized|virtual|yield|try)\b/g
		},
		{
			type: "oper",
			match: /[/*+:?&|%^~=!,<>.^-]+/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		},
		{
			type: "func",
			match: /[a-zA-Z_][\w_]*(?=\s*!?\s*\()/g
		}
	];
});
var Mt$1 = {};
p$1(Mt$1, { default: () => Ae$1 });
var Ae$1, $t$1 = a$1(() => {
	Ae$1 = [
		{
			match: /--.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "func",
			match: /\b(AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/g
		},
		{
			type: "kwd",
			match: /\b(ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|kwdS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:S|ING)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/g
		},
		{
			type: "num",
			match: /\.?\d[\d.oxa-fA-F-]*|\bNULL\b/g
		},
		{
			type: "bool",
			match: /\b(TRUE|FALSE)\b/g
		},
		{
			type: "oper",
			match: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|IN|ILIKE|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/g
		},
		{
			type: "var",
			match: /@\S+/g
		}
	];
});
var vt$1 = {};
p$1(vt$1, { default: () => Re$1 });
var Re$1, Bt$1 = a$1(() => {
	Re$1 = [
		{
			match: /#.*/g,
			sub: "todo"
		},
		{
			type: "str",
			match: /("""|''')((?!\1)[^]|\\[^])*\1?/g
		},
		{ expand: "str" },
		{
			type: "section",
			match: /^\[.+\]\s*$/gm
		},
		{
			type: "num",
			match: /\b(inf|nan)\b|\d[\d:ZT.-]*/g
		},
		{ expand: "num" },
		{
			type: "bool",
			match: /\b(true|false)\b/g
		},
		{
			type: "oper",
			match: /[+,.=-]/g
		},
		{
			type: "var",
			match: /\w+(?= \=)/g
		}
	];
});
var Gt$1 = {};
p$1(Gt$1, { default: () => Oe$1 });
var Oe$1, Ht$1 = a$1(() => {
	L$1();
	Oe$1 = [
		{
			type: "type",
			match: /:\s*(any|void|number|boolean|string|object|never|enum)\b/g
		},
		{
			type: "kwd",
			match: /\b(type|namespace|typedef|interface|public|private|protected|implements|declare|abstract|readonly)\b/g
		},
		...O$1
	];
});
var kt$1 = {};
p$1(kt$1, { default: () => Le$1 });
var Le$1, zt$1 = a$1(() => {
	Le$1 = [
		{
			match: /^#.*/gm,
			sub: "todo"
		},
		{
			type: "class",
			match: /^\w+(?=:?)/gm
		},
		{
			type: "num",
			match: /:\d+/g
		},
		{
			type: "oper",
			match: /[:/&?]|\w+=/g
		},
		{
			type: "func",
			match: /[.\w]+@|#[\w]+$/gm
		},
		{
			type: "var",
			match: /\w+\.\w+(\.\w+)*/g
		}
	];
});
var _t$1 = {};
p$1(_t$1, { default: () => xe$1 });
var xe$1, Yt$1 = a$1(() => {
	xe$1 = [
		{
			match: /#.*/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "str",
			match: /(>|\|)\r?\n((\s[^\n]*)?(\r?\n|$))*/g
		},
		{
			type: "type",
			match: /!![a-z]+/g
		},
		{
			type: "bool",
			match: /\b(Yes|No)\b/g
		},
		{
			type: "oper",
			match: /[+:-]/g
		},
		{ expand: "num" },
		{
			type: "var",
			match: /[a-zA-Z]\w*(?=:)/g
		}
	];
});
var U$1 = {
	num: {
		type: "num",
		match: /(\.e?|\b)\d(e-|[\d.oxa-fA-F_])*(\.|\b)/g
	},
	str: {
		type: "str",
		match: /(["'])(\\[^]|(?!\1)[^\r\n\\])*\1?/g
	},
	strDouble: {
		type: "str",
		match: /"((?!")[^\r\n\\]|\\[^])*"?/g
	}
};
var Se$1 = w$1({
	"./languages/asm.js": () => Promise.resolve().then(() => (F$1(), P$1)),
	"./languages/bash.js": () => Promise.resolve().then(() => (f(), $$1)),
	"./languages/bf.js": () => Promise.resolve().then(() => (B$1(), v$1)),
	"./languages/c.js": () => Promise.resolve().then(() => (H$1(), G$1)),
	"./languages/css.js": () => Promise.resolve().then(() => (z$1(), k$1)),
	"./languages/csv.js": () => Promise.resolve().then(() => (Y$1(), _$1)),
	"./languages/diff.js": () => Promise.resolve().then(() => (N$1(), Z$1)),
	"./languages/docker.js": () => Promise.resolve().then(() => (W$1(), X$1)),
	"./languages/git.js": () => Promise.resolve().then(() => (K$1(), j$1)),
	"./languages/go.js": () => Promise.resolve().then(() => (q$1(), V$1)),
	"./languages/html.js": () => Promise.resolve().then(() => (et$1(), tt$1)),
	"./languages/http.js": () => Promise.resolve().then(() => (pt$1(), at$1)),
	"./languages/ini.js": () => Promise.resolve().then(() => (ct$1(), st$1)),
	"./languages/java.js": () => Promise.resolve().then(() => (mt$1(), nt$1)),
	"./languages/js.js": () => Promise.resolve().then(() => (L$1(), rt$1)),
	"./languages/js_template_literals.js": () => Promise.resolve().then(() => (Et$1(), ot$1)),
	"./languages/jsdoc.js": () => Promise.resolve().then(() => (ht$1(), ut$1)),
	"./languages/json.js": () => Promise.resolve().then(() => (gt$1(), it$1)),
	"./languages/leanpub-md.js": () => Promise.resolve().then(() => (yt$1(), bt$1)),
	"./languages/log.js": () => Promise.resolve().then(() => (ft$1(), Tt$1)),
	"./languages/lua.js": () => Promise.resolve().then(() => (Nt$1(), It$1)),
	"./languages/make.js": () => Promise.resolve().then(() => (Rt$1(), At$1)),
	"./languages/md.js": () => Promise.resolve().then(() => (D$1(), dt$1)),
	"./languages/pl.js": () => Promise.resolve().then(() => (Lt$1(), Ot$1)),
	"./languages/plain.js": () => Promise.resolve().then(() => (St$1(), xt$1)),
	"./languages/py.js": () => Promise.resolve().then(() => (Dt$1(), Ct$1)),
	"./languages/regex.js": () => Promise.resolve().then(() => (Ut$1(), wt$1)),
	"./languages/rs.js": () => Promise.resolve().then(() => (Ft$1(), Pt$1)),
	"./languages/sql.js": () => Promise.resolve().then(() => ($t$1(), Mt$1)),
	"./languages/todo.js": () => Promise.resolve().then(() => (S$1(), lt$1)),
	"./languages/toml.js": () => Promise.resolve().then(() => (Bt$1(), vt$1)),
	"./languages/ts.js": () => Promise.resolve().then(() => (Ht$1(), Gt$1)),
	"./languages/uri.js": () => Promise.resolve().then(() => (zt$1(), kt$1)),
	"./languages/xml.js": () => Promise.resolve().then(() => (R$1(), J$1)),
	"./languages/yaml.js": () => Promise.resolve().then(() => (Yt$1(), _t$1))
});
var b$1 = {}, Ce$1 = (t = "") => t.replaceAll("&", "&#38;").replaceAll?.("<", "&lt;").replaceAll?.(">", "&gt;"), De$1 = (t, e) => e ? `<span class="shj-syn-${e}">${t}</span>` : t;
async function Zt$1(t, e, s) {
	try {
		let c, m, n = {}, i, r = [], h = 0, y = typeof e == "string" ? await (b$1[e] ?? (b$1[e] = Se$1(`./languages/${e}.js`))) : e, g = [...typeof e == "string" ? y.default : e.sub];
		for (; h < t.length;) {
			for (n.index = null, c = g.length; c-- > 0;) {
				if (m = g[c].expand ? U$1[g[c].expand] : g[c], r[c] === void 0 || r[c].match.index < h) {
					if (m.match.lastIndex = h, i = m.match.exec(t), i === null) {
						g.splice(c, 1), r.splice(c, 1);
						continue;
					}
					r[c] = {
						match: i,
						lastIndex: m.match.lastIndex
					};
				}
				r[c].match[0] && (r[c].match.index <= n.index || n.index === null) && (n = {
					part: m,
					index: r[c].match.index,
					match: r[c].match[0],
					end: r[c].lastIndex
				});
			}
			if (n.index === null) break;
			s(t.slice(h, n.index), y.type), h = n.end, n.part.sub ? await Zt$1(n.match, typeof n.part.sub == "string" ? n.part.sub : typeof n.part.sub == "function" ? n.part.sub(n.match) : n.part, s) : s(n.match, n.part.type);
		}
		s(t.slice(h, t.length), y.type);
	} catch {
		s(t);
	}
}
async function we$1(t, e, s = !0, c = {}) {
	let m = "";
	return await Zt$1(t, e, (n, i) => m += De$1(Ce$1(n), i)), s ? `<div><div class="shj-numbers">${"<div></div>".repeat(!c.hideLineNumbers && t.split(`
`).length)}</div><div>${m}</div></div>` : m;
}

//#endregion
//#region ../../node_modules/.pnpm/@speed-highlight+core@1.2.14/node_modules/@speed-highlight/core/dist/terminal.js
var te = Object.defineProperty;
var d = (n) => (t) => {
	var s = n[t];
	if (s) return s();
	throw new Error("Module not found in bundle: " + t);
};
var e = (n, t) => () => (n && (t = n(n = 0)), t);
var a = (n, t) => {
	for (var s in t) te(n, s, {
		get: t[s],
		enumerable: !0
	});
};
var B = {};
a(B, { default: () => ee });
var ee, G = e(() => {
	ee = [
		{
			type: "cmnt",
			match: /(;|#).*/gm
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "num",
			match: /\$[\da-fA-F]*\b/g
		},
		{
			type: "kwd",
			match: /^[a-z]+\s+[a-z.]+\b/gm,
			sub: [{
				type: "func",
				match: /^[a-z]+/g
			}]
		},
		{
			type: "kwd",
			match: /^\t*[a-z][a-z\d]*\b/gm
		},
		{
			match: /%|\$/g,
			type: "oper"
		}
	];
});
var H = {};
a(H, { default: () => I });
var k, I, N = e(() => {
	k = {
		type: "var",
		match: /\$\w+|\${[^}]*}|\$\([^)]*\)/g
	}, I = [
		{
			sub: "todo",
			match: /#.*/g
		},
		{
			type: "str",
			match: /(["'])((?!\1)[^\r\n\\]|\\[^])*\1?/g,
			sub: [k]
		},
		{
			type: "oper",
			match: /(?<=\s|^)\.*\/[a-z/_.-]+/gi
		},
		{
			type: "kwd",
			match: /\s-[a-zA-Z]+|$<|[&|;]+|\b(unset|readonly|shift|export|if|fi|else|elif|while|do|done|for|until|case|esac|break|continue|exit|return|trap|wait|eval|exec|then|declare|enable|local|select|typeset|time|add|remove|install|update|delete)(?=\s|$)/g
		},
		{ expand: "num" },
		{
			type: "func",
			match: /(?<=(^|\||\&\&|\;)\s*)[a-z_.-]+(?=\s|$)/gim
		},
		{
			type: "bool",
			match: /(?<=\s|^)(true|false)(?=\s|$)/g
		},
		{
			type: "oper",
			match: /[=(){}<>!]+/g
		},
		{
			type: "var",
			match: /(?<=\s|^)[\w_]+(?=\s*=)/g
		},
		k
	];
});
var z = {};
a(z, { default: () => ae });
var ae, _ = e(() => {
	ae = [
		{
			match: /[^\[\->+.<\]\s].*/g,
			sub: "todo"
		},
		{
			type: "func",
			match: /\.+/g
		},
		{
			type: "kwd",
			match: /[<>]+/g
		},
		{
			type: "oper",
			match: /[+-]+/g
		}
	];
});
var Y = {};
a(Y, { default: () => ne });
var ne, Z = e(() => {
	ne = [
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "kwd",
			match: /#\s*include (<.*>|".*")/g,
			sub: [{
				type: "str",
				match: /(<|").*/g
			}]
		},
		{
			match: /asm\s*{[^}]*}/g,
			sub: [{
				type: "kwd",
				match: /^asm/g
			}, {
				match: /[^{}]*(?=}$)/g,
				sub: "asm"
			}]
		},
		{
			type: "kwd",
			match: /\*|&|#[a-z]+\b|\b(asm|auto|double|int|struct|break|else|long|switch|case|enum|register|typedef|char|extern|return|union|const|float|short|unsigned|continue|for|signed|void|default|goto|sizeof|volatile|do|if|static|while)\b/g
		},
		{
			type: "oper",
			match: /[/*+:?&|%^~=!,<>.^-]+/g
		},
		{
			type: "func",
			match: /[a-zA-Z_][\w_]*(?=\s*\()/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		}
	];
});
var X = {};
a(X, { default: () => pe });
var pe, W = e(() => {
	pe = [
		{
			match: /\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "kwd",
			match: /@\w+\b|\b(and|not|only|or)\b|\b[a-z-]+(?=[^{}]*{)/g
		},
		{
			type: "var",
			match: /\b[\w-]+(?=\s*:)|(::?|\.)[\w-]+(?=[^{}]*{)/g
		},
		{
			type: "func",
			match: /#[\w-]+(?=[^{}]*{)/g
		},
		{
			type: "num",
			match: /#[\da-f]{3,8}/g
		},
		{
			type: "num",
			match: /\d+(\.\d+)?(cm|mm|in|px|pt|pc|em|ex|ch|rem|vm|vh|vmin|vmax|%)?/g,
			sub: [{
				type: "var",
				match: /[a-z]+|%/g
			}]
		},
		{
			match: /url\([^)]*\)/g,
			sub: [{
				type: "func",
				match: /url(?=\()/g
			}, {
				type: "str",
				match: /[^()]+/g
			}]
		},
		{
			type: "func",
			match: /\b[a-zA-Z]\w*(?=\s*\()/g
		},
		{
			type: "num",
			match: /\b[a-z-]+\b/g
		}
	];
});
var j = {};
a(j, { default: () => se });
var se, K = e(() => {
	se = [{ expand: "strDouble" }, {
		type: "oper",
		match: /,/g
	}];
});
var V = {};
a(V, { default: () => A });
var A, R = e(() => {
	A = [
		{
			type: "deleted",
			match: /^[-<].*/gm
		},
		{
			type: "insert",
			match: /^[+>].*/gm
		},
		{
			type: "kwd",
			match: /!.*/gm
		},
		{
			type: "section",
			match: /^@@.*@@$|^\d.*|^([*-+])\1\1.*/gm
		}
	];
});
var q = {};
a(q, { default: () => re });
var re, Q = e(() => {
	N();
	re = [{
		type: "kwd",
		match: /^(FROM|RUN|CMD|LABEL|MAINTAINER|EXPOSE|ENV|ADD|COPY|ENTRYPOINT|VOLUME|USER|WORKDIR|ARG|ONBUILD|STOPSIGNAL|HEALTHCHECK|SHELL)\b/gim
	}, ...I];
});
var J = {};
a(J, { default: () => ce });
var ce, tt = e(() => {
	R();
	ce = [
		{
			match: /^#.*/gm,
			sub: "todo"
		},
		{ expand: "str" },
		...A,
		{
			type: "func",
			match: /^(\$ )?git(\s.*)?$/gm
		},
		{
			type: "kwd",
			match: /^commit \w+$/gm
		}
	];
});
var et = {};
a(et, { default: () => me });
var me, at = e(() => {
	me = [
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "kwd",
			match: /\*|&|\b(break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go|goto|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/g
		},
		{
			type: "func",
			match: /[a-zA-Z_][\w_]*(?=\s*\()/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		},
		{
			type: "oper",
			match: /[+\-*\/%&|^~=!<>.^-]+/g
		}
	];
});
var pt = {};
a(pt, {
	default: () => O,
	name: () => u,
	properties: () => E,
	xmlElement: () => l
});
var nt, oe, u, E, l, O, x = e(() => {
	nt = ":A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�", oe = nt + "\\-\\.0-9·̀-ͯ‿-⁀", u = `[${nt}][${oe}]*`, E = `\\s*(\\s+${u}\\s*(=\\s*([^"']\\S*|("|')(\\\\[^]|(?!\\4)[^])*\\4?)?)?\\s*)*`, l = {
		match: RegExp(`<[/!?]?${u}${E}[/!?]?>`, "g"),
		sub: [
			{
				type: "var",
				match: RegExp(`^<[/!?]?${u}`, "g"),
				sub: [{
					type: "oper",
					match: /^<[\/!?]?/g
				}]
			},
			{
				type: "str",
				match: /=\s*([^"']\S*|("|')(\\[^]|(?!\2)[^])*\2?)/g,
				sub: [{
					type: "oper",
					match: /^=/g
				}]
			},
			{
				type: "oper",
				match: /[\/!?]?>/g
			},
			{
				type: "class",
				match: RegExp(u, "g")
			}
		]
	}, O = [
		{
			match: /<!--((?!-->)[^])*-->/g,
			sub: "todo"
		},
		{
			type: "class",
			match: /<!\[CDATA\[[\s\S]*?\]\]>/gi
		},
		l,
		{
			type: "str",
			match: RegExp(`<\\?${u}([^?]|\\?[^?>])*\\?+>`, "g"),
			sub: [{
				type: "var",
				match: RegExp(`^<\\?${u}`, "g"),
				sub: [{
					type: "oper",
					match: /^<\?/g
				}]
			}, {
				type: "oper",
				match: /\?+>$/g
			}]
		},
		{
			type: "var",
			match: /&(#x?)?[\da-z]{1,8};/gi
		}
	];
});
var st = {};
a(st, { default: () => le });
var le, rt = e(() => {
	x();
	le = [
		{
			type: "class",
			match: /<!DOCTYPE("[^"]*"|'[^']*'|[^"'>])*>/gi,
			sub: [
				{
					type: "str",
					match: /"[^"]*"|'[^']*'/g
				},
				{
					type: "oper",
					match: /^<!|>$/g
				},
				{
					type: "var",
					match: /DOCTYPE/gi
				}
			]
		},
		{
			match: RegExp(`<style${E}>((?!</style>)[^])*</style\\s*>`, "g"),
			sub: [
				{
					match: RegExp(`^<style${E}>`, "g"),
					sub: l.sub
				},
				{
					match: RegExp(`${l.match}|[^]*(?=</style\\s*>$)`, "g"),
					sub: "css"
				},
				l
			]
		},
		{
			match: RegExp(`<script${E}>((?!<\/script>)[^])*<\/script\\s*>`, "g"),
			sub: [
				{
					match: RegExp(`^<script${E}>`, "g"),
					sub: l.sub
				},
				{
					match: RegExp(`${l.match}|[^]*(?=<\/script\\s*>$)`, "g"),
					sub: "js"
				},
				l
			]
		},
		...O
	];
});
var ue, i, b = e(() => {
	ue = [
		[
			"bash",
			[/#!(\/usr)?\/bin\/bash/g, 500],
			[/\b(if|elif|then|fi|echo)\b|\$/g, 10]
		],
		[
			"html",
			[/<\/?[a-z-]+[^\n>]*>/g, 10],
			[/^\s+<!DOCTYPE\s+html/g, 500]
		],
		["http", [/^(GET|HEAD|POST|PUT|DELETE|PATCH|HTTP)\b/g, 500]],
		["js", [/\b(console|await|async|function|export|import|this|class|for|let|const|map|join|require)\b/g, 10]],
		["ts", [/\b(console|await|async|function|export|import|this|class|for|let|const|map|join|require|implements|interface|namespace)\b/g, 10]],
		["py", [/\b(def|print|class|and|or|lambda)\b/g, 10]],
		["sql", [/\b(SELECT|INSERT|FROM)\b/g, 50]],
		[
			"pl",
			[/#!(\/usr)?\/bin\/perl/g, 500],
			[/\b(use|print)\b|\$/g, 10]
		],
		["lua", [/#!(\/usr)?\/bin\/lua/g, 500]],
		["make", [/\b(ifneq|endif|if|elif|then|fi|echo|.PHONY|^[a-z]+ ?:$)\b|\$/gm, 10]],
		["uri", [/https?:|mailto:|tel:|ftp:/g, 30]],
		["css", [/^(@import|@page|@media|(\.|#)[a-z]+)/gm, 20]],
		[
			"diff",
			[/^[+><-]/gm, 10],
			[/^@@ ?[-+,0-9 ]+ ?@@/gm, 25]
		],
		[
			"md",
			[/^(>|\t\*|\t\d+.)/gm, 10],
			[/\[.*\](.*)/g, 10]
		],
		["docker", [/^(FROM|ENTRYPOINT|RUN)/gm, 500]],
		[
			"xml",
			[/<\/?[a-z-]+[^\n>]*>/g, 10],
			[/^<\?xml/g, 500]
		],
		["c", [/#include\b|\bprintf\s+\(/g, 100]],
		["rs", [/^\s+(use|fn|mut|match)\b/gm, 100]],
		["go", [/\b(func|fmt|package)\b/g, 100]],
		["java", [/^import\s+java/gm, 500]],
		["asm", [/^(section|global main|extern|\t(call|mov|ret))/gm, 100]],
		["css", [/^(@import|@page|@media|(\.|#)[a-z]+)/gm, 20]],
		["json", [/\b(true|false|null|\{})\b|\"[^"]+\":/g, 10]],
		["yaml", [/^(\s+)?[a-z][a-z0-9]*:/gim, 10]]
	], i = (n) => ue.map(([t, ...s]) => [t, s.reduce((r, [m, c]) => r + [...n.matchAll(m)].length * c, 0)]).filter(([t, s]) => s > 20).sort((t, s) => s[1] - t[1])[0]?.[0] || "plain";
});
var ct = {};
a(ct, { default: () => Ee });
var Ee, mt = e(() => {
	b();
	Ee = [
		{
			type: "kwd",
			match: /^(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|PRI|SEARCH)\b/gm
		},
		{ expand: "str" },
		{
			type: "section",
			match: /\bHTTP\/[\d.]+\b/g
		},
		{ expand: "num" },
		{
			type: "oper",
			match: /[,;:=]/g
		},
		{
			type: "var",
			match: /[a-zA-Z][\w-]*(?=:)/g
		},
		{
			match: /\n\n[^]*/g,
			sub: i
		}
	];
});
var ot = {};
a(ot, { default: () => ie });
var ie, lt = e(() => {
	ie = [
		{
			match: /(^[ \f\t\v]*)[#;].*/gm,
			sub: "todo"
		},
		{
			type: "str",
			match: /.*/g
		},
		{
			type: "var",
			match: /.*(?==)/g
		},
		{
			type: "section",
			match: /^\s*\[.+\]\s*$/gm
		},
		{
			type: "oper",
			match: /=/g
		}
	];
});
var ut = {};
a(ut, { default: () => he });
var he, Et = e(() => {
	he = [
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "kwd",
			match: /\b(abstract|assert|boolean|break|byte|case|catch|char|class|continue|const|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|package|private|protected|public|requires|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|transient|try|var|void|volatile|while)\b/g
		},
		{
			type: "oper",
			match: /[/*+:?&|%^~=!,<>.^-]+/g
		},
		{
			type: "func",
			match: /[a-zA-Z_][\w_]*(?=\s*\()/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		}
	];
});
var it = {};
a(it, { default: () => L });
var L, S = e(() => {
	L = [
		{
			match: /\/\*\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "jsdoc"
		},
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			match: /`((?!`)[^]|\\[^])*`?/g,
			sub: "js_template_literals"
		},
		{
			type: "kwd",
			match: /=>|\b(this|set|get|as|async|await|break|case|catch|class|const|constructor|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|if|implements|import|in|instanceof|interface|let|var|of|new|package|private|protected|public|return|static|super|switch|throw|throws|try|typeof|void|while|with|yield)\b/g
		},
		{
			match: /\/((?!\/)[^\r\n\\]|\\.)+\/[dgimsuy]*/g,
			sub: "regex"
		},
		{ expand: "num" },
		{
			type: "num",
			match: /\b(NaN|null|undefined|[A-Z][A-Z_]*)\b/g
		},
		{
			type: "bool",
			match: /\b(true|false)\b/g
		},
		{
			type: "oper",
			match: /[/*+:?&|%^~=!,<>.^-]+/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		},
		{
			type: "func",
			match: /[a-zA-Z$_][\w$_]*(?=\s*((\?\.)?\s*\(|=\s*(\(?[\w,{}\[\])]+\)? =>|function\b)))/g
		}
	];
});
var ht = {};
a(ht, {
	default: () => ge,
	type: () => de
});
var ge, de, gt = e(() => {
	ge = [{
		match: new class {
			exec(n) {
				let t = this.lastIndex, s, r = (m) => {
					for (; ++t < n.length - 2;) if (n[t] == "{") r();
					else if (n[t] == "}") return;
				};
				for (; t < n.length; ++t) if (n[t - 1] != "\\" && n[t] == "$" && n[t + 1] == "{") return s = t++, r(t), this.lastIndex = t + 1, {
					index: s,
					0: n.slice(s, t + 1)
				};
				return null;
			}
		}(),
		sub: [{
			type: "kwd",
			match: /^\${|}$/g
		}, {
			match: /(?!^\$|{)[^]+(?=}$)/g,
			sub: "js"
		}]
	}], de = "str";
});
var dt = {};
a(dt, {
	default: () => C,
	type: () => be
});
var C, be, D = e(() => {
	C = [
		{
			type: "err",
			match: /\b(TODO|FIXME|DEBUG|OPTIMIZE|WARNING|XXX|BUG)\b/g
		},
		{
			type: "class",
			match: /\bIDEA\b/g
		},
		{
			type: "insert",
			match: /\b(CHANGED|FIX|CHANGE)\b/g
		},
		{
			type: "oper",
			match: /\bQUESTION\b/g
		}
	], be = "cmnt";
});
var bt = {};
a(bt, {
	default: () => ye,
	type: () => Te
});
var ye, Te, yt = e(() => {
	D();
	ye = [
		{
			type: "kwd",
			match: /@\w+/g
		},
		{
			type: "class",
			match: /{[\w\s|<>,.@\[\]]+}/g
		},
		{
			type: "var",
			match: /\[[\w\s="']+\]/g
		},
		...C
	], Te = "cmnt";
});
var Tt = {};
a(Tt, { default: () => fe });
var fe, ft = e(() => {
	fe = [
		{
			type: "var",
			match: /(("|')((?!\2)[^\r\n\\]|\\[^])*\2|[a-zA-Z]\w*)(?=\s*:)/g
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "num",
			match: /\bnull\b/g
		},
		{
			type: "bool",
			match: /\b(true|false)\b/g
		}
	];
});
var It = {};
a(It, { default: () => w });
var w, U = e(() => {
	b();
	w = [
		{
			type: "cmnt",
			match: /^>.*|(=|-)\1+/gm
		},
		{
			type: "class",
			match: /\*\*((?!\*\*).)*\*\*/g
		},
		{
			match: /```((?!```)[^])*\n```/g,
			sub: (n) => ({
				type: "kwd",
				sub: [{
					match: /\n[^]*(?=```)/g,
					sub: n.split(`
`)[0].slice(3) || i(n)
				}]
			})
		},
		{
			type: "str",
			match: /`[^`]*`/g
		},
		{
			type: "var",
			match: /~~((?!~~).)*~~/g
		},
		{
			type: "kwd",
			match: /\b_\S([^\n]*?\S)?_\b|\*\S([^\n]*?\S)?\*/g
		},
		{
			type: "kwd",
			match: /^\s*(\*|\d+\.)\s/gm
		},
		{
			type: "func",
			match: /\[[^\]]*]\([^)]*\)|<[^>]*>/g,
			sub: [{
				type: "oper",
				match: /^\[[^\]]*]/g
			}]
		}
	];
});
var Nt = {};
a(Nt, { default: () => Ie });
var Ie, At = e(() => {
	U();
	b();
	Ie = [
		{
			type: "insert",
			match: /(leanpub-start-insert)((?!leanpub-end-insert)[^])*(leanpub-end-insert)?/g,
			sub: [{
				type: "insert",
				match: /leanpub-(start|end)-insert/g
			}, {
				match: /(?!leanpub-start-insert)((?!leanpub-end-insert)[^])*/g,
				sub: i
			}]
		},
		{
			type: "deleted",
			match: /(leanpub-start-delete)((?!leanpub-end-delete)[^])*(leanpub-end-delete)?/g,
			sub: [{
				type: "deleted",
				match: /leanpub-(start|end)-delete/g
			}, {
				match: /(?!leanpub-start-delete)((?!leanpub-end-delete)[^])*/g,
				sub: i
			}]
		},
		...w
	];
});
var Rt = {};
a(Rt, { default: () => Ne });
var Ne, Ot = e(() => {
	Ne = [
		{
			type: "cmnt",
			match: /^#.*/gm
		},
		{ expand: "strDouble" },
		{ expand: "num" },
		{
			type: "err",
			match: /\b(err(or)?|[a-z_-]*exception|warn|warning|failed|ko|invalid|not ?found|alert|fatal)\b/gi
		},
		{
			type: "num",
			match: /\b(null|undefined)\b/gi
		},
		{
			type: "bool",
			match: /\b(false|true|yes|no)\b/gi
		},
		{
			type: "oper",
			match: /\.|,/g
		}
	];
});
var xt = {};
a(xt, { default: () => Ae });
var Ae, Lt = e(() => {
	Ae = [
		{
			match: /^#!.*|--(\[(=*)\[((?!--\]\2\])[^])*--\]\2\]|.*)/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "kwd",
			match: /\b(and|break|do|else|elseif|end|for|function|if|in|local|not|or|repeat|return|then|until|while)\b/g
		},
		{
			type: "bool",
			match: /\b(true|false|nil)\b/g
		},
		{
			type: "oper",
			match: /[+*/%^#=~<>:,.-]+/g
		},
		{ expand: "num" },
		{
			type: "func",
			match: /[a-z_]+(?=\s*[({])/g
		}
	];
});
var St = {};
a(St, { default: () => Re });
var Re, Ct = e(() => {
	Re = [
		{
			match: /^\s*#.*/gm,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "oper",
			match: /[${}()]+/g
		},
		{
			type: "class",
			match: /.PHONY:/gm
		},
		{
			type: "section",
			match: /^[\w.]+:/gm
		},
		{
			type: "kwd",
			match: /\b(ifneq|endif)\b/g
		},
		{ expand: "num" },
		{
			type: "var",
			match: /[A-Z_]+(?=\s*=)/g
		},
		{
			match: /^.*$/gm,
			sub: "bash"
		}
	];
});
var Dt = {};
a(Dt, { default: () => Oe });
var Oe, wt = e(() => {
	Oe = [
		{
			match: /#.*/g,
			sub: "todo"
		},
		{
			type: "str",
			match: /(["'])(\\[^]|(?!\1)[^])*\1?/g
		},
		{ expand: "num" },
		{
			type: "kwd",
			match: /\b(any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while|not|and|or|xor)\b/g
		},
		{
			type: "oper",
			match: /[-+*/%~!&<>|=?,]+/g
		},
		{
			type: "func",
			match: /[a-z_]+(?=\s*\()/g
		}
	];
});
var Ut = {};
a(Ut, { default: () => xe });
var xe, Pt = e(() => {
	xe = [{ expand: "strDouble" }];
});
var Ft = {};
a(Ft, { default: () => Le });
var Le, Mt = e(() => {
	Le = [
		{
			match: /#.*/g,
			sub: "todo"
		},
		{
			type: "str",
			match: /f("""|''')(\\[^]|(?!\1)[^])*\1?|f("|')(\\[^]|(?!\3).)*\3?/gi,
			sub: [{
				type: "var",
				match: /{[^{}]*}/g,
				sub: [{
					match: /(?!^{)[^]*(?=}$)/g,
					sub: "py"
				}]
			}]
		},
		{
			match: /("""|''')(\\[^]|(?!\1)[^])*\1?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "kwd",
			match: /\b(and|as|assert|break|class|continue|def|del|elif|else|except|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|raise|return|try|while|with|yield)\b/g
		},
		{
			type: "bool",
			match: /\b(False|True|None)\b/g
		},
		{ expand: "num" },
		{
			type: "func",
			match: /[a-z_]\w*(?=\s*\()/gi
		},
		{
			type: "oper",
			match: /[-/*+<>,=!&|^%]+/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		}
	];
});
var $t = {};
a($t, {
	default: () => Se,
	type: () => Ce
});
var Se, Ce, vt = e(() => {
	Se = [
		{
			match: /^(?!\/).*/gm,
			sub: "todo"
		},
		{
			type: "num",
			match: /\[((?!\])[^\\]|\\.)*\]/g
		},
		{
			type: "kwd",
			match: /\||\^|\$|\\.|\w+($|\r|\n)/g
		},
		{
			type: "var",
			match: /\*|\+|\{\d+,\d+\}/g
		}
	], Ce = "oper";
});
var Bt = {};
a(Bt, { default: () => De });
var De, Gt = e(() => {
	De = [
		{
			match: /\/\/.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{ expand: "num" },
		{
			type: "kwd",
			match: /\b(as|break|const|continue|crate|else|enum|extern|false|fn|for|if|impl|in|let|loop|match|mod|move|mut|pub|ref|return|self|Self|static|struct|super|trait|true|type|unsafe|use|where|while|async|await|dyn|abstract|become|box|do|final|macro|override|priv|typeof|unsized|virtual|yield|try)\b/g
		},
		{
			type: "oper",
			match: /[/*+:?&|%^~=!,<>.^-]+/g
		},
		{
			type: "class",
			match: /\b[A-Z][\w_]*\b/g
		},
		{
			type: "func",
			match: /[a-zA-Z_][\w_]*(?=\s*!?\s*\()/g
		}
	];
});
var kt = {};
a(kt, { default: () => we });
var we, Ht = e(() => {
	we = [
		{
			match: /--.*\n?|\/\*((?!\*\/)[^])*(\*\/)?/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "func",
			match: /\b(AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/g
		},
		{
			type: "kwd",
			match: /\b(ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|kwdS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:S|ING)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/g
		},
		{
			type: "num",
			match: /\.?\d[\d.oxa-fA-F-]*|\bNULL\b/g
		},
		{
			type: "bool",
			match: /\b(TRUE|FALSE)\b/g
		},
		{
			type: "oper",
			match: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|IN|ILIKE|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/g
		},
		{
			type: "var",
			match: /@\S+/g
		}
	];
});
var zt = {};
a(zt, { default: () => Ue });
var Ue, _t = e(() => {
	Ue = [
		{
			match: /#.*/g,
			sub: "todo"
		},
		{
			type: "str",
			match: /("""|''')((?!\1)[^]|\\[^])*\1?/g
		},
		{ expand: "str" },
		{
			type: "section",
			match: /^\[.+\]\s*$/gm
		},
		{
			type: "num",
			match: /\b(inf|nan)\b|\d[\d:ZT.-]*/g
		},
		{ expand: "num" },
		{
			type: "bool",
			match: /\b(true|false)\b/g
		},
		{
			type: "oper",
			match: /[+,.=-]/g
		},
		{
			type: "var",
			match: /\w+(?= \=)/g
		}
	];
});
var Yt = {};
a(Yt, { default: () => Pe });
var Pe, Zt = e(() => {
	S();
	Pe = [
		{
			type: "type",
			match: /:\s*(any|void|number|boolean|string|object|never|enum)\b/g
		},
		{
			type: "kwd",
			match: /\b(type|namespace|typedef|interface|public|private|protected|implements|declare|abstract|readonly)\b/g
		},
		...L
	];
});
var Xt = {};
a(Xt, { default: () => Fe });
var Fe, Wt = e(() => {
	Fe = [
		{
			match: /^#.*/gm,
			sub: "todo"
		},
		{
			type: "class",
			match: /^\w+(?=:?)/gm
		},
		{
			type: "num",
			match: /:\d+/g
		},
		{
			type: "oper",
			match: /[:/&?]|\w+=/g
		},
		{
			type: "func",
			match: /[.\w]+@|#[\w]+$/gm
		},
		{
			type: "var",
			match: /\w+\.\w+(\.\w+)*/g
		}
	];
});
var jt = {};
a(jt, { default: () => Me });
var Me, Kt = e(() => {
	Me = [
		{
			match: /#.*/g,
			sub: "todo"
		},
		{ expand: "str" },
		{
			type: "str",
			match: /(>|\|)\r?\n((\s[^\n]*)?(\r?\n|$))*/g
		},
		{
			type: "type",
			match: /!![a-z]+/g
		},
		{
			type: "bool",
			match: /\b(Yes|No)\b/g
		},
		{
			type: "oper",
			match: /[+:-]/g
		},
		{ expand: "num" },
		{
			type: "var",
			match: /[a-zA-Z]\w*(?=:)/g
		}
	];
});
var Vt = {};
a(Vt, { default: () => p });
var p, y = e(() => {
	p = {
		black: "\x1B[30m",
		red: "\x1B[31m",
		green: "\x1B[32m",
		gray: "\x1B[90m",
		yellow: "\x1B[33m",
		blue: "\x1B[34m",
		magenta: "\x1B[35m",
		cyan: "\x1B[36m",
		white: "\x1B[37m"
	};
});
var qt = {};
a(qt, { default: () => ve });
var ve, Qt = e(() => {
	y();
	ve = {
		deleted: p.red,
		var: p.red,
		err: p.red,
		kwd: p.magenta,
		num: p.yellow,
		class: p.yellow,
		cmnt: p.gray,
		insert: p.green,
		str: p.green,
		bool: p.cyan,
		type: p.blue,
		oper: p.blue,
		section: p.magenta,
		func: p.blue
	};
});
var M = {};
a(M, { default: () => Be });
var Be, $ = e(() => {
	y();
	Be = {
		deleted: p.red,
		var: p.red,
		err: p.red,
		kwd: p.red,
		num: p.yellow,
		class: p.yellow,
		cmnt: p.gray,
		insert: p.green,
		str: p.green,
		bool: p.cyan,
		type: p.blue,
		oper: p.blue,
		section: p.magenta,
		func: p.magenta
	};
});
var v = {
	num: {
		type: "num",
		match: /(\.e?|\b)\d(e-|[\d.oxa-fA-F_])*(\.|\b)/g
	},
	str: {
		type: "str",
		match: /(["'])(\\[^]|(?!\1)[^\r\n\\])*\1?/g
	},
	strDouble: {
		type: "str",
		match: /"((?!")[^\r\n\\]|\\[^])*"?/g
	}
};
var $e = d({
	"./languages/asm.js": () => Promise.resolve().then(() => (G(), B)),
	"./languages/bash.js": () => Promise.resolve().then(() => (N(), H)),
	"./languages/bf.js": () => Promise.resolve().then(() => (_(), z)),
	"./languages/c.js": () => Promise.resolve().then(() => (Z(), Y)),
	"./languages/css.js": () => Promise.resolve().then(() => (W(), X)),
	"./languages/csv.js": () => Promise.resolve().then(() => (K(), j)),
	"./languages/diff.js": () => Promise.resolve().then(() => (R(), V)),
	"./languages/docker.js": () => Promise.resolve().then(() => (Q(), q)),
	"./languages/git.js": () => Promise.resolve().then(() => (tt(), J)),
	"./languages/go.js": () => Promise.resolve().then(() => (at(), et)),
	"./languages/html.js": () => Promise.resolve().then(() => (rt(), st)),
	"./languages/http.js": () => Promise.resolve().then(() => (mt(), ct)),
	"./languages/ini.js": () => Promise.resolve().then(() => (lt(), ot)),
	"./languages/java.js": () => Promise.resolve().then(() => (Et(), ut)),
	"./languages/js.js": () => Promise.resolve().then(() => (S(), it)),
	"./languages/js_template_literals.js": () => Promise.resolve().then(() => (gt(), ht)),
	"./languages/jsdoc.js": () => Promise.resolve().then(() => (yt(), bt)),
	"./languages/json.js": () => Promise.resolve().then(() => (ft(), Tt)),
	"./languages/leanpub-md.js": () => Promise.resolve().then(() => (At(), Nt)),
	"./languages/log.js": () => Promise.resolve().then(() => (Ot(), Rt)),
	"./languages/lua.js": () => Promise.resolve().then(() => (Lt(), xt)),
	"./languages/make.js": () => Promise.resolve().then(() => (Ct(), St)),
	"./languages/md.js": () => Promise.resolve().then(() => (U(), It)),
	"./languages/pl.js": () => Promise.resolve().then(() => (wt(), Dt)),
	"./languages/plain.js": () => Promise.resolve().then(() => (Pt(), Ut)),
	"./languages/py.js": () => Promise.resolve().then(() => (Mt(), Ft)),
	"./languages/regex.js": () => Promise.resolve().then(() => (vt(), $t)),
	"./languages/rs.js": () => Promise.resolve().then(() => (Gt(), Bt)),
	"./languages/sql.js": () => Promise.resolve().then(() => (Ht(), kt)),
	"./languages/todo.js": () => Promise.resolve().then(() => (D(), dt)),
	"./languages/toml.js": () => Promise.resolve().then(() => (_t(), zt)),
	"./languages/ts.js": () => Promise.resolve().then(() => (Zt(), Yt)),
	"./languages/uri.js": () => Promise.resolve().then(() => (Wt(), Xt)),
	"./languages/xml.js": () => Promise.resolve().then(() => (x(), pt)),
	"./languages/yaml.js": () => Promise.resolve().then(() => (Kt(), jt))
});
var P = {};
async function F(n, t, s) {
	try {
		let r, m, c = {}, T, o = [], h = 0, f = typeof t == "string" ? await (P[t] ?? (P[t] = $e(`./languages/${t}.js`))) : t, g = [...typeof t == "string" ? f.default : t.sub];
		for (; h < n.length;) {
			for (c.index = null, r = g.length; r-- > 0;) {
				if (m = g[r].expand ? v[g[r].expand] : g[r], o[r] === void 0 || o[r].match.index < h) {
					if (m.match.lastIndex = h, T = m.match.exec(n), T === null) {
						g.splice(r, 1), o.splice(r, 1);
						continue;
					}
					o[r] = {
						match: T,
						lastIndex: m.match.lastIndex
					};
				}
				o[r].match[0] && (o[r].match.index <= c.index || c.index === null) && (c = {
					part: m,
					index: o[r].match.index,
					match: o[r].match[0],
					end: o[r].lastIndex
				});
			}
			if (c.index === null) break;
			s(n.slice(h, c.index), f.type), h = c.end, c.part.sub ? await F(c.match, typeof c.part.sub == "string" ? c.part.sub : typeof c.part.sub == "function" ? c.part.sub(c.match) : c.part, s) : s(c.match, c.part.type);
		}
		s(n.slice(h, n.length), f.type);
	} catch {
		s(n);
	}
}
var Ge = d({
	"./themes/atom-dark.js": () => Promise.resolve().then(() => (Qt(), qt)),
	"./themes/default.js": () => Promise.resolve().then(() => ($(), M)),
	"./themes/termcolor.js": () => Promise.resolve().then(() => (y(), Vt))
});
var Jt = Promise.resolve().then(() => ($(), M)), ke = async (n, t) => {
	let s = "", r = (await Jt).default;
	return await F(n, t, (m, c) => s += c ? `${r[c] ?? ""}${m}\x1B[0m` : m), s;
}, la = async (n, t) => console.log(await ke(n, t)), ua = async (n) => Jt = Ge(`./themes/${n}.js`);

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/chunk-7QV3D5YX.js
var GUTTER = "┃";
var POINTER = "❯";
var LANGS_MAP = {
	".tsx": "ts",
	".jsx": "js",
	".js": "js",
	".ts": "ts",
	".css": "css",
	".json": "json",
	".html": "html",
	".astro": "ts",
	".vue": "ts"
};
var ErrorStackSource = class extends BaseComponent {
	cssFile = new URL("./error_stack_source/style.css", publicDirURL);
	/**
	* The toHTML method is used to output the HTML for the
	* web view
	*/
	async toHTML(props) {
		const frame = props.frame;
		if (frame.type === "native" || !frame.source || !frame.fileName) return "";
		const language = LANGS_MAP[extname$1(frame.fileName)] ?? "plain";
		const highlight = `<div class="line-highlight" style="margin-top: ${`${frame.source.findIndex((chunk) => {
			return chunk.lineNumber === frame.lineNumber;
		}) * 24}px`}"></div>`;
		let code = await we$1(frame.source.map((chunk) => chunk.chunk).join("\n"), language, true);
		code = code.replace("<div class=\"shj-numbers\">", `<div class="shj-numbers" style="counter-set: line ${frame.source[0].lineNumber - 1}">`);
		return `<pre><code class="shj-lang-js">${highlight}${code}</code></pre>`;
	}
	/**
	* The toANSI method is used to output the text for the console
	*/
	async toANSI(props) {
		const frame = props.frame;
		if (frame.type === "native" || !frame.source || !frame.fileName) return "";
		const language = LANGS_MAP[extname$1(frame.fileName)] ?? "plain";
		const largestLineNumber = Math.max(...frame.source.map(({ lineNumber }) => lineNumber));
		const lineNumberCols = String(largestLineNumber).length;
		return `

${(await ke(frame.source.map(({ chunk }) => chunk).join("\n"), language)).split("\n").map((line, index) => {
			const lineNumber = frame.source[index].lineNumber;
			const alignedLineNumber = String(lineNumber).padStart(lineNumberCols, " ");
			if (lineNumber === props.frame.lineNumber) return ` ${colors$1.bgRed(`${POINTER} ${alignedLineNumber} ${GUTTER}  ${stripAnsi(line)}`)}`;
			return `   ${colors$1.dim(alignedLineNumber)} ${colors$1.dim(GUTTER)}  ${line}`;
		}).join("\n")}
`;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/chunk-AUGPHE32.js
var DARK_MODE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="15" height="15" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M0 0h24v24H0z" stroke="none"/><path d="M12 3h.393a7.5 7.5 0 0 0 7.92 12.446A9 9 0 1 1 12 2.992z"/></svg>`;
var LIGHT_MODE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" width="15" height="15" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M0 0h24v24H0z" stroke="none"/><circle cx="12" cy="12" r="4"/><path d="M3 12h1m8-9v1m8 8h1m-9 8v1M5.6 5.6l.7.7m12.1-.7-.7.7m0 11.4.7.7m-12.1-.7-.7.7"/></svg>`;
var Header = class extends BaseComponent {
	cssFile = new URL("./header/style.css", publicDirURL);
	scriptFile = new URL("./header/script.js", publicDirURL);
	/**
	* The toHTML method is used to output the HTML for the
	* web view
	*/
	async toHTML() {
		return `<header id="header">
      <div id="header-actions">
        <div id="toggle-theme-container">
          <input type="checkbox" id="toggle-theme-checkbox" />
          <label id="toggle-theme-label" for="toggle-theme-checkbox">
            <span id="light-theme-indicator" title="Light mode">${LIGHT_MODE_SVG}</span>
            <span id="dark-theme-indicator" title="Dark mode">${DARK_MODE_SVG}</span>
          </label>
        </div>
      </div>
    </header>`;
	}
	/**
	* The toANSI method is used to output the text for the console
	*/
	async toANSI() {
		return "";
	}
};

//#endregion
//#region ../../node_modules/.pnpm/cookie-es@2.0.0/node_modules/cookie-es/dist/index.mjs
function parse$3(str, options) {
	if (typeof str !== "string") throw new TypeError("argument str must be a string");
	const obj = {};
	const opt = options || {};
	const dec = opt.decode || decode;
	let index = 0;
	while (index < str.length) {
		const eqIdx = str.indexOf("=", index);
		if (eqIdx === -1) break;
		let endIdx = str.indexOf(";", index);
		if (endIdx === -1) endIdx = str.length;
		else if (endIdx < eqIdx) {
			index = str.lastIndexOf(";", eqIdx - 1) + 1;
			continue;
		}
		const key = str.slice(index, eqIdx).trim();
		if (opt?.filter && !opt?.filter(key)) {
			index = endIdx + 1;
			continue;
		}
		if (void 0 === obj[key]) {
			let val = str.slice(eqIdx + 1, endIdx).trim();
			if (val.codePointAt(0) === 34) val = val.slice(1, -1);
			obj[key] = tryDecode(val, dec);
		}
		index = endIdx + 1;
	}
	return obj;
}
function decode(str) {
	return str.includes("%") ? decodeURIComponent(str) : str;
}
function tryDecode(str, decode2) {
	try {
		return decode2(str);
	} catch {
		return str;
	}
}

//#endregion
//#region ../../node_modules/.pnpm/@poppinss+exception@1.2.3/node_modules/@poppinss/exception/build/index.js
var Exception = class extends Error {
	name;
	status;
	constructor(message, options) {
		super(message, options);
		const ErrorConstructor = this.constructor;
		this.name = ErrorConstructor.name;
		this.message = message || ErrorConstructor.message || "";
		this.status = options?.status || ErrorConstructor.status || 500;
		const code = options?.code || ErrorConstructor.code;
		if (code !== void 0) this.code = code;
		const help = ErrorConstructor.help;
		if (help !== void 0) this.help = help;
		Error.captureStackTrace(this, ErrorConstructor);
	}
	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
	toString() {
		if (this.code) return `${this.name} [${this.code}]: ${this.message}`;
		return `${this.name}: ${this.message}`;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/error-stack-parser-es@1.0.5/node_modules/error-stack-parser-es/dist/lite.mjs
const FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
const CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
const SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;
function parse$2(error, options) {
	if (typeof error.stacktrace !== "undefined" || typeof error["opera#sourceloc"] !== "undefined") return parseOpera(error, options);
	else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) return parseV8OrIE(error, options);
	else if (error.stack) return parseFFOrSafari(error, options);
	else if (options?.allowEmpty) return [];
	else throw new Error("Cannot parse given Error object");
}
function extractLocation(urlLike) {
	if (!urlLike.includes(":")) return [
		urlLike,
		void 0,
		void 0
	];
	const parts = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(urlLike.replace(/[()]/g, ""));
	return [
		parts[1],
		parts[2] || void 0,
		parts[3] || void 0
	];
}
function applySlice(lines, options) {
	if (options && options.slice != null) {
		if (Array.isArray(options.slice)) return lines.slice(options.slice[0], options.slice[1]);
		return lines.slice(0, options.slice);
	}
	return lines;
}
function parseV8OrIE(error, options) {
	return parseV8OrIeString(error.stack, options);
}
function parseV8OrIeString(stack, options) {
	return applySlice(stack.split("\n").filter((line) => {
		return !!line.match(CHROME_IE_STACK_REGEXP);
	}), options).map((line) => {
		if (line.includes("(eval ")) line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
		let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
		const location = sanitizedLine.match(/ (\(.+\)$)/);
		sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
		const locationParts = extractLocation(location ? location[1] : sanitizedLine);
		return {
			function: location && sanitizedLine || void 0,
			file: ["eval", "<anonymous>"].includes(locationParts[0]) ? void 0 : locationParts[0],
			line: locationParts[1] ? +locationParts[1] : void 0,
			col: locationParts[2] ? +locationParts[2] : void 0,
			raw: line
		};
	});
}
function parseFFOrSafari(error, options) {
	return parseFFOrSafariString(error.stack, options);
}
function parseFFOrSafariString(stack, options) {
	return applySlice(stack.split("\n").filter((line) => {
		return !line.match(SAFARI_NATIVE_CODE_REGEXP);
	}), options).map((line) => {
		if (line.includes(" > eval")) line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
		if (!line.includes("@") && !line.includes(":")) return { function: line };
		else {
			const functionNameRegex = /(([^\n\r"\u2028\u2029]*".[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*(?:@[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*)*(?:[\n\r\u2028\u2029][^@]*)?)?[^@]*)@/;
			const matches = line.match(functionNameRegex);
			const functionName = matches && matches[1] ? matches[1] : void 0;
			const locationParts = extractLocation(line.replace(functionNameRegex, ""));
			return {
				function: functionName,
				file: locationParts[0],
				line: locationParts[1] ? +locationParts[1] : void 0,
				col: locationParts[2] ? +locationParts[2] : void 0,
				raw: line
			};
		}
	});
}
function parseOpera(e, options) {
	if (!e.stacktrace || e.message.includes("\n") && e.message.split("\n").length > e.stacktrace.split("\n").length) return parseOpera9(e);
	else if (!e.stack) return parseOpera10(e);
	else return parseOpera11(e, options);
}
function parseOpera9(e, options) {
	const lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
	const lines = e.message.split("\n");
	const result = [];
	for (let i = 2, len = lines.length; i < len; i += 2) {
		const match = lineRE.exec(lines[i]);
		if (match) result.push({
			file: match[2],
			line: +match[1],
			raw: lines[i]
		});
	}
	return applySlice(result, options);
}
function parseOpera10(e, options) {
	const lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
	const lines = e.stacktrace.split("\n");
	const result = [];
	for (let i = 0, len = lines.length; i < len; i += 2) {
		const match = lineRE.exec(lines[i]);
		if (match) result.push({
			function: match[3] || void 0,
			file: match[2],
			line: match[1] ? +match[1] : void 0,
			raw: lines[i]
		});
	}
	return applySlice(result, options);
}
function parseOpera11(error, options) {
	return applySlice(error.stack.split("\n").filter((line) => {
		return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
	}), options).map((line) => {
		const tokens = line.split("@");
		const locationParts = extractLocation(tokens.pop());
		const functionCall = tokens.shift() || "";
		const functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
		let argsRaw;
		if (functionCall.match(/\(([^)]*)\)/)) argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
		return {
			function: functionName,
			args: argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(","),
			file: locationParts[0],
			line: locationParts[1] ? +locationParts[1] : void 0,
			col: locationParts[2] ? +locationParts[2] : void 0,
			raw: line
		};
	});
}

//#endregion
//#region ../../node_modules/.pnpm/error-stack-parser-es@1.0.5/node_modules/error-stack-parser-es/dist/index.mjs
function stackframesLiteToStackframes(liteStackframes) {
	return liteStackframes.map((liteStackframe) => {
		return {
			functionName: liteStackframe.function,
			args: liteStackframe.args,
			fileName: liteStackframe.file,
			lineNumber: liteStackframe.line,
			columnNumber: liteStackframe.col,
			source: liteStackframe.raw
		};
	});
}
function parse$1(error, options) {
	return stackframesLiteToStackframes(parse$2(error, options));
}

//#endregion
//#region ../../node_modules/.pnpm/youch-core@0.3.3/node_modules/youch-core/build/index.js
var debug_default = debuglog$1("youch:core");
var SourceFile = class {
	#contents;
	constructor(options) {
		if ("contents" in options) this.#contents = options.contents;
	}
	/**
	* Slice the file contents for the buffer size around a given
	* line number.
	*
	* @example
	* ```ts
	* const chunks = sourceFile.slice(11, 7)
	* // Here chunks will be an array of 7 items from line number
	* // 8 to 14
	* ```
	*/
	slice(lineNumber, bufferSize) {
		if (!this.#contents) return;
		const lines = this.#contents.split(/\n|\r\n/);
		const contentSize = lines.length;
		const chunkSize = Math.ceil((bufferSize - 1) / 2);
		let startIndex = chunkSize >= lineNumber ? 0 : lineNumber - chunkSize - 1;
		if (contentSize - lineNumber < chunkSize) startIndex = Math.max(startIndex - (chunkSize - (contentSize - lineNumber)), 0);
		const sourceIndex = lineNumber - 1;
		const endIndex = startIndex - sourceIndex + chunkSize + chunkSize + lineNumber;
		debug_default("slicing file contents", {
			startIndex,
			endIndex,
			sourceIndex,
			contentSize,
			bufferSize,
			chunkSize
		});
		return lines.slice(startIndex, endIndex).map((chunk, index) => {
			return {
				chunk,
				lineNumber: startIndex + index + 1
			};
		});
	}
};
var ErrorParser = class _ErrorParser {
	/**
	* FS source loader reads the file contents from the filesystem
	* for all non-native frames
	*/
	static fsSourceLoader = async (frame) => {
		if (!frame.fileName || frame.fileType !== "fs" || frame.type === "native") return;
		debug_default("reading contents for source file %s", frame.fileName);
		try {
			return { contents: await readFile$1(frame.fileName, "utf-8") };
		} catch (error) {
			debug_default(`Unable to read source file %s, error %s`, frame.fileName, error.message);
		}
	};
	/**
	* Native frames filename identifiers for Node.js and
	* Deno
	*/
	#nativeFramesIdentifiers = ["node:", "ext:"];
	/**
	* Native frames filename identifier for Bun. In case of
	* bun, the filename exactly matches the keyword "native"
	*/
	#bunNativeIdentifier = "native";
	/**
	* Cache of preloaded source files along with their absolute
	* path
	*/
	#sourceFiles = /* @__PURE__ */ new Map();
	/**
	* The offset can be used to skip initial frames from the
	* error stack
	*/
	#offset;
	/**
	* Custom source loader to consult for reading the sourcefile
	* contents
	*/
	#sourceLoader = _ErrorParser.fsSourceLoader;
	/**
	* Parsers are used to prepare the source value for parsing
	*/
	#parsers = [];
	/**
	* Transformers are used to post process the parsed error and
	* attach additional information to it.
	*/
	#transformers = [];
	constructor(options) {
		options = options ?? {};
		this.#offset = options.offset;
	}
	/**
	* Normalizes the unknown error to be an Error
	*/
	#normalizeError(source) {
		if (source instanceof Error) return source;
		if (typeof source === "object" && source && "message" in source && "stack" in source) return source;
		const error = new Exception(JSON.stringify(source));
		error.help = "To get as much information as possible from your errors, make sure to throw Error objects. See <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error</a> for more information.";
		return error;
	}
	/**
	* Returns the source chunks for a given file and the
	* line number.
	*/
	async #getSource(frame) {
		let sourceFile = this.#sourceFiles.get(frame.fileName);
		if (sourceFile) {
			debug_default("reading sourcefile from cache %s", frame.fileName);
			return sourceFile.slice(frame.lineNumber ?? 1, 11);
		}
		const contents = await this.#sourceLoader(frame);
		if (contents) {
			sourceFile = new SourceFile(contents);
			debug_default("caching sourcefile instance for %s", frame.fileName);
			this.#sourceFiles.set(frame.fileName, sourceFile);
			return sourceFile.slice(frame.lineNumber ?? 1, 11);
		}
	}
	/**
	* Syntax errors in JavaScript does not contain the source file
	* location within the stack trace, since the error has
	* happened in the language parser.
	*
	* However, Node.js includes the absolute path to the file within
	* the stack trace contents as the first line. So we parse
	* that out in this function.
	*/
	#parseSyntaxError(error) {
		const [sourceIdentifier] = error.stack?.split("\n") || [];
		const tokens = sourceIdentifier.split(":");
		const lineNumber = Number(tokens.pop());
		const fileName = tokens.join(":");
		if (fileName && !Number.isNaN(lineNumber)) return [{
			fileName,
			lineNumber,
			source: sourceIdentifier
		}];
		return [];
	}
	/**
	* Applies the offset on the frames to skip certain frames
	* from the start
	*/
	#applyOffset(frames) {
		if (this.#offset) return frames.slice(this.#offset);
		return frames;
	}
	/**
	* Replaces windows slash to unix slash
	*/
	#toUnixSlash(fileName) {
		return fileName.startsWith("\\\\?\\") ? fileName : fileName.replace(/\\/g, "/");
	}
	/**
	* Normalizes the filename to be a path with unix slash. The
	* URL style paths are also converted to normalized file
	* paths
	*/
	#normalizeFileName(fileName) {
		if (fileName.startsWith("file:")) return this.#toUnixSlash(fileURLToPath$1(fileName));
		return this.#toUnixSlash(fileName);
	}
	/**
	* Returns the type of the frame.
	*/
	#getFrameType(fileName) {
		return this.#nativeFramesIdentifiers.some((identifier) => fileName.includes(identifier)) || fileName === this.#bunNativeIdentifier ? "native" : fileName.includes("node_modules/") ? "module" : "app";
	}
	/**
	* Returns the source type of the frame.
	*/
	#getFrameSourceType(fileName) {
		return fileName.startsWith("http://") ? "http" : fileName.startsWith("https://") ? "https" : "fs";
	}
	/**
	* Enhances a frame to contain additional information
	*/
	async #enhanceFrames(frames) {
		let stackFrames = [];
		for (const { source: raw, ...frame } of frames) {
			const stackFrame = {
				...frame,
				raw
			};
			if (!stackFrame.fileName) {
				stackFrames.push(stackFrame);
				continue;
			}
			stackFrame.fileName = this.#normalizeFileName(stackFrame.fileName);
			stackFrame.type = this.#getFrameType(stackFrame.fileName);
			stackFrame.fileType = this.#getFrameSourceType(stackFrame.fileName);
			stackFrame.source = await this.#getSource(stackFrame);
			debug_default("stack frame %O", stackFrame);
			stackFrames.push(stackFrame);
		}
		return stackFrames;
	}
	/**
	* Register a parser. Parsers are synchronous functions
	* that can be used to pre-process the source value
	* before it get parsed.
	*
	* @example
	* ```ts
	* sourceFile.useParser((source) => {
	*   if (valueCanBeParsed) {
	*     return newValue
	*   }
	*   return source
	* })
	* ```
	*/
	useParser(parser) {
		this.#parsers.push(parser);
		return this;
	}
	/**
	* Register a transformer. Transformers can be async functions
	* to post-process the parsed error value.
	*
	* @example
	* ```ts
	* sourceFile.useTransformer((error, source) => {
	*   // mutate "error" properties
	* })
	* ```
	*/
	useTransformer(transformer) {
		this.#transformers.push(transformer);
		return this;
	}
	/**
	* Define a custom source loader to load the contents of the
	* source file within the error stack.
	*
	* For example: You might want to register a custom source loader
	* that makes an fetch call to the server to read the source of
	* the file within the error stack.
	*/
	defineSourceLoader(loader) {
		this.#sourceLoader = loader;
		return this;
	}
	/**
	* Parse an unknown value into a parsed error object.
	*/
	async parse(source) {
		debug_default("parsing source %O", source);
		source = this.#parsers.reduce((result, parser) => {
			result = parser(result);
			return result;
		}, source);
		let error = this.#normalizeError(source);
		debug_default("error normalized to %O", error);
		let esFrames = error instanceof SyntaxError ? this.#parseSyntaxError(error) : [];
		esFrames = esFrames.concat(parse$1(error, { allowEmpty: true }));
		esFrames = this.#applyOffset(esFrames);
		const parsedError = {
			message: error.message,
			name: error.name,
			frames: await this.#enhanceFrames(esFrames),
			hint: "hint" in error && error.hint ? String(error.hint) : "help" in error && error.help ? String(error.help) : void 0,
			code: "code" in error ? String(error.code) : void 0,
			cause: error.cause,
			stack: error.stack,
			raw: error
		};
		for (const transformer of this.#transformers) await transformer(parsedError, error);
		return parsedError;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/youch@4.1.0-beta.13/node_modules/youch/build/index.js
var Metadata = class {
	#groups = {};
	/**
	* Converts value to an array (if not an array already)
	*/
	#toArray(value) {
		return Array.isArray(value) ? value : [value];
	}
	/**
	* Define a group, its sections and their rows. In case of
	* existing groups/sections, the new data will be merged
	* with the existing data
	*/
	group(name, sections) {
		this.#groups[name] = this.#groups[name] ?? {};
		Object.keys(sections).forEach((section) => {
			if (!this.#groups[name][section]) this.#groups[name][section] = sections[section];
			else {
				this.#groups[name][section] = this.#toArray(this.#groups[name][section]);
				this.#groups[name][section].push(...this.#toArray(sections[section]));
			}
		});
		return this;
	}
	/**
	* Returns the existing metadata groups, sections and
	* rows.
	*/
	toJSON() {
		return this.#groups;
	}
};
var Templates = class {
	constructor(devMode) {
		this.devMode = devMode;
		this.#knownTemplates = {
			layout: new Layout(devMode),
			header: new Header(devMode),
			errorInfo: new ErrorInfo(devMode),
			errorStack: new ErrorStack(devMode),
			errorStackSource: new ErrorStackSource(devMode),
			errorCause: new ErrorCause(devMode),
			errorMetadata: new ErrorMetadata(devMode)
		};
	}
	#knownTemplates;
	#styles = /* @__PURE__ */ new Map([["global", createStyleSheet()]]);
	#scripts = /* @__PURE__ */ new Map([["global", createScript()]]);
	/**
	* Returns a collection of style and script tags to dump
	* inside the document HEAD.
	*/
	#getStylesAndScripts(cspNonce) {
		let customInjectedStyles = "";
		let globalScript = "";
		const styles = [];
		const scripts = [];
		const cspNonceAttr = cspNonce ? ` nonce="${cspNonce}"` : "";
		this.#styles.forEach((bucket, name) => {
			if (name === "injected") customInjectedStyles = `<style id="${name}-styles"${cspNonceAttr}>${bucket}</style>`;
			else styles.push(`<style id="${name}-styles"${cspNonceAttr}>${bucket}</style>`);
		});
		this.#scripts.forEach((bucket, name) => {
			if (name === "global") globalScript = `<script id="${name}-script"${cspNonceAttr}>${bucket}<\/script>`;
			scripts.push(`<script id="${name}-script"${cspNonceAttr}>${bucket}<\/script>`);
		});
		return {
			styles: `${styles.join("\n")}
${customInjectedStyles}`,
			scripts: scripts.join("\n"),
			globalScript
		};
	}
	/**
	* Collects styles and scripts for components as we render
	* them.
	*/
	async #collectStylesAndScripts(templateName) {
		if (!this.#styles.has(templateName)) {
			const styles = await this.#knownTemplates[templateName].getStyles();
			if (styles) this.#styles.set(templateName, styles);
		}
		if (!this.#scripts.has(templateName)) {
			const script = await this.#knownTemplates[templateName].getScript();
			if (script) this.#scripts.set(templateName, script);
		}
	}
	/**
	* Returns the HTML for a given template
	*/
	async #tmplToHTML(templateName, props) {
		const component = this.#knownTemplates[templateName];
		if (!component) throw new Error(`Invalid template "${templateName}"`);
		await this.#collectStylesAndScripts(templateName);
		return component.toHTML(props);
	}
	/**
	* Returns the ANSI output for a given template
	*/
	async #tmplToANSI(templateName, props) {
		const component = this.#knownTemplates[templateName];
		if (!component) throw new Error(`Invalid template "${templateName}"`);
		return component.toANSI(props);
	}
	/**
	* Define a custom component to be used in place of the default component.
	* Overriding components allows you control the HTML layout, styles and
	* the frontend scripts of an HTML fragment.
	*/
	use(templateName, component) {
		this.#knownTemplates[templateName] = component;
		return this;
	}
	/**
	* Inject custom styles to the document. Injected styles are
	* always placed after the global and the components style
	* tags.
	*/
	injectStyles(cssFragment) {
		let injectedStyles = this.#styles.get("injected") ?? "";
		injectedStyles += `
${cssFragment}`;
		this.#styles.set("injected", injectedStyles);
		return this;
	}
	/**
	* Returns the HTML output for the given parsed error
	*/
	async toHTML(props) {
		const html = await this.#tmplToHTML("layout", {
			title: props.title,
			ide: props.ide,
			cspNonce: props.cspNonce,
			children: async () => {
				return `${await this.#tmplToHTML("header", props)}${await this.#tmplToHTML("errorInfo", props)}${await this.#tmplToHTML("errorStack", {
					ide: process.env.EDITOR ?? "vscode",
					sourceCodeRenderer: (error, frame) => {
						return this.#tmplToHTML("errorStackSource", {
							error,
							frame,
							ide: props.ide,
							cspNonce: props.cspNonce
						});
					},
					...props
				})}${await this.#tmplToHTML("errorCause", props)}${await this.#tmplToHTML("errorMetadata", props)}`;
			}
		});
		const { globalScript, scripts, styles } = this.#getStylesAndScripts(props.cspNonce);
		return html.replace("<!-- STYLES -->", styles).replace("<!-- SCRIPTS -->", scripts).replace("<!-- GLOBAL SCRIPT -->", globalScript);
	}
	/**
	* Returns the ANSI output to be printed on the terminal
	*/
	async toANSI(props) {
		return await this.#tmplToANSI("layout", {
			title: props.title,
			children: async () => {
				return `${await this.#tmplToANSI("header", {})}${await this.#tmplToANSI("errorInfo", props)}${await this.#tmplToANSI("errorStack", {
					ide: process.env.EDITOR ?? "vscode",
					sourceCodeRenderer: (error, frame) => {
						return this.#tmplToANSI("errorStackSource", {
							error,
							frame
						});
					},
					...props
				})}${await this.#tmplToANSI("errorCause", props)}${await this.#tmplToANSI("errorMetadata", props)}`;
			}
		});
	}
};
var Youch = class {
	/**
	* Properties to be shared with the Error parser
	*/
	#sourceLoader;
	#parsers = [];
	#transformers = [];
	/**
	* Manage templates used for converting error to the HTML
	* output
	*/
	templates = new Templates(false);
	/**
	* Define metadata to be displayed alongside the error output
	*/
	metadata = new Metadata();
	/**
	* Creates an instance of the ErrorParser and applies the
	* source loader, parsers and transformers on it
	*/
	#createErrorParser(options) {
		const errorParser = new ErrorParser(options);
		if (this.#sourceLoader) errorParser.defineSourceLoader(this.#sourceLoader);
		this.#parsers.forEach((parser) => errorParser.useParser(parser));
		this.#transformers.forEach((transformer) => errorParser.useTransformer(transformer));
		return errorParser;
	}
	/**
	* Defines the request properties as a metadata group
	*/
	#defineRequestMetadataGroup(request) {
		if (!request || Object.keys(request).length === 0) return;
		this.metadata.group("Request", {
			...request.url ? { url: {
				key: "URL",
				value: request.url
			} } : {},
			...request.method ? { method: {
				key: "Method",
				value: request.method
			} } : {},
			...request.headers ? { headers: Object.keys(request.headers).map((key) => {
				const value = request.headers[key];
				return {
					key,
					value: key === "cookie" ? { ...parse$3(value) } : value
				};
			}) } : {}
		});
	}
	/**
	* Define custom implementation for loading the source code
	* of a stack frame.
	*/
	defineSourceLoader(loader) {
		this.#sourceLoader = loader;
		return this;
	}
	/**
	* Define a custom parser. Parsers are executed before the
	* error gets parsed and provides you with an option to
	* modify the error
	*/
	useParser(parser) {
		this.#parsers.push(parser);
		return this;
	}
	/**
	* Define a custom transformer. Transformers are executed
	* after the error has been parsed and can mutate the
	* properties of the parsed error.
	*/
	useTransformer(transformer) {
		this.#transformers.push(transformer);
		return this;
	}
	/**
	* Parses error to JSON
	*/
	async toJSON(error, options) {
		options = { ...options };
		return this.#createErrorParser({ offset: options.offset }).parse(error);
	}
	/**
	* Render error to HTML
	*/
	async toHTML(error, options) {
		options = { ...options };
		this.#defineRequestMetadataGroup(options.request);
		const parsedError = await this.#createErrorParser({ offset: options.offset }).parse(error);
		return this.templates.toHTML({
			title: options.title ?? "An error has occurred",
			ide: options.ide ?? process.env.IDE ?? "vscode",
			cspNonce: options.cspNonce,
			error: parsedError,
			metadata: this.metadata
		});
	}
	/**
	* Render error to ANSI output
	*/
	async toANSI(error, options) {
		options = { ...options };
		const parsedError = await this.#createErrorParser({ offset: options.offset }).parse(error);
		return this.templates.toANSI({
			title: "",
			error: parsedError,
			metadata: this.metadata
		});
	}
};

//#endregion
//#region src/dev/error.ts
async function renderError(req, res, error) {
	if (res.headersSent) {
		if (!res.writableEnded) res.end();
		return;
	}
	const youch = new Youch();
	res.statusCode = 500;
	res.setHeader("Content-Type", "text/html");
	res.setHeader("Cache-Control", "no-store");
	res.setHeader("Refresh", "3");
	const html = await youch.toHTML(error, { request: {
		url: req.url,
		method: req.method,
		headers: req.headers
	} });
	res.end(html);
}

//#endregion
//#region src/dev/utils.ts
const RESTART_RE = /^(?:nuxt\.config\.[a-z0-9]+|\.nuxtignore|\.nuxtrc|\.config\/nuxt(?:\.config)?\.[a-z0-9]+)$/;
var FileChangeTracker = class {
	mtimes = /* @__PURE__ */ new Map();
	shouldEmitChange(filePath) {
		const resolved = resolve$2(filePath);
		try {
			const currentMtime = statSync(resolved).mtimeMs;
			const lastMtime = this.mtimes.get(resolved);
			this.mtimes.set(resolved, currentMtime);
			return lastMtime === void 0 || currentMtime !== lastMtime;
		} catch {
			this.mtimes.delete(resolved);
			return true;
		}
	}
	prime(filePath, recursive = false) {
		const resolved = resolve$2(filePath);
		const stat = statSync(resolved);
		this.mtimes.set(resolved, stat.mtimeMs);
		if (stat.isDirectory()) {
			const entries = readdirSync(resolved);
			for (const entry of entries) {
				const fullPath = resolve$2(resolved, entry);
				try {
					const stats = statSync(fullPath);
					this.mtimes.set(fullPath, stats.mtimeMs);
					if (recursive && stats.isDirectory()) this.prime(fullPath, recursive);
				} catch {}
			}
		}
	}
};
var NuxtDevServer = class extends EventEmitter {
	#handler;
	#distWatcher;
	#configWatcher;
	#currentNuxt;
	#loadingMessage;
	#loadingError;
	#fileChangeTracker = new FileChangeTracker();
	#cwd;
	#websocketConnections = /* @__PURE__ */ new Set();
	loadDebounced;
	handler;
	listener;
	constructor(options) {
		super();
		this.options = options;
		this.loadDebounced = debounce(this.load);
		let _initResolve;
		const _initPromise = new Promise((resolve) => {
			_initResolve = resolve;
		});
		this.once("ready", () => {
			_initResolve();
		});
		this.#cwd = options.cwd;
		this.handler = async (req, res) => {
			if (this.#loadingError) {
				renderError(req, res, this.#loadingError);
				return;
			}
			await _initPromise;
			if (this.#handler) this.#handler(req, res);
			else this.#renderLoadingScreen(req, res);
		};
	}
	async #renderLoadingScreen(req, res) {
		if (res.headersSent) {
			if (!res.writableEnded) res.end();
			return;
		}
		res.statusCode = 503;
		res.setHeader("Content-Type", "text/html");
		const loadingTemplate = this.options.loadingTemplate || this.#currentNuxt?.options.devServer.loadingTemplate || await resolveLoadingTemplate(this.#cwd);
		res.end(loadingTemplate({ loading: this.#loadingMessage || "Loading..." }));
	}
	async init() {
		this.#loadingMessage = `Starting Nuxt...`;
		this.#handler = void 0;
		this.emit("loading", this.#loadingMessage);
		await this.#loadNuxtInstance();
		if (this.options.showBanner) showVersionsFromConfig(this.options.cwd, this.#currentNuxt.options);
		await this.#createListener();
		await this.#initializeNuxt(false);
		this.#watchConfig();
	}
	closeWatchers() {
		this.#distWatcher?.close();
		this.#configWatcher?.();
	}
	async load(reload, reason) {
		try {
			this.closeWatchers();
			await this.#load(reload, reason);
			this.#loadingError = void 0;
		} catch (error) {
			console.error(`Cannot ${reload ? "restart" : "start"} nuxt: `, error);
			this.#handler = void 0;
			this.#loadingError = error;
			this.#loadingMessage = "Error while loading Nuxt. Please check console and fix errors.";
			this.emit("loading:error", error);
		}
		this.#watchConfig();
	}
	async #loadNuxtInstance(urls) {
		const kit = await loadKit(this.options.cwd);
		const loadOptions = {
			cwd: this.options.cwd,
			dev: true,
			ready: false,
			envName: this.options.envName,
			dotenv: {
				cwd: this.options.cwd,
				fileName: this.options.dotenv.fileName
			},
			overrides: {
				logLevel: this.options.logLevel,
				...this.options.overrides,
				vite: {
					clearScreen: this.options.clear,
					...this.options.overrides.vite
				}
			}
		};
		if (urls) {
			const overrides = this.options.listenOverrides || {};
			const hostname = overrides.hostname;
			const https = overrides.https;
			loadOptions.defaults = resolveDevServerDefaults({
				hostname,
				https
			}, urls);
		}
		this.#currentNuxt = await kit.loadNuxt(loadOptions);
	}
	async #createListener() {
		if (!this.#currentNuxt) throw new Error("Nuxt must be loaded before creating listener");
		const listenOptions = this.#resolveListenOptions();
		this.listener = await listen(this.handler, listenOptions);
		if (listenOptions.public) {
			this.#currentNuxt.options.devServer.cors = { origin: "*" };
			if (this.#currentNuxt.options.vite?.server) this.#currentNuxt.options.vite.server.allowedHosts = true;
			return;
		}
		const urls = await this.listener.getURLs().then((r) => r.map((r) => r.url));
		if (urls && urls.length > 0) this.#currentNuxt.options.vite = defu(this.#currentNuxt.options.vite, { server: { allowedHosts: urls.map((u) => new URL(u).hostname) } });
	}
	#resolveListenOptions() {
		if (!this.#currentNuxt) throw new Error("Nuxt must be loaded before resolving listen options");
		const nuxtConfig = this.#currentNuxt.options;
		const overrides = this.options.listenOverrides || {};
		const port = overrides.port ?? nuxtConfig.devServer?.port;
		const hostname = overrides.hostname ?? nuxtConfig.devServer?.host;
		const isPublic = p$2 === "codesandbox" || (overrides.public ?? (isPublicHostname(hostname) ? true : void 0));
		const httpsFromConfig = typeof nuxtConfig.devServer?.https !== "boolean" && nuxtConfig.devServer?.https ? nuxtConfig.devServer.https : {};
		overrides._https ??= !!nuxtConfig.devServer?.https;
		const httpsOptions = overrides.https && defu(typeof overrides.https === "object" ? overrides.https : {}, httpsFromConfig);
		const baseURL = nuxtConfig.app?.baseURL?.startsWith?.("./") ? nuxtConfig.app.baseURL.slice(1) : nuxtConfig.app?.baseURL;
		return {
			...overrides,
			port,
			hostname,
			public: isPublic,
			https: httpsOptions || void 0,
			baseURL
		};
	}
	async #initializeNuxt(reload) {
		if (!this.#currentNuxt) throw new Error("Nuxt must be loaded before configuration");
		if (!process$1.env.NUXI_DISABLE_VITE_HMR) this.#currentNuxt.hooks.hook("vite:extend", ({ config }) => {
			if (config.server) config.server.hmr = {
				protocol: void 0,
				...config.server.hmr,
				port: void 0,
				host: void 0,
				server: this.listener.server
			};
		});
		this.#currentNuxt.hooks.hookOnce("close", () => {
			this.#closeWebSocketConnections();
			this.listener.server.removeAllListeners("upgrade");
		});
		if (!reload) {
			const previousManifest = await loadNuxtManifest(this.#currentNuxt.options.buildDir);
			const newManifest = resolveNuxtManifest(this.#currentNuxt);
			const promise = writeNuxtManifest(this.#currentNuxt, newManifest);
			this.#currentNuxt.hooks.hookOnce("ready", async () => {
				await promise;
			});
			if (previousManifest && newManifest && previousManifest._hash !== newManifest._hash) await clearBuildDir(this.#currentNuxt.options.buildDir);
		}
		await this.#currentNuxt.ready();
		const unsub = this.#currentNuxt.hooks.hook("restart", async (options) => {
			unsub();
			if (options?.hard) {
				this.emit("restart");
				return;
			}
			await this.load(true);
		});
		if (this.#currentNuxt.server && "upgrade" in this.#currentNuxt.server) this.listener.server.on("upgrade", (req, socket, head) => {
			const nuxt = this.#currentNuxt;
			if (!nuxt || !nuxt.server) return;
			const viteHmrPath = joinURL(nuxt.options.app.baseURL.startsWith("./") ? nuxt.options.app.baseURL.slice(1) : nuxt.options.app.baseURL, nuxt.options.app.buildAssetsDir);
			if (req.url?.startsWith(viteHmrPath)) return;
			nuxt.server.upgrade(req, socket, head);
			this.#websocketConnections.add(socket);
			socket.on("close", () => {
				this.#websocketConnections.delete(socket);
			});
		});
		await this.#currentNuxt.hooks.callHook("listen", this.listener.server, this.listener);
		const addr = this.listener.address;
		this.#currentNuxt.options.devServer.host = addr.address;
		this.#currentNuxt.options.devServer.port = addr.port;
		this.#currentNuxt.options.devServer.url = getAddressURL(addr, !!this.listener.https);
		this.#currentNuxt.options.devServer.https = this.listener.https;
		if (this.listener.https && !process$1.env.NODE_TLS_REJECT_UNAUTHORIZED) console.warn("You might need `NODE_TLS_REJECT_UNAUTHORIZED=0` environment variable to make https work.");
		const kit = await loadKit(this.options.cwd);
		const typesPromise = existsSync(join$1(this.#currentNuxt.options.buildDir, "tsconfig.json")) ? kit.writeTypes(this.#currentNuxt).catch(console.error) : await kit.writeTypes(this.#currentNuxt).catch(console.error);
		await Promise.all([typesPromise, kit.buildNuxt(this.#currentNuxt)]);
		if (!this.#currentNuxt.server) throw new Error("Nitro server has not been initialized.");
		const distDir = join$1(this.#currentNuxt.options.buildDir, "dist");
		await mkdir(distDir, { recursive: true });
		this.#fileChangeTracker.prime(distDir);
		this.#distWatcher = watch(distDir);
		this.#distWatcher.on("change", (_event, file) => {
			if (!this.#fileChangeTracker.shouldEmitChange(resolve$2(distDir, file || ""))) return;
			this.loadDebounced(true, ".nuxt/dist directory has been removed");
		});
		if ("fetch" in this.#currentNuxt.server) this.#handler = toNodeHandler(this.#currentNuxt.server.fetch);
		else this.#handler = toNodeListener(this.#currentNuxt.server.app);
		const proto = this.listener.https ? "https" : "http";
		this.emit("ready", `${proto}://127.0.0.1:${addr.port}`);
	}
	async close() {
		if (this.#currentNuxt) await this.#currentNuxt.close();
	}
	#closeWebSocketConnections() {
		for (const socket of this.#websocketConnections) socket.destroy();
		this.#websocketConnections.clear();
	}
	async #load(reload, reason) {
		const action = reload ? "Restarting" : "Starting";
		this.#loadingMessage = `${reason ? `${reason}. ` : ""}${action} Nuxt...`;
		this.#handler = void 0;
		this.emit("loading", this.#loadingMessage);
		if (reload) console.info(this.#loadingMessage);
		await this.close();
		const urls = await this.listener.getURLs().then((r) => r.map((r) => r.url));
		await this.#loadNuxtInstance(urls);
		await this.#initializeNuxt(!!reload);
	}
	#watchConfig() {
		this.#configWatcher = createConfigWatcher(this.#cwd, this.options.dotenv.fileName, () => this.emit("restart"), (file) => this.loadDebounced(true, `${file} updated`));
	}
};
function getAddressURL(addr, https) {
	const proto = https ? "https" : "http";
	let host = addr.address.includes(":") ? `[${addr.address}]` : addr.address;
	if (host === "[::]") host = "localhost";
	const port = addr.port || 3e3;
	return `${proto}://${host}:${port}/`;
}
function resolveDevServerDefaults(listenOptions, urls = []) {
	const defaultConfig = {};
	if (urls && urls.length > 0) defaultConfig.vite = { server: { allowedHosts: urls.map((u) => new URL(u).hostname) } };
	if (listenOptions.hostname) {
		defaultConfig.devServer = { cors: { origin: [`${listenOptions.https ? "https" : "http"}://${listenOptions.hostname}`, ...urls] } };
		defaultConfig.vite = defu(defaultConfig.vite, { server: { allowedHosts: [listenOptions.hostname] } });
	}
	return defaultConfig;
}
function createConfigWatcher(cwd, dotenvFileName = ".env", onRestart, onReload) {
	const fileWatcher = new FileChangeTracker();
	fileWatcher.prime(cwd);
	const configWatcher = watch(cwd);
	let configDirWatcher = existsSync(join$1(cwd, ".config")) ? createConfigDirWatcher(cwd, onReload) : void 0;
	const dotenvFileNames = new Set(Array.isArray(dotenvFileName) ? dotenvFileName : [dotenvFileName]);
	configWatcher.on("change", (_event, file) => {
		if (!fileWatcher.shouldEmitChange(resolve$2(cwd, file))) return;
		if (dotenvFileNames.has(file)) onRestart();
		if (RESTART_RE.test(file)) onReload(file);
		if (file === ".config") configDirWatcher ||= createConfigDirWatcher(cwd, onReload);
	});
	return () => {
		configWatcher.close();
		configDirWatcher?.();
	};
}
function createConfigDirWatcher(cwd, onReload) {
	const configDir = join$1(cwd, ".config");
	const fileWatcher = new FileChangeTracker();
	fileWatcher.prime(configDir);
	const configDirWatcher = watch(configDir);
	configDirWatcher.on("change", (_event, file) => {
		if (!fileWatcher.shouldEmitChange(resolve$2(configDir, file))) return;
		if (RESTART_RE.test(file)) onReload(file);
	});
	return () => configDirWatcher.close();
}
async function resolveLoadingTemplate(cwd) {
	return (await import(pathToFileURL(resolveModulePath("@nuxt/ui-templates", { from: withNodePath(resolveModulePath("nuxt", {
		from: withNodePath(cwd),
		try: true
	}) || cwd) })).href)).loading || ((params) => `<h2>${params.loading}</h2>`);
}
function isPublicHostname(hostname) {
	return !!hostname && ![
		"localhost",
		"127.0.0.1",
		"::1"
	].includes(hostname);
}

//#endregion
export { require_lib as a, listenAndWatch as i, createDevServer as n, require_http_shutdown as o, listen as r, NuxtDevServer as t };